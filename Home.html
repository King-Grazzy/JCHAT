<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Last updated: 2025-08-21T18:19:29Z -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JCHAT - Home</title>
    <link rel="canonical" href="https://jchat.app/Home.html">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/1a1a2e/ffffff?text=J">
    <meta name="apple-mobile-web-app-title" content="JCHAT">
    
    <!-- Security Meta Tags -->
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="JCHAT - Modern social chat platform with levels, JCoins, and community features">
    <meta name="keywords" content="chat, social, messaging, community, levels, gaming">
    <meta name="author" content="JCHAT Team">
    <meta name="robots" content="index, follow">
    <meta name="theme-color" content="#1a1a2e">
    <meta property="og:title" content="JCHAT - Home">
    <meta property="og:description" content="Modern social chat platform with levels, JCoins, and community features">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://placehold.co/1200x630/1a1a2e/ffffff?text=JCHAT">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' ry='12' fill='%231a1a2e'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Poppins, Arial, sans-serif' font-size='28' fill='%23ffffff'%3EJ%3C/text%3E%3C/svg%3E">

    <!-- Google Fonts: Poppins for headings, Inter for body text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Preconnect to Firebase and Cloudinary domains for faster loading -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://firebaseio.com" crossorigin>
    <link rel="preconnect" href="https://res.cloudinary.com" crossorigin>
    <link rel="preconnect" href="https://api.cloudinary.com" crossorigin>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
    <!-- Tone.js for audio notifications -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <style>
        /* Universal box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Global CSS Variables for easy theme switching */
        :root {
            --pink: #ff2e92;
            --blue: #00d5ff;
            --glass-black: rgba(10, 10, 10, .75);
            --glass-blue: rgba(0, 213, 255, .15);
            --radius: 20px;
            --transition: .3s ease;

            /* These variables will be overridden by theme classes */
            --white: #fff;
            --text-light: rgba(255, 255, 255, .7);
            --background-main: rgba(10, 10, 10, .75);
            --background-gradient-1: #00d5ff;
            --background-gradient-2: #ff2e92;
            --card-background: linear-gradient(145deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .01));
            --header-background: linear-gradient(135deg, rgba(10, 10, 10, .85), rgba(10, 10, 10, .75));
            --border-light: rgba(255, 255, 255, .05);
            --input-background: rgba(255, 255, 255, 0.05);
            --button-background: linear-gradient(90deg, var(--blue), var(--pink));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);

            /* New variables for consistent theming (Added for consistency with Profile/Levels) */
            --background-color-primary: #1a1a2e;
            --background-color-secondary: #0f0f1f;
            --header-background-color: #2a2a4a;
            --footer-background-color: #2a2a4a;
            --content-background-color: #20203a;
            --card-background-color: #2a2a4a;
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            /* --notification-badge-color: Hardcoded for visibility */
            --status-online: #4CAF50;
            --status-offline: #6c757d;
            --status-away: #FFC107;
            --delete-button-color: #dc3545;
            --warning-color: #ffc107;
            --accent-color: #00d5ff; /* A bright cyan */
            --accent-color-dark: #00aaff;
            --border-color: #3a3a5a;
            --theme-gold: #ffd700;
        }

        /* Pink and Blue Glowing Loader */
        .jchat-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 10, 10, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .jchat-loader.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader-container {
            text-align: center;
            position: relative;
        }

        .loader-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid transparent;
            border-radius: 50%;
            position: relative;
            margin: 0 auto 20px;
            animation: spin 2s linear infinite;
        }

        .loader-spinner::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 4px solid transparent;
            border-top: 4px solid var(--pink);
            border-right: 4px solid var(--blue);
            border-radius: 50%;
            animation: spin 1.5s linear infinite reverse;
            filter: drop-shadow(0 0 20px var(--pink)) drop-shadow(0 0 20px var(--blue));
        }

        .loader-spinner::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            border: 3px solid transparent;
            border-bottom: 3px solid var(--pink);
            border-left: 3px solid var(--blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            filter: drop-shadow(0 0 15px var(--pink)) drop-shadow(0 0 15px var(--blue));
        }

        .loader-text {
            color: var(--white);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--pink), var(--blue), var(--pink));
            background-size: 200% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 2s ease-in-out infinite;
        }

        .loader-subtext {
            color: var(--text-light);
            font-size: 14px;
            opacity: 0.7;
            animation: pulse 2s ease-in-out infinite;
        }

        .loader-dots {
            display: inline-flex;
            gap: 4px;
            margin-left: 5px;
        }

        .loader-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--pink), var(--blue));
            animation: bounce 1.4s ease-in-out infinite;
            filter: drop-shadow(0 0 8px var(--pink)) drop-shadow(0 0 8px var(--blue));
        }

        .loader-dot:nth-child(1) { animation-delay: -0.32s; }
        .loader-dot:nth-child(2) { animation-delay: -0.16s; }
        .loader-dot:nth-child(3) { animation-delay: 0s; }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes bounce {
            0%, 80%, 100% { 
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Loader progress bar */
        .loader-progress { width: 220px; height: 6px; margin: 12px auto 0; border-radius: 999px; background: rgba(255,255,255,0.1); overflow: hidden; border: 1px solid var(--border-light); }
        .loader-progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, var(--blue), var(--pink)); }

        /* Respect reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            .loader-spinner, .loader-spinner::before, .loader-spinner::after, .loader-text, .loader-subtext, .loader-dot { animation: none !important; }
        }

        /* Loader particle effects */
        .loader-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            margin: -100px 0 0 -100px;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--pink);
            box-shadow: 0 0 10px var(--pink);
            animation: orbit 4s linear infinite;
        }

        .particle:nth-child(1) {
            background: var(--blue);
            box-shadow: 0 0 10px var(--blue);
            animation-delay: 0s;
            animation-duration: 3s;
        }

        .particle:nth-child(2) {
            animation-delay: -1s;
            animation-duration: 4s;
        }

        .particle:nth-child(3) {
            background: var(--blue);
            box-shadow: 0 0 10px var(--blue);
            animation-delay: -2s;
            animation-duration: 3.5s;
        }

        .particle:nth-child(4) {
            animation-delay: -3s;
            animation-duration: 4.5s;
        }

        @keyframes orbit {
            0% {
                transform: rotate(0deg) translateX(100px) rotate(0deg);
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
            100% {
                transform: rotate(360deg) translateX(100px) rotate(-360deg);
                opacity: 1;
            }
        }

        /* Theme Switcher Button - Enhanced for Dark/Light Mode */
        .theme-switcher-btn {
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.8), rgba(255, 46, 146, 0.8));
            color: var(--white);
            border: 2px solid transparent;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .theme-switcher-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, var(--accent-color), var(--pink));
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 50%;
        }

        .theme-switcher-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 213, 255, 0.4), 0 6px 20px rgba(255, 46, 146, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .theme-switcher-btn:hover::before {
            opacity: 0.1;
        }

        .theme-switcher-btn:active {
            transform: scale(0.95);
        }

        /* Theme-specific button styling */
        body.theme-light-mode .theme-switcher-btn {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.2);
        }

        body.theme-light-mode .theme-switcher-btn:hover {
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4), 0 6px 20px rgba(139, 92, 246, 0.4);
            border-color: rgba(59, 130, 246, 0.4);
        }

        body.theme-dark-mode .theme-switcher-btn {
            background: linear-gradient(45deg, #00d5ff, #ff2e92);
            box-shadow: 0 4px 15px rgba(0, 213, 255, 0.3), 0 4px 15px rgba(255, 46, 146, 0.3);
            border-color: rgba(0, 213, 255, 0.2);
        }

        body.theme-dark-mode .theme-switcher-btn:hover {
            box-shadow: 0 6px 20px rgba(0, 213, 255, 0.4), 0 6px 20px rgba(255, 46, 146, 0.4);
            border-color: rgba(0, 213, 255, 0.4);
        }

        /* Skip link focus for accessibility */
        .skip-link:focus {
            position: static !important;
            left: auto !important;
            width: auto !important;
            height: auto !important;
            padding: 8px 12px;
            background: var(--button-background);
            color: var(--white);
            border-radius: 8px;
            outline: 2px solid var(--accent-color);
            z-index: 9999;
        }
        /* --- Theme Definitions (Light and Dark Mode) --- */
        /* Light Mode - Premium Platinum Minimal */
        body.theme-light-mode {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 25%, #cbd5e1 50%, #94a3b8 75%, #64748b 100%) !important;
            background-size: 400% 400% !important;
            animation: platinumShimmer 20s ease-in-out infinite !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #f8fafc 0%, #64748b 100%);
            --background-gradient-1: #e2e8f0;
            --background-gradient-2: #cbd5e1;
            --white: #1e293b;
            --text-light: #475569;
            --card-background: rgba(255, 255, 255, 0.95);
            --header-background: rgba(248, 250, 252, 0.98);
            --border-light: rgba(148, 163, 184, 0.2);
            --input-background: rgba(241, 245, 249, 0.8);
            --button-background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            --button-shadow: 0 4px 15px rgba(59, 130, 246, 0.3), 0 4px 15px rgba(29, 78, 216, 0.3);
            --background-color-primary: #f8fafc;
            --background-color-secondary: #e2e8f0;
            --header-background-color: #ffffff;
            --footer-background-color: #ffffff;
            --content-background-color: #f1f5f9;
            --card-background-color: #ffffff;
            --text-color-primary: #1e293b;
            --text-color-secondary: #475569;
            --text-color-light: #64748b;
            --accent-color: #3b82f6;
            --accent-color-dark: #1d4ed8;
            --border-color: #e2e8f0;
            --input-background-color: #f1f5f9;
            --button-hover-background: #2563eb;
            --active-item-background: rgba(59, 130, 246, 0.1);
            --status-online: #10b981;
            --status-offline: #6b7280;
            --status-away: #f59e0b;
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
            box-shadow: inset 0 0 100px rgba(59, 130, 246, 0.05) !important;
        }
        
        @keyframes platinumShimmer {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 25%; }
            50% { background-position: 100% 75%; }
            75% { background-position: 0% 100%; }
        }

        /* Dark Mode - Premium Starlight Noir */
        body.theme-dark-mode {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%) !important;
            background-size: 400% 400% !important;
            animation: starlightDrift 25s ease-in-out infinite !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #0f0f23 0%, #533483 100%);
            --background-gradient-1: #16213e;
            --background-gradient-2: #0f3460;
            --white: #e2e8f0;
            --text-light: #94a3b8;
            --card-background: rgba(30, 41, 59, 0.8);
            --header-background: linear-gradient(135deg, rgba(15, 15, 35, 0.95), rgba(26, 26, 46, 0.9));
            --border-light: rgba(148, 163, 184, 0.15);
            --input-background: rgba(51, 65, 85, 0.6);
            --button-background: linear-gradient(90deg, #8b5cf6, #7c3aed);
            --button-shadow: 0 4px 15px rgba(139, 92, 246, 0.4), 0 4px 15px rgba(124, 58, 237, 0.4);
            --background-color-primary: #0f172a;
            --background-color-secondary: #1e293b;
            --header-background-color: #1e293b;
            --footer-background-color: #1e293b;
            --content-background-color: #334155;
            --card-background-color: #475569;
            --text-color-primary: #f1f5f9;
            --text-color-secondary: #cbd5e1;
            --accent-color: #8b5cf6;
            --accent-color-dark: #7c3aed;
            --border-color: #475569;
            --input-background-color: #334155;
            --button-hover-background: #a855f7;
            --active-item-background: rgba(139, 92, 246, 0.2);
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
            box-shadow: inset 0 0 100px rgba(139, 92, 246, 0.1) !important;
        }
        
        @keyframes starlightDrift {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 25%; }
            50% { background-position: 100% 75%; }
            75% { background-position: 0% 100%; }
        }

        /* Sunset Theme */
        body.theme-sunset-mode {
            background: linear-gradient(to top, #ff7e5f, #feb47b) !important;
            background-color: transparent !important;
            background-image: linear-gradient(to top, #ff7e5f, #feb47b) !important;
            --background-main: linear-gradient(to top, #ff7e5f, #feb47b);
            --card-background: rgba(255, 255, 255, 0.15);
            --white: #fff;
            --text-light: rgba(255, 255, 255, 0.8);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.3);
            --button-background: linear-gradient(90deg, #fd746c, #ff9068);
            --button-shadow: 0 4px 15px rgba(253, 116, 108, 0.4), 0 4px 15px rgba(255, 144, 104, 0.4);
            --background-color-primary: #ff7e5f;
            --background-color-secondary: #feb47b;
            --header-background-color: rgba(255, 126, 95, 0.9);
            --footer-background-color: rgba(255, 126, 95, 0.9);
            --content-background-color: rgba(255, 126, 95, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.15);
            --text-color-primary: #fff;
            --text-color-secondary: rgba(255, 255, 255, 0.8);
            --accent-color: #fd746c;
            --accent-color-dark: #ff9068;
            --border-color: rgba(255, 255, 255, 0.3);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #fd746c, #ff9068);
            --button-hover-background: #ff9068;
            --active-item-background: rgba(253, 116, 108, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #dc143c;
            --warning-color: #ffd700;
        }
        /* Glass Mode specific variables */
        body.theme-glass-mode {
            --background-main: rgba(10, 10, 10, 0.75);
            background-image: url('https://source.unsplash.com/random/1920x1080?abstract,blur') !important; /* Added !important */
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            backdrop-filter: blur(10px);
            --card-background: rgba(25, 25, 40, 0.7);
            --white: #e0e0e0; /* text-color */
            --text-light: rgba(255, 255, 255, 0.7);
            --input-background: rgba(255, 255, 255, 0.05);
            --border-light: rgba(255, 255, 255, 0.1); /* glass-border-color */
            --button-background: linear-gradient(90deg, var(--pink), var(--blue));
            --button-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5); /* Inner shadow for glass effect */

            /* New variables override for glass mode */
            --background-color-primary: rgba(10, 10, 10, 0.75);
            --background-color-secondary: rgba(10, 10, 10, 0.6);
            --header-background-color: rgba(10, 10, 10, 0.85);
            --footer-background-color: rgba(10, 10, 10, 0.85);
            --content-background-color: rgba(10, 10, 10, 0.75);
            --card-background-color: rgba(25, 25, 40, 0.7);
            --text-color-primary: #e0e0e0;
            --text-color-secondary: #b0b0d0;
            --accent-color: #00d5ff;
            --accent-color-dark: #00aaff;
            --border-color: rgba(255, 255, 255, 0.1);
            --input-background-color: rgba(255, 255, 255, 0.05);
            --button-background: rgba(0, 213, 255, 0.15); /* Glassy button */
            --button-hover-background: rgba(0, 213, 255, 0.25);
            --active-item-background: rgba(0, 213, 255, 0.1);
        }

        /* Ocean Theme - Premium Deep Waters with Animated Waves */
        body.theme-ocean-mode {
            background: linear-gradient(135deg, #001f3f 0%, #0074d9 20%, #7fdbff 40%, #39cccc 60%, #01ff70 80%, #2ecc40 100%) !important;
            background-size: 400% 400% !important;
            animation: oceanWaves 15s ease-in-out infinite !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #001f3f 0%, #2ecc40 100%);
            --card-background: rgba(0, 116, 217, 0.15);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.9);
            --input-background: rgba(0, 116, 217, 0.1);
            --border-light: rgba(127, 219, 255, 0.4);
            --button-background: linear-gradient(45deg, #0074d9, #7fdbff, #39cccc);
            --button-shadow: 0 8px 25px rgba(0, 116, 217, 0.4), 0 0 30px rgba(127, 219, 255, 0.3);
            --background-color-primary: rgba(0, 31, 63, 0.95);
            --background-color-secondary: rgba(0, 116, 217, 0.9);
            --header-background-color: rgba(0, 31, 63, 0.95);
            --footer-background-color: rgba(57, 204, 204, 0.9);
            --content-background-color: rgba(0, 116, 217, 0.08);
            --card-background-color: rgba(127, 219, 255, 0.12);
            --text-color-primary: #ffffff;
            --text-color-secondary: #e6f9ff;
            --accent-color: #7fdbff;
            --accent-color-dark: #0074d9;
            --border-color: rgba(127, 219, 255, 0.5);
            --input-background-color: rgba(0, 116, 217, 0.1);
            --button-hover-background: #39cccc;
            --active-item-background: rgba(127, 219, 255, 0.25);
            --delete-button-color: #ff6b6b;
            --warning-color: #ffdc00;
            box-shadow: inset 0 0 100px rgba(127, 219, 255, 0.1) !important;
        }
        
        @keyframes oceanWaves {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 25%; }
            50% { background-position: 100% 75%; }
            75% { background-position: 0% 100%; }
        }

        /* Forest Theme - Premium Enchanted Woods with Particle Effects */
        body.theme-forest-mode {
            background: linear-gradient(135deg, #064e3b, #065f46, #047857, #059669) !important;
            background-color: transparent !important;
            background-image: linear-gradient(135deg, #064e3b, #065f46, #047857, #059669) !important;
            --background-main: linear-gradient(135deg, #064e3b, #065f46, #047857, #059669);
            --card-background: rgba(255, 255, 255, 0.1);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.9);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.2);
            --button-background: linear-gradient(90deg, #059669, #10b981);
            --button-shadow: 0 4px 15px rgba(5, 150, 105, 0.4), 0 4px 15px rgba(16, 185, 129, 0.4);
            --background-color-primary: #064e3b;
            --background-color-secondary: #065f46;
            --header-background-color: rgba(6, 78, 59, 0.9);
            --footer-background-color: rgba(6, 78, 59, 0.9);
            --content-background-color: rgba(6, 78, 59, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.1);
            --text-color-primary: #ffffff;
            --text-color-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #10b981;
            --accent-color-dark: #059669;
            --border-color: rgba(255, 255, 255, 0.2);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #059669, #10b981);
            --button-hover-background: #047857;
            --active-item-background: rgba(16, 185, 129, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
        }

        /* Cosmic Theme - Premium Nebula with Stellar Animation */
        body.theme-cosmic-mode {
            background: linear-gradient(135deg, #1e1b4b, #312e81, #4338ca, #6366f1) !important;
            background-color: transparent !important;
            background-image: linear-gradient(135deg, #1e1b4b, #312e81, #4338ca, #6366f1) !important;
            --background-main: linear-gradient(135deg, #1e1b4b, #312e81, #4338ca, #6366f1);
            --card-background: rgba(255, 255, 255, 0.1);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.9);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.2);
            --button-background: linear-gradient(90deg, #6366f1, #8b5cf6);
            --button-shadow: 0 4px 15px rgba(99, 102, 241, 0.4), 0 4px 15px rgba(139, 92, 246, 0.4);
            --background-color-primary: #1e1b4b;
            --background-color-secondary: #312e81;
            --header-background-color: rgba(30, 27, 75, 0.9);
            --footer-background-color: rgba(30, 27, 75, 0.9);
            --content-background-color: rgba(30, 27, 75, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.1);
            --text-color-primary: #ffffff;
            --text-color-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #8b5cf6;
            --accent-color-dark: #7c3aed;
            --border-color: rgba(255, 255, 255, 0.2);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #6366f1, #8b5cf6);
            --button-hover-background: #7c3aed;
            --active-item-background: rgba(139, 92, 246, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
        }
        /* Retro Theme - Premium 80s Synthwave with Grid Animation */
        body.theme-retro-mode {
            background: linear-gradient(135deg, #581c87, #7c3aed, #a855f7, #c084fc) !important;
            background-color: transparent !important;
            background-image: linear-gradient(135deg, #581c87, #7c3aed, #a855f7, #c084fc) !important;
            --background-main: linear-gradient(135deg, #581c87, #7c3aed, #a855f7, #c084fc);
            --card-background: rgba(255, 255, 255, 0.1);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.9);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.2);
            --button-background: linear-gradient(90deg, #a855f7, #c084fc);
            --button-shadow: 0 4px 15px rgba(168, 85, 247, 0.4), 0 4px 15px rgba(192, 132, 252, 0.4);
            --background-color-primary: #581c87;
            --background-color-secondary: #7c3aed;
            --header-background-color: rgba(88, 28, 135, 0.9);
            --footer-background-color: rgba(88, 28, 135, 0.9);
            --content-background-color: rgba(88, 28, 135, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.1);
            --text-color-primary: #ffffff;
            --text-color-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #c084fc;
            --accent-color-dark: #a855f7;
            --border-color: rgba(255, 255, 255, 0.2);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #a855f7, #c084fc);
            --button-hover-background: #9333ea;
            --active-item-background: rgba(192, 132, 252, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
        }

        /* Neon Theme - Premium Digital Matrix with Code Rain */
        body.theme-neon-mode {
            background: linear-gradient(135deg, #0f172a, #1e293b, #334155, #475569) !important;
            background-color: transparent !important;
            background-image: linear-gradient(135deg, #0f172a, #1e293b, #334155, #475569) !important;
            --background-main: linear-gradient(135deg, #0f172a, #1e293b, #334155, #475569);
            --card-background: rgba(255, 255, 255, 0.1);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.9);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.2);
            --button-background: linear-gradient(90deg, #06b6d4, #0ea5e9);
            --button-shadow: 0 4px 15px rgba(6, 182, 212, 0.4), 0 4px 15px rgba(14, 165, 233, 0.4);
            --background-color-primary: #0f172a;
            --background-color-secondary: #1e293b;
            --header-background-color: rgba(15, 23, 42, 0.9);
            --footer-background-color: rgba(15, 23, 42, 0.9);
            --content-background-color: rgba(15, 23, 42, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.1);
            --text-color-primary: #ffffff;
            --text-color-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #06b6d4;
            --accent-color-dark: #0891b2;
            --border-color: rgba(255, 255, 255, 0.2);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #06b6d4, #0ea5e9);
            --button-hover-background: #0891b2;
            --active-item-background: rgba(6, 182, 212, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
        }
        /* Elegant Theme - Premium Luxury with Golden Shimmer */
        body.theme-elegant-mode {
            background: linear-gradient(135deg, #92400e, #b45309, #d97706, #f59e0b) !important;
            background-color: transparent !important;
            background-image: linear-gradient(135deg, #92400e, #b45309, #d97706, #f59e0b) !important;
            --background-main: linear-gradient(135deg, #92400e, #b45309, #d97706, #f59e0b);
            --card-background: rgba(255, 255, 255, 0.1);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.9);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.2);
            --button-background: linear-gradient(90deg, #f59e0b, #fbbf24);
            --button-shadow: 0 4px 15px rgba(245, 158, 11, 0.4), 0 4px 15px rgba(251, 191, 36, 0.4);
            --background-color-primary: #92400e;
            --background-color-secondary: #b45309;
            --header-background-color: rgba(146, 64, 14, 0.9);
            --footer-background-color: rgba(146, 64, 14, 0.9);
            --content-background-color: rgba(146, 64, 14, 0.85);
            --card-background-color: rgba(255, 255, 255, 0.1);
            --text-color-primary: #ffffff;
            --text-color-secondary: rgba(255, 255, 255, 0.9);
            --accent-color: #fbbf24;
            --accent-color-dark: #f59e0b;
            --border-color: rgba(255, 255, 255, 0.2);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-background: linear-gradient(90deg, #f59e0b, #fbbf24);
            --button-hover-background: #d97706;
            --active-item-background: rgba(251, 191, 36, 0.2);
            /* --notification-badge-color: Hardcoded for visibility */
            --delete-button-color: #ef4444;
            --warning-color: #f59e0b;
        }

        /* ===== PREMIUM THEMES WORTH $4 EACH ===== */

        /* 1. 🌌 Quantum Nexus - Premium Particle Physics Simulation */
        body.theme-quantum-nexus {
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 255, 0, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #000428 0%, #004e92 25%, #2c3e50 50%, #3498db 75%, #00d4ff 100%) !important;
            background-size: 200% 200%, 300% 300%, 150% 150%, 100% 100% !important;
            animation: quantumFlux 20s ease-in-out infinite, particleCollision 15s linear infinite !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #000428 0%, #00d4ff 100%);
            --card-background: rgba(0, 212, 255, 0.15);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.95);
            --input-background: rgba(0, 212, 255, 0.1);
            --border-light: rgba(0, 212, 255, 0.4);
            --button-background: linear-gradient(45deg, #00d4ff, #3498db, #2c3e50);
            --button-shadow: 0 8px 25px rgba(0, 212, 255, 0.5), 0 0 40px rgba(52, 152, 219, 0.4);
            --background-color-primary: rgba(0, 4, 40, 0.95);
            --background-color-secondary: rgba(0, 78, 146, 0.9);
            --header-background-color: rgba(0, 4, 40, 0.95);
            --footer-background-color: rgba(0, 212, 255, 0.9);
            --content-background-color: rgba(44, 62, 80, 0.1);
            --card-background-color: rgba(0, 212, 255, 0.15);
            --text-color-primary: #ffffff;
            --text-color-secondary: #00d4ff;
            --accent-color: #00d4ff;
            --accent-color-dark: #3498db;
            --border-color: rgba(0, 212, 255, 0.6);
            --input-background-color: rgba(0, 212, 255, 0.1);
            --button-hover-background: #3498db;
            --active-item-background: rgba(0, 212, 255, 0.3);
            --delete-button-color: #ff6b6b;
            --warning-color: #ffd700;
            box-shadow: inset 0 0 100px rgba(0, 212, 255, 0.1) !important;
        }
        
        @keyframes quantumFlux {
            0%, 100% { background-position: 0% 0%, 0% 0%, 0% 0%, 0% 0%; }
            25% { background-position: 100% 100%, 25% 25%, 50% 50%, 0% 0%; }
            50% { background-position: 50% 50%, 75% 50%, 25% 25%, 0% 0%; }
            75% { background-position: 0% 100%, 100% 75%, 0% 50%, 0% 0%; }
        }
        
        @keyframes particleCollision {
            0% { filter: brightness(1) contrast(1) saturate(1); }
            50% { filter: brightness(1.2) contrast(1.1) saturate(1.3); }
            100% { filter: brightness(1) contrast(1) saturate(1); }
        }

        /* 2. 🎭 Holographic Matrix - Premium 3D Holographic Projection */
        body.theme-holographic-matrix {
            background: 
                linear-gradient(45deg, transparent 49%, rgba(0, 255, 255, 0.1) 50%, transparent 51%),
                linear-gradient(-45deg, transparent 49%, rgba(255, 0, 255, 0.1) 50%, transparent 51%),
                radial-gradient(circle at 50% 50%, rgba(0, 255, 255, 0.05) 0%, transparent 70%),
                linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%) !important;
            background-size: 60px 60px, 60px 60px, 100% 100%, 100% 100% !important;
            animation: holographicScan 25s linear infinite, matrixGlitch 8s ease-in-out infinite alternate !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #0a0a0a 0%, #533483 100%);
            --card-background: rgba(0, 255, 255, 0.1);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.95);
            --input-background: rgba(0, 255, 255, 0.08);
            --border-light: rgba(0, 255, 255, 0.5);
            --button-background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff00);
            --button-shadow: 0 8px 25px rgba(0, 255, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.4);
            --background-color-primary: rgba(10, 10, 10, 0.95);
            --background-color-secondary: rgba(26, 26, 46, 0.9);
            --header-background-color: rgba(10, 10, 10, 0.95);
            --footer-background-color: rgba(0, 255, 255, 0.9);
            --content-background-color: rgba(22, 33, 62, 0.1);
            --card-background-color: rgba(0, 255, 255, 0.1);
            --text-color-primary: #ffffff;
            --text-color-secondary: #00ffff;
            --accent-color: #00ffff;
            --accent-color-dark: #ff00ff;
            --border-color: rgba(0, 255, 255, 0.7);
            --input-background-color: rgba(0, 255, 255, 0.08);
            --button-hover-background: #ff00ff;
            --active-item-background: rgba(0, 255, 255, 0.25);
            --delete-button-color: #ff6b6b;
            --warning-color: #ffff00;
            box-shadow: inset 0 0 100px rgba(0, 255, 255, 0.05) !important;
            transform-style: preserve-3d !important;
            perspective: 1000px !important;
        }
        
        @keyframes holographicScan {
            0% { background-position: 0px 0px, 0px 0px, 0% 0%, 0% 0%; }
            100% { background-position: 60px 60px, 60px 60px, 100% 100%, 100% 100%; }
        }
        
        @keyframes matrixGlitch {
            0% { filter: brightness(1) contrast(1) saturate(1); transform: skewX(0deg); }
            25% { filter: brightness(1.1) contrast(1.05) saturate(1.1); transform: skewX(0.5deg); }
            50% { filter: brightness(1.2) contrast(1.1) saturate(1.2); transform: skewX(-0.5deg); }
            75% { filter: brightness(1.1) contrast(1.05) saturate(1.1); transform: skewX(0.5deg); }
            100% { filter: brightness(1) contrast(1) saturate(1); transform: skewX(0deg); }
        }

        /* 3. 🌟 Stellar Genesis - Premium Cosmic Birth Simulation */
        body.theme-stellar-genesis {
            background: 
                radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(255, 215, 0, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(138, 43, 226, 0.1) 0%, transparent 60%),
                linear-gradient(135deg, #000000 0%, #1a0033 20%, #4b0082 40%, #8a2be2 60%, #da70d6 80%, #ffd700 100%) !important;
            background-size: 150% 150%, 200% 200%, 100% 100%, 100% 100% !important;
            animation: stellarBirth 30s ease-in-out infinite, cosmicEvolution 20s linear infinite !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #000000 0%, #ffd700 100%);
            --card-background: rgba(255, 215, 0, 0.12);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.95);
            --input-background: rgba(255, 215, 0, 0.08);
            --border-light: rgba(255, 215, 0, 0.5);
            --button-background: linear-gradient(45deg, #ffd700, #da70d6, #8a2be2);
            --button-shadow: 0 8px 25px rgba(255, 215, 0, 0.6), 0 0 40px rgba(218, 112, 214, 0.4);
            --background-color-primary: rgba(0, 0, 0, 0.95);
            --background-color-secondary: rgba(26, 0, 51, 0.9);
            --header-background-color: rgba(0, 0, 0, 0.95);
            --footer-background-color: rgba(255, 215, 0, 0.9);
            --content-background-color: rgba(75, 0, 130, 0.1);
            --card-background-color: rgba(255, 215, 0, 0.12);
            --text-color-primary: #ffffff;
            --text-color-secondary: #ffd700;
            --accent-color: #ffd700;
            --accent-color-dark: #da70d6;
            --border-color: rgba(255, 215, 0, 0.7);
            --input-background-color: rgba(255, 215, 0, 0.08);
            --button-hover-background: #da70d6;
            --active-item-background: rgba(255, 215, 0, 0.25);
            --delete-button-color: #ff6b6b;
            --warning-color: #ffd700;
            box-shadow: inset 0 0 100px rgba(255, 215, 0, 0.08) !important;
        }
        
        @keyframes stellarBirth {
            0%, 100% { background-position: 0% 0%, 0% 0%, 0% 0%, 0% 0%; }
            25% { background-position: 100% 100%, 25% 25%, 50% 50%, 0% 0%; }
            50% { background-position: 50% 50%, 75% 50%, 25% 25%, 0% 0%; }
            75% { background-position: 0% 100%, 100% 75%, 0% 50%, 0% 0%; }
        }
        
        @keyframes cosmicEvolution {
            0% { filter: brightness(1) contrast(1) saturate(1); }
            50% { filter: brightness(1.15) contrast(1.1) saturate(1.2); }
            100% { filter: brightness(1) contrast(1) saturate(1); }
        }

        /* 4. ��� Circus Maximus - Premium Interactive Performance Theater */
        body.theme-circus-maximus {
            background: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255, 0, 0, 0.03) 10px, rgba(255, 0, 0, 0.03) 20px),
                repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(0, 255, 0, 0.03) 10px, rgba(0, 255, 0, 0.03) 20px),
                radial-gradient(circle at 25% 25%, rgba(255, 165, 0, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(255, 20, 147, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #ff0080 0%, #ff6b35 20%, #f7931e 40%, #ffd700 60%, #00ffff 80%, #1e90ff 100%) !important;
            background-size: 20px 20px, 20px 20px, 200% 200%, 150% 150%, 100% 100% !important;
            animation: circusPerformance 18s ease-in-out infinite, tentPhysics 12s linear infinite !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #ff0080 0%, #1e90ff 100%);
            --card-background: rgba(255, 255, 255, 0.15);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.95);
            --input-background: rgba(255, 255, 255, 0.1);
            --border-light: rgba(255, 255, 255, 0.4);
            --button-background: linear-gradient(45deg, #ff0080, #00ffff, #ffd700, #1e90ff);
            --button-shadow: 0 8px 25px rgba(255, 0, 128, 0.6), 0 0 40px rgba(0, 255, 255, 0.4);
            --background-color-primary: rgba(255, 0, 128, 0.95);
            --background-color-secondary: rgba(30, 144, 255, 0.9);
            --header-background-color: rgba(255, 0, 128, 0.95);
            --footer-background-color: rgba(30, 144, 255, 0.9);
            --content-background-color: rgba(255, 255, 255, 0.1);
            --card-background-color: rgba(255, 255, 255, 0.15);
            --text-color-primary: #ffffff;
            --text-color-secondary: #ffd700;
            --accent-color: #00ffff;
            --accent-color-dark: #ff0080;
            --border-color: rgba(255, 255, 255, 0.5);
            --input-background-color: rgba(255, 255, 255, 0.1);
            --button-hover-background: #ffd700;
            --active-item-background: rgba(0, 255, 255, 0.25);
            --delete-button-color: #ff6b6b;
            --warning-color: #ffd700;
            box-shadow: inset 0 0 100px rgba(255, 0, 128, 0.1) !important;
        }
        
        @keyframes circusPerformance {
            0%, 100% { background-position: 0px 0px, 0px 0px, 0% 0%, 0% 0%, 0% 0%; }
            25% { background-position: 20px 20px, 20px 20px, 100% 100%, 50% 50%, 0% 0%; }
            50% { background-position: 10px 10px, 10px 10px, 50% 50%, 100% 100%, 0% 0%; }
            75% { background-position: 0px 0px, 0px 0px, 0% 100%, 50% 0%, 0% 0%; }
        }
        
        @keyframes tentPhysics {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.02) rotate(0.5deg); }
            50% { transform: scale(1.01) rotate(-0.5deg); }
            75% { transform: scale(1.02) rotate(0.5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* 5. 🔮 Temporal Paradox - Premium Time Manipulation Interface */
        body.theme-temporal-paradox {
            background: 
                conic-gradient(from 0deg at 50% 50%, 
                    rgba(255, 0, 0, 0.1) 0deg, 
                    rgba(0, 255, 0, 0.1) 72deg, 
                    rgba(0, 0, 255, 0.1) 144deg, 
                    rgba(255, 0, 255, 0.1) 216deg, 
                    rgba(255, 255, 0, 0.1) 288deg, 
                    rgba(0, 255, 255, 0.1) 360deg),
                radial-gradient(circle at 20% 80%, rgba(128, 0, 128, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #000000 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%) !important;
            background-size: 100% 100%, 200% 200%, 100% 100% !important;
            animation: temporalShift 35s ease-in-out infinite, timeDilation 10s ease-in-out infinite alternate !important;
            background-attachment: fixed !important;
            --background-main: linear-gradient(135deg, #000000 0%, #533483 100%);
            --card-background: rgba(128, 0, 128, 0.15);
            --white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.95);
            --input-background: rgba(128, 0, 128, 0.1);
            --border-light: rgba(128, 0, 128, 0.5);
            --button-background: linear-gradient(45deg, #800080, #4b0082, #8a2be2, #da70d6);
            --button-shadow: 0 8px 25px rgba(128, 0, 128, 0.6), 0 0 40px rgba(138, 43, 226, 0.4);
            --background-color-primary: rgba(0, 0, 0, 0.95);
            --background-color-secondary: rgba(26, 26, 46, 0.9);
            --header-background-color: rgba(0, 0, 0, 0.95);
            --footer-background-color: rgba(128, 0, 128, 0.9);
            --content-background-color: rgba(22, 33, 62, 0.1);
            --card-background-color: rgba(128, 0, 128, 0.15);
            --text-color-primary: #ffffff;
            --text-color-secondary: #da70d6;
            --accent-color: #800080;
            --accent-color-dark: #4b0082;
            --border-color: rgba(128, 0, 128, 0.7);
            --input-background-color: rgba(128, 0, 128, 0.1);
            --button-hover-background: #8a2be2;
            --active-item-background: rgba(128, 0, 128, 0.25);
            --delete-button-color: #ff6b6b;
            --warning-color: #ffd700;
            box-shadow: inset 0 0 100px rgba(128, 0, 128, 0.1) !important;
        }
        
        @keyframes temporalShift {
            0%, 100% { background-position: 0% 0%, 0% 0%, 0% 0%; }
            25% { background-position: 100% 100%, 50% 50%, 0% 0%; }
            50% { background-position: 50% 50%, 100% 100%, 0% 0%; }
            75% { background-position: 0% 100%, 50% 0%, 0% 0%; }
        }
        
        @keyframes timeDilation {
            0% { filter: brightness(1) contrast(1) saturate(1); animation-duration: 1s; }
            100% { filter: brightness(1.1) contrast(1.05) saturate(1.1); animation-duration: 0.5s; }
        }

        /* Allow vertical scrolling but prevent horizontal scroll */
        html {
            overflow-y: auto;
            overflow-x: hidden;
            height: 100%;
            /* Prevent horizontal swipe gestures */
            touch-action: pan-y pinch-zoom;
        }

        /* Theme picker animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Theme picker styling */
        .theme-picker {
            position: fixed;
            z-index: 10000;
            width: 300px;
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            animation: fadeIn 0.3s ease;
            overflow: hidden;
        }

        .theme-picker-btn {
            transition: all 0.2s ease;
            border: none;
            background: transparent;
            color: var(--white);
            cursor: pointer;
            padding: 16px 20px;
            width: 100%;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            font-weight: 500;
            position: relative;
        }

        .theme-picker-btn:hover {
            background: rgba(255, 255, 255, 0.08) !important;
            transform: translateX(4px);
        }

        .theme-picker-btn[data-locked="true"] {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .theme-picker-btn[data-locked="true"]:hover {
            background: rgba(255, 0, 0, 0.1) !important;
        }

        /* Currency selector styling */
        .currency-selector {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin: 10px;
        }

        .currency-selector select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            padding: 8px;
            width: 100%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .currency-selector select:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .currency-selector select:focus {
            outline: none;
            border-color: var(--blue);
            box-shadow: 0 0 0 2px rgba(0, 213, 255, 0.2);
        }

        .currency-selector label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-bottom: 5px;
            display: block;
            font-weight: 500;
        }

        /* Theme picker title styling */
        .theme-picker-title {
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .theme-picker-title h3 {
            background: linear-gradient(135deg, var(--blue), var(--pink));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Stop theme animations (disable moving effects) */
        body[class*="theme-"] *,
        body[class*="theme-"]::before,
        body[class*="theme-"]::after {
            animation: none !important;
            animation-play-state: paused !important;
        }

        body {
            min-height: 100vh;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto; /* Allow vertical scrolling */
            overflow-x: hidden; /* Prevent horizontal scroll */
            /* 100% steel background - solid, non-transparent */
            background-color: #1a1a2e;
            background-image: none; /* Remove gradient for solid steel look */
            color: var(--white);
            transition: background-color 0.5s ease, color 0.5s ease; /* Smooth theme transition */
            /* Prevent horizontal swipe gestures on main content */
            touch-action: pan-y pinch-zoom;
            /* Prevent elastic scrolling bounce */
            overscroll-behavior-x: none;
        }

        /* Header Styling */
        header {
            background: var(--header-background);
            border-bottom: 1px solid var(--border-light);
            padding: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 55px;
            z-index: 10;
            display: flex;
            justify-content: center;
        }

        header .header-content-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1200px;
            padding: 0 30px;
        }

        .logo {
            font-family: 'Poppins', sans-serif;
            font-size: 1.8rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
            text-decoration: none;
        }

        /* Removed Header Navigation (Home, Profile) */
        header nav {
            display: none; /* Hide the nav element entirely */
        }



        /* User Profile Header Styling */
        .user-profile-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Cool Notification Icon Styling */
        .notification-icon-wrapper {
            position: relative;
            margin-right: 15px;
        }
        .notification-icon-wrapper a {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.06));
            border: 2px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            /* Enhanced visibility with subtle glow */
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15), 0 0 20px rgba(255, 255, 255, 0.05);
        }

        .notification-icon-wrapper a::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .notification-icon-wrapper a:hover::before {
            left: 100%;
        }

        .notification-icon-wrapper a:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.3),
                0 0 30px rgba(255, 142, 83, 0.2),
                0 2px 12px rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 215, 0, 0.7);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.08));
        }

        .notification-icon-wrapper i {
            font-size: 1.2rem;
            /* Improved visibility with solid colors that work across all themes */
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 142, 83, 0.6);
            transition: all 0.3s ease;
            z-index: 1;
            position: relative;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .notification-icon-wrapper a:hover i {
            transform: rotate(10deg) scale(1.05);
            color: #ffdf00;
            text-shadow: 0 0 15px rgba(255, 223, 0, 0.9), 0 0 20px rgba(255, 142, 83, 0.8);
            filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.5));
        }

        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            /* High contrast background for excellent visibility */
            background: linear-gradient(135deg, #ff4757, #ff3742);
            color: #ffffff;
            border-radius: 50%;
            padding: 3px 7px;
            font-size: 0.75rem;
            font-weight: 900;
            min-width: 20px;
            height: 20px;
            text-align: center;
            /* Enhanced shadow for better definition */
            box-shadow: 
                0 2px 8px rgba(255, 71, 87, 0.6),
                0 0 0 2px #ffffff,
                0 0 0 3px rgba(255, 71, 87, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-notification 2s infinite;
            z-index: 2;
            /* Better text readability */
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            line-height: 1;
        }

        @keyframes pulse-notification {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .notification-badge:empty {
            display: none;
        }
        /* Additional cool effects for notification icon */
        .notification-icon-wrapper a:active {
            transform: scale(0.98);
        }

        /* Glow effect when there are notifications */
        .notification-icon-wrapper.has-notifications a {
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
        }

        .notification-icon-wrapper.has-notifications a:hover {
            box-shadow: 
                0 6px 20px rgba(255, 215, 0, 0.4),
                0 0 35px rgba(255, 215, 0, 0.6),
                0 2px 12px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced shaking animation for notification bell - shakes every 3 seconds */
        .notification-icon-wrapper.has-notifications i {
            animation: bell-shake 3s ease-in-out infinite;
            transform-origin: top;
        }

        @keyframes bell-shake {
            0%, 90%, 100% { transform: rotate(0deg); }
            5%, 15%, 25%, 35% { transform: rotate(10deg); }
            10%, 20%, 30% { transform: rotate(-10deg); }
            40%, 50%, 60%, 70%, 80% { transform: rotate(0deg); }
        }

        /* Pause shaking on hover */
        .notification-icon-wrapper.has-notifications a:hover i {
            animation-play-state: paused;
        }
        /* --- Comprehensive Notification System CSS --- */
        
        /* Toast Notifications */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 350px;
            z-index: 10000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast-notification.show {
            transform: translateX(0);
        }

        .toast-notification.toast-success {
            border-left: 4px solid #4caf50;
        }

        .toast-notification.toast-error {
            border-left: 4px solid #f44336;
        }

        .toast-notification.toast-info {
            border-left: 4px solid #2196f3;
        }

        .toast-notification.toast-warning {
            border-left: 4px solid #ff9800;
        }

        .toast-notification.toast-friend_request {
            border-left: 4px solid #9c27b0;
        }

        .toast-notification.toast-message {
            border-left: 4px solid #00bcd4;
        }

        .toast-notification.toast-level_up {
            border-left: 4px solid #ffd700;
        }

        .toast-icon {
            font-size: 0.9rem;
            color: var(--white);
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--white);
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.3;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--white);
        }


        .no-notifications {
            text-align: center;
            padding: 60px 30px;
            color: var(--text-light);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.03) 0%, 
                rgba(255, 255, 255, 0.01) 100%);
            border-radius: 15px;
            margin: 20px;
        }

        .no-notifications i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.6;
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.7), rgba(255, 46, 146, 0.7));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .no-notifications p {
            font-size: 1rem;
            margin: 0;
            font-weight: 500;
        }

        /* Beautiful Notification Center Scrollbar */
        .notifications-list::-webkit-scrollbar {
            width: 8px;
        }

        .notifications-list::-webkit-scrollbar-track {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.05) 0%, 
                rgba(255, 255, 255, 0.02) 100%);
            border-radius: 4px;
            margin: 5px 0;
        }

        .notifications-list::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.3) 0%, 
                rgba(255, 255, 255, 0.1) 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .notifications-list::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.4) 0%, 
                rgba(255, 255, 255, 0.2) 100%);
            transform: scale(1.05);
        }

        /* Duplicate notification animation removed to prevent conflicts */

        /* Notification Dropdown Styles */
        .notification-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            width: 350px;
            max-height: 400px;
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            margin-top: 10px;
            backdrop-filter: blur(10px);
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-light);
        }

        .notification-header h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--white);
        }

        .view-all-link {
            color: var(--accent-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: opacity 0.3s ease;
        }

        .view-all-link:hover {
            opacity: 0.8;
        }

        .notification-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
        }

        .notification-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .notification-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--accent-color);
        }

        .notification-item.unread {
            background: rgba(0, 213, 255, 0.1);
            border-color: var(--accent-color);
        }

        .notification-item .notification-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1rem;
            flex-shrink: 0;
        }

        .notification-item .notification-content {
            flex: 1;
            min-width: 0;
        }

        .notification-item .notification-content h4 {
            margin: 0 0 4px 0;
            font-size: 0.9rem;
            color: var(--white);
            font-weight: 600;
        }

        .notification-item .notification-content p {
            margin: 0;
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.4;
        }

        .notification-item .notification-time {
            font-size: 0.7rem;
            color: var(--text-light);
            margin-top: 4px;
        }

        .notification-loading {
            text-align: center;
            padding: 20px;
            color: var(--text-light);
        }

        .notification-loading i {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: var(--accent-color);
        }

        .notification-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-light);
        }

        .notification-empty i {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--text-light);
        }

        /* Admin Icon Styling */
        #adminIconLink {
            display: none; /* Hidden by default */
            margin-right: 15px; /* Space it out from other icons */
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            font-size: 1.5rem;
            transition: transform 0.2s ease;
        }

        #adminIconLink:hover {
            transform: scale(1.05);
        }

        .user-profile-header #profileLink {
            display: flex;
            align-items: center;
            gap: 0;
            text-decoration: none;
            color: var(--white);
            transition: opacity 0.3s ease, background-color 0.3s ease;
            padding: 5px 10px;
            border-radius: var(--radius);
        }

        .user-profile-header #profileLink:hover {
            opacity: 0.8;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .user-profile-header img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color); /* Used accent-color for consistency */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .user-profile-header i {
            font-size: 30px;
            /* Apply gradient to icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        .user-profile-header span {
            font-weight: 600;
            font-size: 1rem;
            white-space: nowrap;
            overflow: visible;
            text-overflow: unset;
            max-width: none;
            /* Apply gradient to names */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }
        /* Main Content Area */
        main {
            flex-grow: 1;
            padding: 40px 0;
            padding-top: 55px; /* Back to original header spacing */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top */
            text-align: center;
            /* Prevent horizontal swipe gestures */
            touch-action: pan-y pinch-zoom;
            overscroll-behavior-x: none;
        }

        .content-wrapper {
            width: 100%;
            max-width: 1000px; /* Back to original max-width */
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            /* Prevent horizontal swipe gestures */
            touch-action: pan-y pinch-zoom;
            overscroll-behavior-x: none;
        }

        /* Daily Inspiration Section */
        .daily-inspiration-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 2rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            text-align: center;
        }

        .daily-inspiration-section h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 2rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            margin: 0;
        }
        .daily-inspiration-section .quote-text {
            font-size: 0.9rem;
            color: var(--white);
            line-height: 1.6;
            font-style: italic;
            margin: 0;
        }

        .daily-inspiration-section .quote-author {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-top: 0.5rem;
            font-weight: 600;
        }
        .daily-inspiration-section .inspiration-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        .inspiration-action-button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 0.8rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .inspiration-action-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--blue), 0 6px 20px var(--pink);
        }
        .inspiration-action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }
        .daily-inspiration-section .inspiration-action-button:disabled { background: linear-gradient(90deg, var(--pink), var(--blue)); color: var(--white); opacity: 0.7; }

        /* Global Announcements Section */
        .global-announcements-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 90%;
            max-width: 700px;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            animation: announcementSlideIn 0.5s ease-out;
        }

        .announcement-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .announcement-icon {
            font-size: 1.5rem;
            color: var(--blue);
            animation: announcementPulse 2s infinite;
        }

        .announcement-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--white);
            margin: 0;
            flex: 1;
        }

        .announcement-dismiss-btn {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .announcement-dismiss-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--white);
            transform: scale(1.1);
        }

        .announcement-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .announcement-type-badge,
        .announcement-priority-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 8px;
            margin-bottom: 8px;
            align-self: flex-start;
        }

        .announcement-type-badge {
            background: rgba(0, 213, 255, 0.2);
            color: var(--blue);
            border: 1px solid rgba(0, 213, 255, 0.3);
        }

        .announcement-priority-badge {
            background: rgba(255, 46, 146, 0.2);
            color: var(--pink);
            border: 1px solid rgba(255, 46, 146, 0.3);
        }

        .announcement-message {
            color: var(--white);
            font-size: 1rem;
            line-height: 1.6;
            margin: 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .announcement-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-light);
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .announcement-timestamp {
            font-style: italic;
        }

        .announcement-source {
            color: var(--blue);
            font-weight: 600;
        }

        /* Priority-specific colors */
        .announcement-priority-badge[data-priority="urgent"] {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            border-color: rgba(220, 53, 69, 0.3);
        }

        .announcement-priority-badge[data-priority="high"] {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border-color: rgba(255, 193, 7, 0.3);
        }

        .announcement-priority-badge[data-priority="medium"] {
            background: rgba(255, 46, 146, 0.2);
            color: var(--pink);
            border-color: rgba(255, 46, 146, 0.3);
        }

        .announcement-priority-badge[data-priority="low"] {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border-color: rgba(40, 167, 69, 0.3);
        }
        /* Announcement animations */
        @keyframes announcementSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @keyframes announcementPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        /* Post Creation Section */
        .post-creation-section {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 25px rgba(0, 0, 0, .3);
            padding: 1.5rem;
            width: 100%;
            max-width: 600px; /* Max width for post creation */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 20px; /* Space from inspiration section */
        }

        .post-creation-section h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            margin-bottom: 0.5rem;
        }

        .post-creation-section textarea {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 1rem;
            outline: none;
            transition: border-color var(--transition), box-shadow var(--transition);
            resize: vertical;
            min-height: 80px;
        }

        .post-creation-section textarea:focus {
            border-color: rgba(0, 213, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .post-creation-section .media-upload-area {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .post-creation-section .file-input-label {
            background: linear-gradient(90deg, var(--blue), var(--pink));
            color: var(--white);
            border: none; /* Changed from border to none */
            border-radius: 12px;
            padding: 8px 15px;
            cursor: pointer;
            font-weight: 700;
            transition: all var(--transition);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }

        .post-creation-section .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--blue), 0 44px 15px var(--pink);
        }

        .post-creation-section input[type="file"] {
            display: none;
        }

        .post-creation-section .media-preview {
            max-width: 100px;
            max-height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            display: none;
            margin-left: 10px;
        }

        .post-creation-section .post-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
        }

        .post-creation-section .post-button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 0.7rem 1.2rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .post-creation-section .post-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--blue), 0 6px 20px var(--pink);
        }
        .post-creation-section .post-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Posts Feed Section */
        .posts-feed-section {
            width: 100%;
            max-width: 600px; /* Max width for posts feed */
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px; /* Space from post creation section */
        }

        .post-card {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 4px 15px rgba(0, 0, 0, .2);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative; /* For dropdown menu positioning */
        }

        .post-header .author-pic-wrapper {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid var(--blue);
            flex-shrink: 0;
        }
        .post-header .author-pic {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .post-header .author-pic-placeholder {
            font-size: 40px;
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .post-header .author-info {
            flex-grow: 1;
        }

        .post-header .author-name {
            font-weight: 600;
            color: var(--white);
            font-size: 1rem;
            text-decoration: none; /* Make author name clickable */
        }

        .post-header .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .post-options-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 0.9rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .post-options-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .post-options-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .post-options-dropdown {
            position: absolute;
            top: 40px; /* Position below the button */
            right: 0;
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            min-width: 150px;
            z-index: 20;
            display: none;
            flex-direction: column;
            overflow: hidden; /* For rounded corners on children */
        }

        .post-options-dropdown.active {
            display: flex;
        }

        .post-options-dropdown button {
            background: none;
            border: none;
            color: var(--white);
            padding: 10px 15px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .post-options-dropdown button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .post-options-dropdown button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .post-options-dropdown button i {
            width: 20px; /* Align icons */
        }

        /* Themed buttons in dropdown */
        .post-options-dropdown .edit-post-button {
            background: linear-gradient(90deg, var(--blue), #00d5ff80); /* Blue gradient */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(0, 213, 255, 0.3);
            border-radius: 0; /* Override default button border-radius */
        }
        .post-options-dropdown .edit-post-button:hover {
            background: linear-gradient(90deg, #00b5e0, var(--blue));
            box-shadow: 0 4px 10px rgba(0, 213, 255, 0.5);
        }

        .post-options-dropdown .delete-post-button {
            background: linear-gradient(90deg, var(--pink), #ff2e9280); /* Pink gradient */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(255, 46, 146, 0.3);
            border-radius: 0;
        }
        .post-options-dropdown .delete-post-button:hover {
            background: linear-gradient(90deg, #e02a82, var(--pink));
            box-shadow: 0 4px 10px rgba(255, 46, 146, 0.5);
        }

        .post-options-dropdown .share-post-button {
            background: linear-gradient(90deg, var(--blue), var(--pink)); /* Mixed gradient for share */
            color: var(--white);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border-radius: 0;
        }
        .post-options-dropdown .share-post-button:hover {
            background: linear-gradient(90deg, var(--pink), var(--blue)); /* Reverse gradient on hover */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .post-content-text {
            font-size: 1rem;
            color: var(--white);
            line-height: 1.5;
            word-wrap: break-word;
        }

        .post-media {
            margin-top: 10px;
        }

        .post-media img, .post-media video {
            max-width: 100%;
            border-radius: 10px;
            display: block;
            height: auto;
        }

        .post-reactions-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-light);
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-light);
        }

        .post-reactions-summary span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .post-reactions-summary i {
            font-size: 1rem;
        }

        .post-actions-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding-top: 1rem;
        }

        .post-action-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: color 0.2s ease, transform 0.1s ease-out; /* Added transform for animation */
            padding: 8px 12px;
            border-radius: 10px;
        }

        .post-action-button:hover:not(:disabled) {
            color: var(--blue);
            background-color: rgba(0, 213, 255, 0.05);
            transform: translateY(-2px); /* Slight lift on hover */
        }
        .post-action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Reaction button animations */
        .post-action-button.reacted-like {
            color: var(--blue);
            background-color: rgba(0, 213, 255, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }
        .post-action-button.reacted-love {
            color: var(--pink);
            background-color: rgba(255, 46, 146, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }
        .post-action-button.reacted-haha {
            color: #ffd700; /* Gold */
            background-color: rgba(255, 215, 0, 0.1);
            animation: pop-reaction 0.3s ease-out;
        }

        @keyframes pop-reaction {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Comments Section */
        .comments-section {
            margin-top: 1rem;
            border-top: 1px solid var(--border-light);
            padding-top: 1rem;
        }
        .comments-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 1rem;
        }

        .comment-item {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            background-color: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            padding: 10px;
            position: relative;
        }
        .comment-item[data-reply="true"] { margin-left: 34px; border-left: 2px solid var(--border-light); }
        .comment-reactions-bar { display:inline-flex; gap:6px; margin-left:8px; }
        .comment-reaction-button { background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 12px; padding: 4px 8px; cursor: pointer; font-size: 0.8rem; }
        .comment-reaction-button.active { background: rgba(255,255,255,0.08); }
        .comment-reactions-summary { display:inline-flex; gap:8px; margin-left:10px; color: var(--text-light); font-size: 0.8rem; }

        .comment-item .comment-author-pic {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
            border: 1px solid var(--blue);
        }

        .comment-item .comment-author-pic-placeholder {
            font-size: 30px;
            color: var(--text-light);
            flex-shrink: 0;
        }

        .comment-item .comment-content-wrapper {
            flex-grow: 1;
            text-align: left;
        }

        .comment-item .comment-author-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--white);
            margin-right: 5px;
            text-decoration: none;
        }

        .comment-item .comment-text {
            font-size: 0.9rem;
            color: var(--text-light);
            word-wrap: break-word;
            display: inline; /* Keep on same line as author for short comments */
        }

        .comment-item .comment-timestamp {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            margin-left: 10px;
        }

        .comment-item .delete-comment-button {
            background: none;
            border: none;
            color: var(--pink);
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.9rem;
            padding: 0; /* Remove padding */
        }
        .comment-item .delete-comment-button:hover:not(:disabled) {
            opacity: 0.8;
        }
        .comment-item .delete-comment-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .comment-input-area {
            display: flex;
            gap: 10px;
            margin-top: 1rem;
            align-items: center;
        }

        .comment-input-area textarea {
            flex-grow: 1;
            padding: 8px 12px;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 0.9rem;
            outline: none;
            resize: vertical;
            min-height: 32px;
            max-height: 80px; /* Limit comment input height */
        }

        .comment-input-area textarea:focus {
            border-color: rgba(0, 213, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }

        .comment-input-area button {
            background: var(--button-background);
            color: var(--white);
            border: none;
            border-radius: 15px;
            padding: 8px 15px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            flex-shrink: 0;
        }

        .comment-input-area button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
        }
        .comment-input-area button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--text-light);
            box-shadow: none;
        }

        /* Customization/Edit Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-background);
            border: 1px solid var(--glass-blue);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: var(--radius);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 2rem;
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--white);
            margin-bottom: 0.5rem;
        }

        .modal-content .radio-group,
        .modal-content .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            text-align: left;
        }

        .modal-content label {
            color: var(--text-light);
            font-size: 0.95rem;
            font-weight: 600;
        }

        .modal-content input[type="radio"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--blue);
            border-radius: 50%;
            background-color: var(--input-background);
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .modal-content input[type="radio"]:checked {
            background-color: var(--blue);
            border-color: rgba(0, 213, 255, 0.6);
        }

        .modal-content input[type="radio"]:checked::after {
            content: '';
            width: 8px;
            height: 8px;
            background-color: var(--white);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .modal-content textarea {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 15px;
            background: var(--input-background);
            border: 1px solid var(--border-light);
            color: var(--white);
            font-size: 1rem;
            outline: none;
            transition: border-color var(--transition), box-shadow var(--transition);
            resize: vertical;
            min-height: 80px;
        }
        .modal-content textarea:focus {
            border-color: rgba(0, 213, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(0, 213, 255, 0.2);
        }
        .modal-content .button-group {
            display: flex;
            justify-content: flex-end;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        .modal-content .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .modal-content .cancel-button {
            background: rgba(255, 255, 255, 0.1);
            color: var(--white);
            border: 1px solid var(--border-light);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        .modal-content .cancel-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .modal-content .save-button {
            background: var(--button-background);
            color: var(--white);
            box-shadow: var(--button-shadow);
        }

        .modal-content .save-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px var(--blue), 0 4px 15px var(--pink);
        }

        .button-text {
            display: block;
        }

        .loading .button-text {
            display: none;
        }

        /* Premium Request Button */
        .premium-request-btn {
            background: linear-gradient(90deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
        }

        .premium-request-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .premium-request-btn i {
            font-size: 1rem;
        }

        /* Premium Request Modal Styles */
        .premium-tiers {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .premium-tier-option {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--border-light);
            border-radius: 12px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .premium-tier-option:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .premium-tier-option.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .tier-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tier-badge {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .tier-price {
            color: var(--accent-color);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .tier-features {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }

        .tier-features li {
            padding: 0.25rem 0;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .tier-features li:before {
            content: "✓";
            color: var(--accent-color);
            font-weight: bold;
            margin-right: 0.5rem;
        }

        /* Premium Badge Styles */
        .premium-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 2px solid #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            animation: premium-glow 2s ease-in-out infinite;
            margin-left: 5px;
            font-size: 10px;
            color: #000;
        }

        .vip-badge {
            background: linear-gradient(135deg, #C0C0C0, #E5E4E2);
            border: 2px solid #C0C0C0;
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.6);
        }

        .elite-badge {
            background: linear-gradient(135deg, #FFD700, #FF6B35);
            border: 3px solid #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            animation: elite-pulse 1.5s ease-in-out infinite;
        }

        @keyframes premium-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        @keyframes elite-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Premium Theme Styles */
        .premium-theme-dark {
            --background-main: #1a1a1a !important;
            --card-background: #2d2d2d !important;
            --white: #ffffff !important;
            --text-light: #cccccc !important;
            --border-light: rgba(255, 255, 255, 0.1) !important;
        }

        .premium-theme-neon {
            --background-main: #000000 !important;
            --card-background: #00ff00 !important;
            --white: #ffffff !important;
            --text-light: #00ff00 !important;
            --border-light: rgba(0, 255, 0, 0.3) !important;
        }

        .premium-theme-glass {
            --background-main: rgba(255, 255, 255, 0.1) !important;
            --card-background: rgba(255, 255, 255, 0.05) !important;
            --white: #ffffff !important;
            --text-light: rgba(255, 255, 255, 0.7) !important;
            --border-light: rgba(255, 255, 255, 0.2) !important;
        }

        /* Premium Features Section */
        .premium-features-section {
            background: var(--card-background);
            border: 1px solid var(--border-light);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .premium-features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .premium-feature-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-light);
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .premium-feature-card:hover {
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .premium-feature-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: var(--accent-color);
        }

        .premium-feature-title {
            font-weight: 600;
            color: var(--white);
            margin-bottom: 5px;
        }

        .premium-feature-desc {
            color: var(--text-light);
            font-size: 0.9rem;
        }
        /* Ad-free Experience */
        .ad-free {
            display: none !important;
        }

        /* Premium Post Features */
        .premium-post-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .premium-post-option {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 5px 12px;
            font-size: 0.8rem;
            color: #FFD700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .premium-post-option:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        .premium-post-option.active {
            background: rgba(255, 215, 0, 0.3);
            color: #000;
        }

        /* Custom Message Box Styles */
        #messageBox {
            position: fixed;
            top: 50%; /* Centered vertically */
            left: 50%;
            transform: translate(-50%, -50%); /* Centered horizontally and vertically */
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px; /* Increased padding for a 'squarer' feel */
            border-radius: 15px; /* Slightly less rounded */
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5); /* More pronounced shadow */
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; /* Add transform transition */
            min-width: 280px; /* Slightly wider */
            max-width: 90%; /* Responsive max-width */
            text-align: center;
            font-size: 1.1rem; /* Slightly larger font */
            font-weight: 600;
            backdrop-filter: blur(5px); /* Subtle blur for glass effect */
        }
        /* Specific styling for success messages */
        #messageBox.success {
            background: linear-gradient(135deg, var(--blue), var(--pink)); /* Pink and blue gradient */
            border: 2px solid rgba(255, 255, 255, 0.3); /* White border for definition */
            color: var(--white); /* Ensure text is white */
            box-shadow: 0 5px 25px rgba(0, 213, 255, 0.5), 0 5px 25px rgba(255, 46, 146, 0.5); /* Dual color shadow */
        }
        #messageBox.error { border-left: 5px solid var(--delete-button-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Corrected from original */
        #messageBox.info { border-left: 5px solid var(--accent-color); background-color: var(--card-background-color); color: var(--text-color-primary); } /* Corrected from original */
        #messageBox.warning i { color: var(--warning-color); }

        @keyframes pulse-bg {
            0% { background-color: rgba(52, 152, 219, 0.9); }
            50% { background-color: rgba(52, 152, 219, 0.7); }
            100% { background-color: rgba(52, 152, 219, 0.9); }
        }
        #messageBox.loading-pulse { animation: pulse-bg 1.5s infinite ease-in-out; }

        /* Confirmation Modal Specific Styles */
        #confirmationModal .modal-content {
            max-width: 400px;
            text-align: center;
            padding: 1.8rem;
        }
        #confirmationModal .modal-content h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.6rem;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--pink), var(--blue));
            margin-bottom: 1rem;
        }
        #confirmationModal .modal-content p {
            font-size: 1rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }
        #confirmationModal .modal-content .button-group {
            justify-content: center;
            gap: 1rem;
        }
        #confirmationModal .confirm-button {
            background: var(--pink); /* Use pink for destructive action */
            color: var(--white);
            box-shadow: 0 4px 15px var(--pink);
        }
        #confirmationModal .confirm-button:hover {
            background: #e02a82; /* Darker pink on hover */
            box-shadow: 0 6px 20px var(--pink);
        }
        #confirmationModal .cancel-button {
            background: var(--blue); /* Use blue for cancel/safe action */
            color: var(--white);
            box-shadow: 0 4px 15px var(--blue);
        }
        #confirmationModal .cancel-button:hover {
            background: #00b5e0; /* Darker blue on hover */
            box-shadow: 0 6px 20px var(--blue);
        }

        /* --- Sidebar Navigation --- */
        #sidebarNav {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 250px; /* Default sidebar width */
            background: var(--header-background); /* Use header background for consistency */
            border-right: 1px solid var(--border-light);
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
            z-index: 90; /* Higher than main content, lower than modals */
            display: flex;
            flex-direction: column;
            padding: 20px;
            transform: translateX(-100%); /* Hidden by default */
            transition: transform .38s cubic-bezier(.22,.61,.36,1), box-shadow .2s ease;
            will-change: transform;
            overscroll-behavior: contain;
            touch-action: pan-y;
        }

        #sidebarNav.sidebar-visible {
            transform: translateX(0); /* Show sidebar */
            box-shadow: 8px 0 30px rgba(0,0,0,0.35);
        }

        #sidebarNav.sidebar-hidden { transform: translateX(-100%); }

        /* Smart scrollable sidebar enhancements */
        #sidebarNav {
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-gutter: stable both-edges;
        }
        #sidebarNav .sidebar-header {
            position: sticky;
            top: 0;
            background: var(--header-background);
            backdrop-filter: blur(6px) saturate(140%);
            z-index: 2;
        }
        #sidebarNav::after {
            content: "";
            position: absolute;
            top: 0;
            right: -1px;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, var(--blue), var(--pink));
            opacity: 0.9;
            pointer-events: none;
        }
        /* Scrollbar styling */
        #sidebarNav::-webkit-scrollbar { width: 8px; }
        #sidebarNav::-webkit-scrollbar-thumb { background: linear-gradient(180deg, var(--blue), var(--pink)); border-radius: 6px; }
        #sidebarNav::-webkit-scrollbar-track { background: transparent; }
        @supports (scrollbar-color: red blue) {
            #sidebarNav { scrollbar-color: var(--blue) transparent; scrollbar-width: thin; }
        }

        /* Backdrop behind sidebar */
        .sidebar-backdrop{
            position:fixed;inset:0;background:rgba(0,0,0,0.35);backdrop-filter:blur(4px);opacity:0;visibility:hidden;transition:opacity .25s ease;z-index:85;
        }
        .sidebar-backdrop.show{opacity:1;visibility:visible}

        /* Staggered link entrance */
        .sidebar-links .sidebar-nav-item{opacity:0;transform:translateX(-8px)}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item{opacity:1;transform:translateX(0);transition:transform .32s ease,opacity .28s ease}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(1){transition-delay:40ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(2){transition-delay:70ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(3){transition-delay:100ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(4){transition-delay:130ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(5){transition-delay:160ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(6){transition-delay:190ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(7){transition-delay:220ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(8){transition-delay:250ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(9){transition-delay:280ms}
        #sidebarNav.sidebar-visible .sidebar-links .sidebar-nav-item:nth-child(10){transition-delay:310ms}

        /* Reduce motion accessibility */
        @media (prefers-reduced-motion: reduce){
            #sidebarNav{transition:none}
            .sidebar-backdrop{transition:none}
            .sidebar-links .sidebar-nav-item{opacity:1;transform:none;transition:none}
        }

        /* Shift content slightly when sidebar open */
        body.sidebar-open header, body.sidebar-open #main-content{transform:translateX(8px);transition:transform .38s cubic-bezier(.22,.61,.36,1)}

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-light);
        }

        .sidebar-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.5rem;
            font-weight: 800;
            background-clip: text;
            color: transparent;
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            letter-spacing: -0.03em;
        }

        #sidebarCloseBtn {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        #sidebarCloseBtn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--white);
        }

        .sidebar-links {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar-nav-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 15px;
            border-radius: 10px;
            text-decoration: none;
            color: var(--text-light);
            font-size: 1.1rem;
            font-weight: 600;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .sidebar-nav-item:hover {
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--white);
            transform: translateX(5px);
        }

        .sidebar-nav-item.active {
            background-color: rgba(0, 213, 255, 0.15); /* Light blue tint for active */
            color: var(--white);
            border-left: 4px solid var(--blue); /* Highlight active link */
            padding-left: 11px; /* Adjust padding due to border */
        }

        .sidebar-nav-item i {
            font-size: 1.4rem;
            /* Apply gradient to sidebar icons */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
            width: 30px; /* Fixed width for icon alignment */
            text-align: center;
        }

        .sidebar-nav-item span {
            /* Apply gradient to sidebar text labels */
            background-image: linear-gradient(90deg, var(--blue), var(--pink));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback */
        }

        /* Sidebar Toggle Button in Header - Enhanced to prevent auto-switching */
        #sidebarToggleFab {
            position: static; /* No longer fixed, now part of header flow */
            width: 32px; /* Consistent with theme switcher */
            height: 32px; /* Consistent with theme switcher */
            border-radius: 50%;
            background: linear-gradient(45deg, rgba(0, 213, 255, 0.8), rgba(255, 46, 146, 0.8));
            color: var(--white);
            border: 2px solid transparent;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); /* Always visible shadow */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem; /* Consistent with theme switcher */
            cursor: pointer;
            z-index: 80;
            transition: all 0.3s ease;
            opacity: 1; /* Always visible to prevent confusion */
            margin-right: 15px; /* Space from logo */
            position: relative;
            overflow: hidden;
        }

        #sidebarToggleFab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, var(--accent-color), var(--pink));
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 50%;
        }

        #sidebarToggleFab:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 213, 255, 0.4), 0 4px 15px rgba(255, 46, 146, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
            background: linear-gradient(45deg, var(--pink), var(--blue)); /* Reverse gradient on hover */
        }

        #sidebarToggleFab:hover::before {
            opacity: 0.1;
        }

        #sidebarToggleFab:active {
            transform: scale(0.95);
        }

        /* Theme-specific sidebar toggle styling */
        body.theme-light-mode #sidebarToggleFab {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.2);
        }

        body.theme-light-mode #sidebarToggleFab:hover {
            background: linear-gradient(45deg, #8b5cf6, #3b82f6);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4), 0 4px 15px rgba(139, 92, 246, 0.4);
            border-color: rgba(59, 130, 246, 0.4);
        }

        body.theme-dark-mode #sidebarToggleFab {
            background: linear-gradient(45deg, #00d5ff, #ff2e92);
            box-shadow: 0 2px 8px rgba(0, 213, 255, 0.3), 0 2px 8px rgba(255, 46, 146, 0.3);
            border-color: rgba(0, 213, 255, 0.2);
        }

        body.theme-dark-mode #sidebarToggleFab:hover {
            background: linear-gradient(45deg, #ff2e92, #00d5ff);
            box-shadow: 0 4px 15px rgba(0, 213, 255, 0.4), 0 4px 15px rgba(255, 46, 146, 0.4);
            border-color: rgba(0, 213, 255, 0.4);
        }

        /* NEW: Maintenance Mode Overlay */
        #maintenanceOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Darker overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top of everything */
            color: var(--white);
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(8px); /* Subtle blur effect */
            transition: opacity 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        #maintenanceOverlay.active {
            opacity: 1;
            visibility: visible;
        }

        #maintenanceOverlay i {
            font-size: 5rem;
            color: var(--warning-color); /* Use warning color for icon */
            margin-bottom: 20px;
        }

        #maintenanceOverlay h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 3rem;
            font-weight: 800;
            color: var(--warning-color); /* Use warning color for heading */
            margin-bottom: 10px;
        }

        #maintenanceOverlay p {
            font-size: 0.9rem;
            line-height: 1.6;
            max-width: 600px;
            color: var(--text-light);
        }

        /* Call Overlay Styles (NEW) */
        #callOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: var(--white);
            font-family: 'Poppins', sans-serif;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }
        #callOverlay .call-status-icon {
            font-size: 5rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            /* Animation for calling/ringing state */
            animation: pulse-color 2s infinite alternate;
        }
        /* New animation for call icon when active */
        @keyframes pulse-color {
            0% { color: var(--accent-color); }
            100% { color: var(--pink); }
        }
        #callOverlay .call-status-text {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 10px;
        }
        #callOverlay .call-timer {
            font-size: 1.5rem;
            color: var(--text-light);
            margin-bottom: 30px;
        }
        #callOverlay .call-actions {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #callOverlay .call-actions button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--white);
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #callOverlay .call-actions button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        #callOverlay .call-actions button.accept-call-btn {
            background: #28a745;
        }
        #callOverlay .call-actions button.decline-call-btn,
        #callOverlay .call-actions button.end-call-btn {
            background: var(--delete-button-color);
        }
        #callOverlay .call-actions button.toggle-mute-btn {
            background: rgba(255, 255, 255, 0.2);
        }
        #callOverlay .call-actions button.toggle-mute-btn.active {
            background: #ccc; /* Grey when muted */
            color: #333;
        }
        #callOverlay .call-actions button.toggle-video-btn {
            background: rgba(255, 255, 255, 0.2);
        }
        #callOverlay .call-actions button.toggle-video-btn.active {
            background: #ccc; /* Grey when video off */
            color: #333;
        }

        /* Video elements within call overlay */
        #callOverlay .video-streams {
            position: relative;
            width: 90%;
            max-width: 800px;
            height: 50%;
            max-height: 450px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: #000;
            display: none; /* Hidden by default until stream is active */
        }
        #localVideo {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 120px;
            height: 90px;
            border-radius: 10px;
            object-fit: cover;
            border: 2px solid var(--accent-color);
            background-color: #333;
            z-index: 1;
            transform: scaleX(-1); /* Mirror local video */
            display: none; /* Hidden by default until stream is active */
        }
        #callOverlay.voice-call .video-streams {
            display: none; /* Hide video streams for voice calls */
        }
        /* Responsive Adjustments */
        @media (max-width: 600px) {
            header .header-content-wrapper {
                padding: 0 20px;
            }
            .logo {
                font-size: 1.6rem;
            }
            #sidebarToggleFab {
                width: 25px;
                height: 25px;
                font-size: 1rem;
                margin-right: 10px;
            }
            .notification-icon-wrapper a {
                width: 36px;
                height: 36px;
            }
            .notification-icon-wrapper i {
                font-size: 1.15rem;
            }
            .notification-badge {
                padding: 2px 5px;
                font-size: 0.65rem;
                min-width: 18px;
                height: 18px;
                top: -6px;
                right: -6px;
            }
            #adminIconLink {
                font-size: 1.1rem;
                margin-right: 10px;
            }
            .user-profile-header span {
                font-size: 0.9rem;
                max-width: 150px;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .daily-inspiration-section {
                padding: 1.5rem;
            }
            .daily-inspiration-section h2 {
                font-size: 1.8rem;
            }
            .daily-inspiration-section .quote-text {
                font-size: 1rem;
            }
            .daily-inspiration-section .quote-author {
                font-size: 0.8rem;
            }
            .inspiration-action-button {
                padding: 0.7rem 1.2rem;
                font-size: 0.8rem;
            }
            .post-creation-section {
                padding: 1rem;
            }
            .post-creation-section h3 {
                font-size: 1.1rem;
            }
            .post-creation-section textarea {
                padding: 0.7rem 0.9rem;
                font-size: 0.9rem;
            }
            .post-creation-section .post-button {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;
            }
            .post-card {
                padding: 1rem;
            }
            .post-header .author-pic-wrapper {
                width: 35px;
                height: 35px;
            }
            .post-header .author-pic-placeholder {
                font-size: 35px;
            }
            .post-header .author-name {
                font-size: 0.9rem;
            }
            .post-header .post-timestamp {
                font-size: 0.7rem;
            }
            .post-action-button {
                font-size: 0.8rem;
            }
            .post-action-button i {
                font-size: 1rem;
            }
            .comment-item .comment-author-pic {
                width: 25px;
                height: 25px;
            }
            .comment-item .comment-author-pic-placeholder {
                font-size: 25px;
            }
            .comment-item .comment-author-name, .comment-item .comment-text {
                font-size: 0.8rem;
            }
            .comment-item .comment-timestamp {
                font-size: 0.75rem;
            }
            .comment-input-area textarea {
                padding: 6px 10px;
                font-size: 0.85rem;
            }
            .comment-input-area button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .modal-content h3 {
                font-size: 1.1rem;
            }
            .modal-content .radio-option {
                font-size: 0.9rem;
            }
            .modal-content .modal-button {
                padding: 8px 15px;
                font-size: 0.8rem;
            }
            #confirmationModal .modal-content h3 {
                font-size: 1.4rem;
            }
            #confirmationModal .modal-content p {
                font-size: 0.9rem;
            }
            /* Sidebar on mobile: make it full width */
            #sidebarNav {
                width: 100%;
                padding: 20px 10px; /* Adjust padding */
            }

            /* Maintenance Overlay on Mobile */
            #maintenanceOverlay h2 {
                font-size: 2rem;
            }
            #maintenanceOverlay p {
                font-size: 1rem;
            }
            #maintenanceOverlay i {
                font-size: 4rem;
            }
            /* Call Overlay on Mobile */
            #callOverlay .call-status-icon {
                font-size: 4rem;
            }
            #callOverlay .call-status-text {
                font-size: 1.5rem;
            }
            #callOverlay .call-timer {
                font-size: 0.9rem;
            }
            #callOverlay .call-actions button {
                width: 50px;
                height: 50px;
                font-size: 1.8rem;
            }
            #localVideo {
                width: 90px;
                height: 70px;
                bottom: 10px;
                right: 10px;
            }
        }

        /* Posts Controls */
        .post-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-controls select,
        .post-controls input[type="text"],
        .post-controls input[type="date"] {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            background: var(--input-background);
            color: var(--white);
        }
        .post-control-button {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            background: var(--button-background);
            color: var(--white);
            cursor: pointer;
        }
        .post-control-button:hover { opacity: .95; }

        /* Stories Bar */
        .stories-bar { display:flex; gap:10px; padding:8px 0; overflow-x:auto; }
        .story-item { display:flex; flex-direction:column; align-items:center; gap:6px; }
        .story-avatar { width:56px; height:56px; border-radius:50%; border:2px solid var(--blue); background:#333; display:flex; align-items:center; justify-content:center; overflow:hidden; }
        .story-avatar img { width:100%; height:100%; object-fit:cover; }
        .add-story-button { background: var(--button-background); color: var(--white); border: none; padding: 6px 10px; border-radius: 8px; cursor: pointer; }

        /* Home Chips and Strips */
        .home-chips-row { display:flex; gap:10px; margin:10px 0; }
        .chip { display:flex; align-items:center; gap:8px; background: var(--card-background); border:1px solid var(--glass-blue); padding:8px 10px; border-radius:10px; text-decoration:none; color:inherit; }
        .chip i { background-image: linear-gradient(90deg, var(--blue), var(--pink)); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; }
        .chip-text { display:flex; flex-direction:column; gap:4px; }
        .chip-progress { width:140px; height:6px; background: rgba(255,255,255,0.1); border-radius:6px; overflow:hidden; }
        .chip-progress > div { height:100%; width:100%; background-image: linear-gradient(90deg, #ff4757 0%, #ff6b35 25%, #ffa726 50%, #ffd700 75%, #4caf50 100%); background-size:200% 100%; background-position:right; transition: background-position 0.8s ease-out; }


        .section-title { 
            font-weight: 700; 
            margin: 0 0 16px 0; 
            display: flex; 
            align-items: center; 
            gap: 8px;
            /* Prevent text shifting */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Enhanced scroll-row for friends carousel */
        .scroll-row { 
            display: flex; 
            gap: 12px; 
            overflow-x: auto; 
            overflow-y: hidden;
            padding: 8px 0 12px 0;
            /* Smooth scrolling like Facebook */
            scroll-behavior: smooth;
            scroll-snap-type: x mandatory;
            /* Hide scrollbar but keep functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
            /* Custom scrollbar for webkit browsers */
            position: relative;
            /* COMPLETELY ISOLATED horizontal scrolling */
            touch-action: pan-x;
            overscroll-behavior-x: contain;
            overscroll-behavior-y: none;
            /* Prevent any parent scrolling */
            contain: layout style paint;
            /* Create stacking context to isolate */
            transform: translateZ(0);
            will-change: scroll-position;
        }

        .scroll-row::-webkit-scrollbar { 
            height: 6px; 
            background: transparent;
        }

        .scroll-row::-webkit-scrollbar-thumb { 
            background: linear-gradient(90deg, var(--pink), var(--blue)); 
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .scroll-row::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, var(--blue), var(--pink));
        }
        .highlight-card, .saved-card { flex:0 0 auto; width:160px; border:1px solid var(--glass-blue); background: var(--card-background); border-radius:10px; overflow:hidden; }
        .highlight-card img, .saved-card img { width:100%; height:100px; object-fit:cover; display:block; } 



        /* Responsive adjustments */
        @media (max-width: 768px) {
            .content-wrapper {
                padding: 16px;
                gap: 16px;
            }
            
            .global-announcements-section {
                width: 95%;
                padding: 1rem;
                margin: 15px auto;
            }

            .announcement-header {
                gap: 0.8rem;
                padding-bottom: 0.8rem;
            }

            .announcement-title {
                font-size: 1.1rem;
            }

            .announcement-icon {
                font-size: 1.3rem;
            }

            .announcement-message {
                font-size: 0.95rem;
                padding: 0.8rem;
            }

            .announcement-meta {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }

        @media (max-width: 480px) {
            .scroll-row {
                gap: 8px;
                padding: 6px 0 10px 0;
            }
            

        }

        /* Engagement Panel */
        .engagement-panel { display:grid; grid-template-columns: 1fr; gap: 12px; margin: 10px 0; }
        .engage-card { background: var(--card-background); border:1px solid var(--glass-blue); border-radius: 15px; padding: 12px; }
        .engage-title { font-weight:600; margin-bottom:6px; }
        .quests-list { display:flex; flex-direction:column; gap:8px; }
        .quest-item { display:flex; align-items:center; justify-content:space-between; gap:10px; }
        .quest-progress { flex:1; height:8px; background:rgba(255,255,255,0.1); border-radius:6px; overflow:hidden; margin:0 8px; }
        .quest-progress > div { height:100%; background: var(--blue); }
        .spin-button { background: linear-gradient(90deg, var(--blue), var(--pink)); color:#fff; border:none; border-radius:10px; padding:8px 12px; cursor:pointer; }

        /* Theme Switcher */
        .theme-switcher { display:flex; gap:8px; align-items:center; }
        .theme-switcher select { padding:6px 10px; border-radius:8px; border:1px solid var(--border-light); background:var(--input-background); color:var(--white); }

        /* Story Viewer (compact) */
        #storyViewer { position: fixed; right: 16px; bottom: 16px; z-index: 1200; display: none; }
        #storyViewer.active { display: block; }
        #storyViewer .viewer-card {
            width: 300px; height: 520px; border-radius: 16px; overflow: hidden;
            background: var(--card-background); border: 1px solid var(--glass-blue);
            box-shadow: 0 12px 30px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;
        }
        #storyViewer .viewer-header { display:flex; align-items:center; justify-content:space-between; padding:8px 10px; }
        #storyViewer .viewer-title { color: var(--white); font-weight: 600; font-size: 0.95rem; }
        #storyViewer .viewer-close { background: transparent; border:none; color: var(--white); cursor:pointer; }
        #storyViewer .viewer-media { flex:1; display:flex; align-items:center; justify-content:center; background:#000; }
        #storyImage, #storyVideo { max-width:100%; max-height:100%; display:none; }
        #storyViewer .viewer-footer { display:flex; align-items:center; justify-content:space-between; padding:6px 10px; }
        #prevStoryBtn, #nextStoryBtn { background: rgba(255,255,255,0.1); color: var(--white); border: 1px solid var(--border-light); border-radius: 10px; padding: 6px 10px; cursor: pointer; }
    #smartScrollBtn { position: fixed; right: 16px; bottom: 90px; z-index: 1100; border: 1px solid var(--border-light); border-radius: 999px; background: var(--button-background); color: #fff; padding: 10px 14px; display: flex; align-items: center; gap: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.4); cursor: pointer; }
        #smartScrollBtn .label { font-weight: 600; }
    .icon-btn { background: transparent; border: 1px solid var(--border-light); color: var(--white); border-radius: 10px; padding: 6px 8px; margin-right: 8px; cursor: pointer; }
            /* Reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            html { scroll-behavior: auto; }
            *, *::before, *::after { animation: none !important; transition: none !important; }
        }
        /* Lightweight skeleton styles for loading states */
        @keyframes skeleton-shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton { background: linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.12), rgba(255,255,255,0.04)); background-size: 200% 100%; animation: skeleton-shimmer 1.2s linear infinite; border-radius: 10px; }
        .post-skeleton-card { background: var(--card-background); border: 1px solid var(--glass-blue); border-radius: var(--radius); padding: 16px; display: flex; flex-direction: column; gap: 12px; }
        .post-skeleton-header { display:flex; align-items:center; gap:10px; }
        .post-skeleton-avatar { width:32px; height:32px; border-radius:50%; }
        .post-skeleton-line { height:10px; }
        .post-skeleton-media { width:100%; height:150px; border-radius: 10px; }
        .post-visibility-badge { align-self:center; margin-left:auto; padding:4px 8px; border:1px solid var(--border-light); border-radius: 999px; color: var(--white); font-size: 0.75rem; background: rgba(255,255,255,0.05); }
</style>
<style id="header-overflow-fix">
/*header-overflow-fix*/
header .header-content-wrapper{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:nowrap}
header .logo{flex:0 0 auto;white-space:nowrap}
header #sidebarToggleFab{flex:0 0 auto}
header .user-profile-header{display:flex;align-items:center;gap:10px;flex:1 1 auto;min-width:0;justify-content:flex-end}
#profileLink{display:inline-flex;align-items:center;column-gap:8px;row-gap:2px;flex-wrap:nowrap;max-width:100%;min-width:0}
#headerProfilePic,#headerAvatarIcon{flex:0 0 auto}
#headerProfilePic{display:none;border-radius:50%;object-fit:cover;border:1px solid var(--border-light);box-shadow:0 0 10px rgba(255,46,146,0.6),0 0 10px rgba(0,213,255,0.6)}
#headerAvatarIcon{font-size:36px;box-shadow:0 0 10px rgba(255,46,146,0.6),0 0 10px rgba(0,213,255,0.6);border-radius:50%}
#headerDisplayName{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:240px;flex:0 1 auto}
.notification-icon-wrapper{flex:0 0 auto}
#premiumRequestBtn{flex:0 0 auto}
@media (max-width:800px){#headerDisplayName{max-width:180px}}
@media (max-width:600px){header .header-content-wrapper{gap:8px}#profileLink{column-gap:6px}#headerDisplayName{max-width:140px}#premiumRequestBtn span{display:none}}
</style></head>
<body class="theme-dark-mode">
    <!-- JCHAT Pink & Blue Glowing Loader -->
    <div id="jchatLoader" class="jchat-loader">
        <div class="loader-container">
            <div class="loader-spinner"></div>
            <div class="loader-particles">
                <div class="particle"></div>
                <div class="particle"></div>
                <div class="particle"></div>
                <div class="particle"></div>
            </div>
            <div class="loader-text">JCHAT</div>
            <div class="loader-subtext">
                Loading your experience
                <span class="loader-dots">
                    <span class="loader-dot"></span>
                    <span class="loader-dot"></span>
                    <span class="loader-dot"></span>
                </span>
            </div>
            <div class="loader-progress" role="progressbar" aria-label="Loading progress" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="loader-progress-bar"></div></div>
        </div>
    </div>

    <header>
        <div class="header-content-wrapper">
            <!-- Sidebar Toggle Button in Header -->
            <button id="sidebarToggleFab" aria-label="Toggle Navigation">
                <i class="fas fa-bars"></i>
            </button>
            <a href="/Home.html" class="logo">
                <span>JCHAT</span>
            </a>
            <!-- Removed Header Navigation (Home, Profile) -->
            <div class="user-profile-header">
                <!-- Admin Icon Link (visible only to admin) -->
                <a href="/Admin.html" id="adminIconLink" aria-label="Admin Dashboard" style="display: none;">
                    <i class="fas fa-user-cog"></i>
                </a>
                <!-- Notification Icon with Badge -->
                <div class="notification-icon-wrapper">
                    <a href="/notifications.html" id="notificationToggle" aria-label="Notifications">
                        <i class="fas fa-bell"></i>
                        <span class="notification-badge" id="notificationCount">0</span>
                    </a>
                    <!-- Notification Dropdown -->
                    <div id="notificationDropdown" class="notification-dropdown" style="display: none;">
                        <div class="notification-header">
                            <h3>Recent Notifications</h3>
                            <a href="/notifications.html" class="view-all-link">View All</a>
                        </div>
                        <div id="notificationList" class="notification-list">
                            <div class="notification-loading">
                                <i class="fas fa-spinner fa-spin"></i>
                                <p>Loading notifications...</p>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Premium Request Button -->
                <button id="premiumRequestBtn" class="premium-request-btn" aria-label="Request Premium Access" style="display:none;">
                    <i class="fas fa-crown"></i>
                    <span>Get Premium</span>
                </button>
                
                <!-- Profile Link with Picture and Name -->
                <a href="./Profile.html" id="profileLink" aria-label="View Profile">
                    <img id="headerProfilePic" src="" alt="Profile Picture" loading="lazy" decoding="async">
                    <i id="headerAvatarIcon" class="fas fa-user-circle" role="img" aria-label="User Avatar"></i>
                    <span id="headerDisplayName">Loading...</span>
                    <span id="headerPremiumBadge" class="premium-badge" style="display: none;"></span>
                </a>
            </div>
        </div>
    </header>



    <a href="#main-content" class="skip-link" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;">Skip to main content</a>

    <main id="main-content">
        <div class="content-wrapper">
            <!-- Daily Inspiration Section -->
            <div class="daily-inspiration-section">
                <h2>Daily Inspiration</h2>
                <p id="inspirationQuote" class="quote-text">"Breathe: peace finds its way in."</p>
                <p id="inspirationAuthor" class="quote-author">- JCHAT</p>
                <div class="inspiration-actions">
                    <button id="sharePostInspirationButton" class="inspiration-action-button" disabled aria-label="Share Inspiration as Post">
                        <i class="fas fa-share-alt"></i> Share / Post
                    </button>
                    <button id="customizeInspirationButton" class="inspiration-action-button" aria-label="Customize Inspiration Type" disabled=""><i class="fas fa-cog"></i> Customize Inspiration </button>
                    <!-- NEW: Daily Bonus Button -->
                    <button id="claimDailyBonusButton" class="inspiration-action-button" aria-label="Claim Daily Bonus" disabled=""><span class="button-text">Login to Claim Bonus</span></button>
                            </div>
            
            <!-- Share Inspiration Modal -->
            <div id="shareInspirationModal" class="modal-overlay share-modal" role="dialog" aria-modal="true" aria-labelledby="shareInspirationTitle" style="display:none;">
                <div class="modal-content">
                    <h3 id="shareInspirationTitle">Share Inspiration</h3>
                    <div id="sharePreview" style="padding:10px;border:1px dashed var(--border-light);border-radius:10px;color:var(--white);">
                        <div id="sharePreviewQuote" style="font-style:italic"></div>
                        <div id="sharePreviewAuthor" style="opacity:0.8;margin-top:6px"></div>
                    </div>
                    <div class="share-options" style="display:flex;flex-direction:column;gap:10px;margin-top:10px;">
                        <button id="copyInspirationBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-copy"></i> Copy to Clipboard</button>
                        <div id="friendPicker" style="border:1px solid var(--border-light);border-radius:10px;padding:8px;display:none;max-height:200px;overflow:auto;"></div>
                        <button id="sendToFriendBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-paper-plane"></i> Send to Friend</button>
                        <button id="postInspirationBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-feather-alt"></i> Post It</button>
                        <button id="saveInspirationBtn" class="share-option-btn" style="display:flex;align-items:center;gap:10px; padding:10px 12px; border-radius:10px; border:1px solid var(--border-light); background: var(--button-background); color:#fff; cursor:pointer;"><i class="fas fa-bookmark"></i> Save Inspiration</button>
                    </div>
                    <div class="button-group" style="margin-top:12px;">
                        <button id="closeShareModalBtn" class="modal-button cancel-button">Close</button>
                    </div>
                </div>
            </div>
            </div>

            <!-- People You May Know Strip -->
            <div id="peopleMayKnow" style="display:none; margin: 16px auto; max-width: 900px;">
                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                    <div style="font-family: 'Poppins', sans-serif; font-weight:700; color: var(--white);">People you may know</div>
                    <button id="refreshPymkBtn" class="icon-btn" title="Refresh" style="border:1px solid var(--border-color); border-radius:10px; padding:6px 10px;"><i class="fas fa-rotate"></i></button>
                </div>
                <div id="pymkScroller" style="display:flex; gap:12px; overflow-x:auto; padding:8px; border:1px solid var(--border-color); border-radius:12px; background: var(--card-background);">
                </div>
            </div>

            <!-- Global Announcements Section -->
            <div id="globalAnnouncementsSection" class="global-announcements-section" style="display: none;">
                <div class="announcement-header">
                    <i class="fas fa-bullhorn announcement-icon"></i>
                    <h3 class="announcement-title">Important Announcement</h3>
                    <button id="dismissAnnouncementBtn" class="announcement-dismiss-btn" aria-label="Dismiss announcement">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="announcement-content">
                    <div class="announcement-type-badge" id="announcementTypeBadge"></div>
                    <div class="announcement-priority-badge" id="announcementPriorityBadge"></div>
                    <p id="announcementMessage" class="announcement-message"></p>
                    <div class="announcement-meta">
                        <small id="announcementTimestamp" class="announcement-timestamp"></small>
                        <small class="announcement-source">From JCHAT TEAM</small>
                    </div>
                </div>
            </div>

            <!-- Home Chips: Level and Wallet -->
            <div class="home-chips-row" id="homeChipsRow" style="display:none;">
                <div class="chip level-chip">
                    <i class="fas fa-star"></i>
                    <div class="chip-text">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <i id="levelChipIcon" class="fas fa-question-circle"></i>
                            <div id="levelChipName">Novice</div>
                            <div id="levelChipPercent" style="opacity:.85;font-size:.85rem;">0%</div>
                        </div>
                        <div class="chip-progress"><div id="levelChipProgressFill"></div></div>
                    </div>
                </div>
                <a href="#" id="walletChipLink" class="chip wallet-chip">
                    <i class="fas fa-wallet"></i>
                    <div class="chip-text">
                        <div><span id="walletChipAmount">0</span> JCoins</div>
                        <div class="chip-sub">Rate: ₦<span id="jcoinRate">0</span>/J</div>
                    </div>
                </a>
            </div>

            <!-- Premium Features Section -->
            <div class="premium-features-section" id="premiumFeaturesSection" style="display: none;">
                <h3>🌟 Premium Features</h3>
                <p style="color: var(--text-light); margin-bottom: 15px;">Unlock exclusive features with your premium subscription!</p>
                
                <div class="premium-features-grid">
                    <div class="premium-feature-card">
                        <div class="premium-feature-icon">����</div>
                        <div class="premium-feature-title">Custom Themes</div>
                        <div class="premium-feature-desc">Choose from exclusive premium themes</div>
                        <div style="margin-top: 10px;">
                            <button class="premium-post-option" onclick="applyPremiumTheme('dark')">Dark Theme</button>
                            <button class="premium-post-option" onclick="applyPremiumTheme('neon')">Neon Theme</button>
                            <button class="premium-post-option" onclick="applyPremiumTheme('glass')">Glass Theme</button>
                        </div>
                    </div>
                    
                    <div class="premium-feature-card">
                        <div class="premium-feature-icon">�����</div>
                        <div class="premium-feature-title">Ad-Free Experience</div>
                        <div class="premium-feature-desc">Enjoy JCHAT without any advertisements</div>
                    </div>
                    
                    <div class="premium-feature-card">
                        <div class="premium-feature-icon">���</div>
                        <div class="premium-feature-title">Priority Support</div>
                        <div class="premium-feature-desc">Get faster response times from support</div>
                    </div>
                    
                    <div class="premium-feature-card">
                        <div class="premium-feature-icon">��</div>
                        <div class="premium-feature-title">Advanced Features</div>
                        <div class="premium-feature-desc">Access to exclusive tools and options</div>
                    </div>
                </div>
            </div>
            <!-- Highlights Strip -->
            <div class="highlights-section" id="highlightsSection" style="display:none;">
                <div class="section-title"><i class="fas fa-bookmark"></i> Highlights</div>
                <div class="scroll-row" id="highlightsStrip"></div>
            </div>

            <!-- Saved Widget -->
            <div class="saved-widget-section" id="savedWidgetSection" style="display:none;">
                <div class="section-title"><i class="fas fa-bookmark"></i> Saved</div>
                <div class="scroll-row" id="savedWidget"></div>
            </div>


            <!-- Post Creation Section -->
            <div class="post-creation-section" id="postCreationSection" style="display: flex;">
                <h3>Create New Post</h3>
                <textarea id="postContent" placeholder="What's on your mind?" maxlength="50000" aria-label="Post Content" disabled=""></textarea>
                <div class="media-upload-area">
                    <label for="postMediaUpload" class="file-input-label" aria-label="Add Media to Post">
                        <i class="fas fa-image"></i> Add Media
                    </label>
                    <input type="file" id="postMediaUpload" accept="image/*,video/*" disabled="">
                    <img id="mediaImagePreview" class="media-preview" src="" alt="Image Preview" loading="lazy" decoding="async" style="display: none;">
                    <video id="mediaVideoPreview" class="media-preview" src="" controls preload="metadata" playsinline style="display: none;"></video>
                </div>
                <div style="margin:8px 0; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:6px;">
                        <input type="checkbox" id="addPollCheckbox"> Add Poll
                    </label>
                    <div id="pollComposer" style="display:none; flex-direction:column; gap:6px; width:100%;">
                        <input type="text" class="poll-option-input" placeholder="Option 1" maxlength="100">
                        <input type="text" class="poll-option-input" placeholder="Option 2" maxlength="100">
                        <button id="addPollOptionBtn" class="post-control-button" type="button" style="width:max-content;">Add Option</button>
                    </div>
                    <label for="postVisibilitySelect" style="display:flex; align-items:center; gap:6px; margin-left:auto;">
                        <i class="fas fa-eye"></i>
                        <select id="postVisibilitySelect" aria-label="Post visibility" style="padding:8px 10px; border-radius:8px; border:1px solid var(--border-light); background:var(--input-background); color:var(--white);">
                            <option value="public">Public</option>
                            <option value="friends">Friends</option>
                            <option value="private">Only me</option>
                        </select>
                    </label>
                </div>
                <div class="post-actions">
                    <button id="createPostButton" class="post-button" aria-label="Create Post" disabled="">
                        <span class="button-text">Post</span>
                    </button>
                </div>
                
                <!-- Premium Post Options -->
                <div class="premium-post-options" id="premiumPostOptions" style="display: none;">
                    <div class="premium-post-option" onclick="togglePremiumPostOption('priority')">
                        <i class="fas fa-star"></i> Priority Post
                    </div>
                    <div class="premium-post-option" onclick="togglePremiumPostOption('exclusive')">
                        <i class="fas fa-crown"></i> Exclusive Content
                    </div>
                    <div class="premium-post-option" onclick="togglePremiumPostOption('custom')">
                        <i class="fas fa-magic"></i> Custom Styling
                    </div>
                </div>
            </div>

            <div id="trendingHashtags" style="margin:8px 0;color:var(--text-light);font-size:0.9rem;"></div>

            <!-- Engagement Panel -->
            <div class="engagement-panel" style="display:none;" id="engagementPanel">
                <div class="engage-card" id="streakCard">
                    <div class="engage-title">Daily Streak</div>
                    <div id="streakInfo" style="color:var(--text-light);">Loading streak...</div>
                </div>
                <div class="engage-card" id="questsCard">
                    <div class="engage-title">Weekly Quests</div>
                    <div class="quests-list" id="questsList"></div>
                </div>
                <div class="engage-card" id="spinCard">
                    <div class="engage-title">Daily Spin</div>
                    <button class="spin-button" id="spinNowButton"><i class="fas fa-sync"></i> Spin Now</button>
                    <div id="spinStatus" style="color:var(--text-light); margin-top:6px;"></div>
                </div>
                <div class="engage-card" id="storiesCard">
                    <div style="display:flex;align-items:center;justify-content:space-between;">
                        <div class="engage-title">Stories</div>
                        <button class="add-story-button" id="addStoryButton"><i class="fas fa-plus"></i> Add Story</button>
                        <input type="file" id="storyUploadInput" accept="image/*,video/*" style="display:none;">
                    </div>
                    <div class="stories-bar" id="storiesBar"></div>
                </div>
            </div>

            <!-- Posts Feed Section -->
            <div class="posts-feed-section" id="postsFeed">
                <!-- Posts will be loaded here dynamically -->
                <p style="text-align: center; color: var(--text-light);" id="loadingPostsMessage">Loading posts...</p>
            </div>
        </div>
    </main>

    <!-- Customization Modal -->
    <div id="customizeInspirationModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="customizeInspirationModalTitle">
        <div class="modal-content">
            <h3 id="customizeInspirationModalTitle">Customize Inspiration Type</h3>
            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="motivational" checked aria-label="Motivational Inspiration">
                    Motivational
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="peaceful" aria-label="Peaceful Inspiration">
                    Peaceful
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="funny" aria-label="Funny Inspiration">
                    Funny
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="wisdom" aria-label="Wisdom Inspiration">
                    Wisdom
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="love" aria-label="Love Inspiration">
                    Love
                </label>
                <label class="radio-option">
                    <input type="radio" name="inspirationType" value="off" aria-label="Turn Off Inspiration">
                    Off
                </label>
            </div>
            <div class="button-group">
                <button id="cancelCustomize" class="modal-button cancel-button" aria-label="Cancel Customization">Cancel</button>
                <button id="saveCustomize" class="modal-button save-button" aria-label="Save Customization">Save</button>
            </div>
        </div>
    </div>

                <!-- Wallet Locked Modal -->
            <div id="walletLockedModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="walletLockedTitle" style="display:none;">
                <div class="modal-content">
                    <h3 id="walletLockedTitle"><i class="fas fa-lock"></i> Wallet Locked</h3>
                    <p style="color:var(--text-light);">Your wallet is locked. Pay ₦5000 to request unlock. A developer will unlock it after confirming your payment.</p>
                    <div class="button-group" style="display:flex;gap:10px;justify-content:flex-end;">
                        <button id="closeWalletLockedBtn" class="modal-button cancel-button">Close</button>
                        <a id="walletPayBtn" href="/Wallet.html?unlock=1&amount=5000" class="modal-button confirm-button">Pay ₦5000</a>
                    </div>
                </div>
            </div>

            <!-- Filters Modal -->
    <div id="filtersModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="filtersModalTitle" style="display:none;">
        <div class="modal-content">
            <h3 id="filtersModalTitle">Feed Filters</h3>
            <div class="input-group" style="display:flex;gap:8px;flex-wrap:wrap;">
                <label><input type="radio" name="filterType" value="all" checked> All</label>
                <label><input type="radio" name="filterType" value="text"> Text</label>
                <label><input type="radio" name="filterType" value="image"> Images</label>
                <label><input type="radio" name="filterType" value="video"> Videos</label>
            </div>
            <div class="input-group" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="filterSavedOnly"> Saved only</label>
                <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="filterFollowedOnly"> Followed tags</label>
                <input type="date" id="filterDateFrom" placeholder="From">
                <input type="date" id="filterDateTo" placeholder="To">
            </div>
            <div class="button-group" style="display:flex;gap:10px;justify-content:flex-end;">
                <button id="resetFiltersBtn" class="modal-button cancel-button">Reset</button>
                <button id="applyFiltersBtn" class="modal-button confirm-button">Apply</button>
            </div>
        </div>
    </div>

                <!-- Premium Request Modal -->
            <div id="premiumRequestModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="premiumRequestModalTitle" style="display:none;">
                <div class="modal-content">
                    <h3 id="premiumRequestModalTitle">🌟 Request Premium Access</h3>
                    <p style="color:var(--text-light); margin-bottom: 1rem;">
                        Choose your premium tier and submit your request. You'll be redirected to payment after submission.
                    </p>
                    
                    <div class="premium-tiers">
                        <div class="premium-tier-option" data-tier="premium">
                            <div class="tier-header">
                                <span class="tier-badge">🌟 Premium</span>
                                <span class="tier-price">$9.99/month</span>
                            </div>
                            <ul class="tier-features">
                                <li>Premium Badge</li>
                                <li>Custom Themes</li>
                                <li>Ad-free Experience</li>
                            </ul>
                        </div>
                        
                        <div class="premium-tier-option" data-tier="vip">
                            <div class="tier-header">
                                <span class="tier-badge">💎 VIP</span>
                                <span class="tier-price">$19.99/month</span>
                            </div>
                            <ul class="tier-features">
                                <li>VIP Badge</li>
                                <li>Priority Support</li>
                                <li>Advanced Features</li>
                                <li>All Premium Features</li>
                            </ul>
                        </div>
                        
                        <div class="premium-tier-option" data-tier="elite">
                            <div class="tier-header">
                                <span class="tier-badge">👑 Elite</span>
                                <span class="tier-price">$39.99/month</span>
                            </div>
                            <ul class="tier-features">
                                <li>Elite Badge</li>
                                <li>Exclusive Content</li>
                                <li>Custom Features</li>
                                <li>All VIP Features</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="premiumRequestMessage">Additional Message (Optional):</label>
                        <textarea id="premiumRequestMessage" placeholder="Tell us why you want premium access..." maxlength="500"></textarea>
                    </div>
                    
                    <div class="button-group" style="display:flex;gap:10px;justify-content:flex-end;">
                        <button id="cancelPremiumRequestBtn" class="modal-button cancel-button">Cancel</button>
                        <button id="submitPremiumRequestBtn" class="modal-button confirm-button">Submit Request</button>
                    </div>
                </div>
            </div>

            <!-- Edit Post Modal -->
            <div id="editPostModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="editPostModalTitle">
                <div class="modal-content">
                    <h3 id="editPostModalTitle">Edit Post</h3>
                    <div class="input-group">
                        <label for="editPostContent">Post Content:</label>
                        <textarea id="editPostContent" maxlength="500" aria-label="Edit Post Content"></textarea>
                    </div>
                    <div class="input-group">
                        <label for="editPostVisibilitySelect">Visibility:</label>
                        <select id="editPostVisibilitySelect" aria-label="Edit Post Visibility" style="padding:8px 10px; border-radius:8px; border:1px solid var(--border-light); background:var(--input-background); color:var(--white);">
                            <option value="public">Public</option>
                            <option value="friends">Friends</option>
                            <option value="private">Only me</option>
                        </select>
                    </div>
                    <div class="media-upload-area">
                        <label for="editPostMediaUpload" class="file-input-label" aria-label="Change Media for Post">
                            <i class="fas fa-image"></i> Change Media
                </label>
                <input type="file" id="editPostMediaUpload" accept="image/*,video/*">
                <img id="editMediaImagePreview" class="media-preview" src="" alt="Image Preview" loading="lazy" decoding="async" style="display: none;">
                <video id="editMediaVideoPreview" class="media-preview" src="" controls preload="metadata" playsinline style="display: none;"></video>
                <button id="removeEditMedia" class="modal-button cancel-button" style="display: none;" aria-label="Remove Media from Post">Remove Media</button>
            </div>
            <div class="button-group">
                <button id="cancelEditPost" class="modal-button cancel-button" aria-label="Cancel Editing">Cancel</button>
                <button id="saveEditedPost" class="modal-button save-button" aria-label="Save Edited Post">
                    <span class="button-text">Save Changes</span>
                    
                </button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="confirmationTitle">
        <div class="modal-content">
            <h3 id="confirmationTitle">Confirm Action</h3>
            <p id="confirmationMessage">Are you sure you want to proceed with this action?</p>
            <div class="button-group">
                <button id="confirmCancelButton" class="modal-button cancel-button" aria-label="Cancel">Cancel</button>
                <button id="confirmProceedButton" class="modal-button confirm-button" aria-label="Proceed">Proceed</button>
            </div>
        </div>
    </div>

    <!-- Custom Message Box -->
    <div id="messageBox" role="alert" aria-live="polite"></div>

    <!-- NEW: Maintenance Mode Overlay -->
    <div id="maintenanceOverlay" role="dialog" aria-modal="true" aria-labelledby="maintenanceOverlayTitle">
        <i class="fas fa-tools" role="img" aria-label="Maintenance Icon"></i>
        <h2 id="maintenanceOverlayTitle">Maintenance Mode</h2>
        <p id="maintenanceAnnouncementText">JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!</p>
    </div>
    <!-- Call Overlay (NEW) -->
    <div id="callOverlay" role="dialog" aria-modal="true" aria-labelledby="callStatusText">
        <div class="video-streams">
            <video id="remoteVideo" autoplay playsinline preload="metadata" aria-label="Remote Video Stream"></video>
            <video id="localVideo" autoplay playsinline muted preload="metadata" aria-label="Local Video Stream"></video>
        </div>
        <i id="callStatusIcon" class="fas fa-phone" role="img" aria-label="Call Status Icon"></i>
        <p id="callStatusText" class="call-status-text">Calling...</p>
        <p id="callTimer" class="call-timer" style="display: none;" aria-live="polite">00:00</p>
        <div class="call-actions" id="callActions">
            <button id="acceptCallBtn" class="accept-call-btn" style="display: none;" aria-label="Accept Call"><i class="fas fa-phone"></i></button>
            <button id="declineCallBtn" class="decline-call-btn" style="display: none;" aria-label="Decline Call"><i class="fas fa-phone-slash"></i></button>
            <button id="toggleMuteBtn" class="toggle-mute-btn" style="display: none;" title="Mute/Unmute" aria-label="Toggle Mute"><i class="fas fa-microphone"></i></button>
            <button id="toggleVideoBtn" class="toggle-video-btn" style="display: none;" title="Turn Video On/Off" aria-label="Toggle Video"><i class="fas fa-video"></i></button>
            <button id="endCallBtn" class="end-call-btn" style="display: none;" aria-label="End Call"><i class="fas fa-phone-slash"></i></button>
        </div>
    </div>
    <!-- Sidebar Navigation -->
    <div id="sidebarBackdrop" class="sidebar-backdrop" aria-hidden="true"></div>
    <aside id="sidebarNav" class="sidebar-hidden" role="navigation" aria-label="Main Navigation">
        <div class="sidebar-header">
            <span class="sidebar-title">JCHAT Menu</span>
            <button id="sidebarCloseBtn" aria-label="Close Menu">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="sidebar-links">
            <a href="/Home.html" class="sidebar-nav-item active" aria-current="page">
                <i class="fas fa-home"></i>
                <span>Home</span>
            </a>
            <a href="/Explore.html" class="sidebar-nav-item">
                <i class="fas fa-hashtag"></i>
                <span>Explore</span>
            </a>
            <a href="/Profile.html" class="sidebar-nav-item">
                <i class="fas fa-user"></i>
                <span>Profile</span>
            </a>
            <a href="/Chat.html" class="sidebar-nav-item" id="chatLink">
                <i class="fas fa-comment-dots"></i>
                <span>Chat</span>
            </a>
            <a href="/Find_Friends.html" class="sidebar-nav-item" id="findFriendsLink">
                <i class="fas fa-users"></i>
                <span>Users</span>
            </a>
            <a href="/Friends.html" class="sidebar-nav-item" id="friendsLink">
                <i class="fas fa-user-friends"></i>
                <span>Friends</span>
            </a>
            <a href="/Groups.html" class="sidebar-nav-item" id="groupsLink">
                <i class="fas fa-layer-group"></i> <!-- New Groups icon -->
                <span>Groups</span>
            </a>
            <a href="#" id="sidebarThemeLink" class="sidebar-nav-item">
                <i class="fas fa-palette"></i>
                <span>Appearance</span>
            </a>
            <a href="/Settings.html" class="sidebar-nav-item">
                <i class="fas fa-cog"></i>
                <span>Settings</span>
            </a>
            <a href="/About_Us.html" class="sidebar-nav-item">
                <i class="fas fa-globe"></i>
                <span>About Us</span>
            </a>
            <a href="/solution_center.html" class="sidebar-nav-item">
                <i class="fas fa-question-circle"></i>
                <span>Solution Center</span>
            </a>
            <!-- NEW: Guide Link - moved inside sidebar-links -->
            <a href="/Guide.html" class="sidebar-nav-item">
                <i class="fas fa-book"></i>
                <span>Guide</span>
                </a>
            <!-- NEW: Guide Link - moved inside sidebar-links -->
            <a href="/Community_guidelines.html" class="sidebar-nav-item">
                <i class="fas fa-exclamation-triangle"></i>
                <span>Community Guidelines</span>
            </a>
            <!-- New: Logout Link in Sidebar -->
            <a href="#" id="sidebarLogoutLink" class="sidebar-nav-item">
                <i class="fas fa-sign-out-alt"></i>
                <span>Logout</span>
            </a>
        </div>
    </aside>

    <!-- Smart Scroll Button -->
    <button id="smartScrollBtn" aria-label="Smart Scroll"><i class="fas fa-arrow-down"></i><span class="label">Bottom</span></button>

    <!-- Compact Story Viewer -->
    <div id="storyViewer" aria-live="polite">
        <div class="viewer-card">
            <div class="viewer-header">
                <div class="viewer-title" id="storyViewerTitle">Story</div>
                <button class="viewer-close" id="closeStoryViewer" aria-label="Close"><i class="fas fa-times"></i></button>
            </div>
            <div class="viewer-media">
                <img id="storyImage" alt="story image" loading="lazy" decoding="async" />
                <video id="storyVideo" controls playsinline preload="metadata"></video>
            </div>
            <div class="viewer-footer">
                <button id="prevStoryBtn"><i class="fas fa-chevron-left"></i> Prev</button>
                <button id="nextStoryBtn">Next <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>
    <script type="module">
        console.log("JCHAT_DEBUG: Home.html script started.");
        
        // --- JCHAT Loader Management ---
        const jchatLoader = document.getElementById('jchatLoader');
        let loaderTimeout;
        let loaderStartTs = 0;
        let LOADER_MIN_MS = 1200; // ensure smooth, non-flashy experience (first visit)
        let LOADER_MAX_MS = 12000; // absolute fallback
        // Shorter loader on subsequent visits for snappier feel
        const __isFirstVisit = !sessionStorage.getItem('jchatFirstVisitShown');
        if (!__isFirstVisit) { LOADER_MIN_MS = 400; }
        sessionStorage.setItem('jchatFirstVisitShown', '1');

        // staged progress map -> smarter messaging
        const loaderStages = [
            { key: 'init', label: 'Initializing JCHAT' },
            { key: 'firebase', label: 'Connecting to servers' },
            { key: 'auth', label: 'Checking your session' },
            { key: 'settings', label: 'Applying your preferences' },
            { key: 'profile', label: 'Loading your profile' },
            { key: 'feed', label: 'Preparing your feed' },
        ];
        const completedStages = new Set();

        function renderLoaderMessage() {
            const subtext = jchatLoader?.querySelector('.loader-subtext');
            const bar = jchatLoader?.querySelector('.loader-progress-bar');
            const track = jchatLoader?.querySelector('.loader-progress');
            if (!subtext) return;
            const nextStage = loaderStages.find(s => !completedStages.has(s.key));
            const message = !navigator.onLine ? 'Working offline' : (nextStage ? nextStage.label : 'Almost there');
            const dotsHtml = `<span class="loader-dots">
                <span class="loader-dot"></span>
                <span class="loader-dot"></span>
                <span class="loader-dot"></span>
            </span>`;
            subtext.innerHTML = message + dotsHtml;
            // Update progress bar
            const progress = Math.min(loaderStages.length, completedStages.size) / loaderStages.length;
            const pct = Math.max(0, Math.min(100, Math.round(progress * 100)));
            if (bar) bar.style.width = pct + '%';
            if (track) track.setAttribute('aria-valuenow', String(pct));
        }

        function setLoaderStage(stageKey) {
            if (!stageKey) return;
            completedStages.add(stageKey);
            renderLoaderMessage();
        }
        window.setLoaderStage = setLoaderStage;

        function showLoader() {
            if (!jchatLoader) return;
            loaderStartTs = performance.now();
            jchatLoader.style.display = 'flex';
            jchatLoader.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            renderLoaderMessage();
            console.log('JCHAT_DEBUG: Loader shown');
        }

        function hideLoader() {
            if (!jchatLoader) return;
            const elapsed = performance.now() - loaderStartTs;
            const wait = Math.max(0, LOADER_MIN_MS - elapsed);
            const doHide = () => {
                jchatLoader.classList.add('hidden');
                document.body.style.overflow = 'auto';
                console.log('JCHAT_DEBUG: Loader hidden');
                setTimeout(() => {
                    if (jchatLoader.classList.contains('hidden')) {
                        jchatLoader.style.display = 'none';
                    }
                }, 500);
            };
            if (wait > 0) setTimeout(doHide, wait); else doHide();
        }

        function setLoaderTimeout() {
            clearTimeout(loaderTimeout);
            loaderTimeout = setTimeout(() => {
                console.log('JCHAT_DEBUG: Loader auto-hide after timeout');
                hideLoader();
            }, LOADER_MAX_MS);
        }

        // Initialize loader on page load
        showLoader();
        setLoaderTimeout();
        setLoaderStage('init');
        
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(reg => {
                    // Listen for SW messages (e.g., background sync to flush post queue)
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        if (event.data && event.data.type === 'FLUSH_POST_QUEUE') {
                            flushOfflineQueue();
                        }
                    });
                }).catch(err => console.log('SW registration failed', err));
            });
        }

        // Import Firebase modules (Updated to v11.8.0 - Latest Stable)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, orderBy, where, getDocs, addDoc, runTransaction, writeBatch, serverTimestamp, arrayUnion, arrayRemove, onSnapshot, documentId } from "https://www.gstatic.com/firebasejs/11.8.0/firebase-firestore.js";

        // --- Firebase & Canvas Environment Configuration ---
        // Firebase configuration, dynamically loaded from Canvas environment variables if available.
        // Provides fallback values for local development if environment variables are not set.
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyDz-8N0totzvMCvonF9pKj9RsoH3J8xL0w",
            authDomain: "jchat-1.firebaseapp.com",
            databaseURL: "https://jchat-1-default-rtdb.firebaseio.com",
            projectId: "jchat-1",
            storageBucket: "jchat-1.firebasestorage.app",
            messagingSenderId: "328479683167",
            appId: "1:328479683167:web:276c0b7e8ea44dd2d6a1ea",
            measurementId: "G-S6Z9GG0R9P"
        };
        // Application ID, dynamically loaded from Canvas environment or defaults for local.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // Initial authentication token for Canvas environment.
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Cloudinary Configuration for media uploads.
        const cloudinaryConfig = {
            cloudName: "dxld01rcp",
            uploadPreset: "Storage_preset"
        };

        // Enhanced Client-Side Features (Updated)
        const JCHAT_VERSION = "2.1.0";
        const CACHE_VERSION = "jchat-v2.1.0";
        
        // Offline Detection
        let isOnline = navigator.onLine;
        if (!isOnline) {
            window.location.replace('/offline.html');
        }
        window.addEventListener('online', () => {
            isOnline = true;
            console.log('JCHAT_DEBUG: Back online');
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            console.log('JCHAT_DEBUG: Gone offline');
            window.location.replace('/offline.html');
        });

        // Global Error Handling - Temporarily disabled for debugging
        window.addEventListener('error', (event) => {
            console.error('JCHAT_ERROR: Unhandled error:', event.error);
            console.error('JCHAT_ERROR: Error details:', {
                name: event.error?.name,
                message: event.error?.message,
                stack: event.error?.stack,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
            
            // Temporarily disabled to debug profile link issues
            // if (typeof showMessageBox === 'function' && messageBox && event.error) {
            //     showMessageBox('An unexpected error occurred. Please refresh if issues persist.', 'error');
            // }
        });

        // Performance Monitoring
        const performanceObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'navigation') {
                    console.log(`JCHAT_PERF: Page load time: ${entry.loadEventEnd - entry.loadEventStart}ms`);
                }
            }
        });
        
        if ('PerformanceObserver' in window) {
            performanceObserver.observe({ entryTypes: ['navigation'] });
        }

        // Initialize Firebase services: App, Auth, and Firestore.
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        if (typeof setLoaderStage === 'function') setLoaderStage('firebase');

        // --- ADMIN UID ---
        // The specific UID for the administrator, used for feature toggling and permissions.
        const ADMIN_UID = 'cc96gdhCRPO72NFZtleRCujHvIq2';

        // --- DOM Elements (Initialize after DOM is loaded) ---
        let themeSwitcherBtn, headerProfilePic, headerAvatarIcon, headerDisplayName;
        let notificationCountElement, adminIconLink, profileLink;
        let inspirationQuoteElement, inspirationAuthorElement, sharePostInspirationButton;
        let customizeInspirationButton, claimDailyBonusButton, customizeInspirationModal;
        let inspirationTypeRadios, cancelCustomizeButton, saveCustomizeButton;
        let postCreationSection, postContentInput, postMediaUpload, mediaImagePreview, mediaVideoPreview;
        let createPostButton, postsFeed, loadingPostsMessage, postTypeFilter, postSearchInput;
        let postDateFromInput, postDateToInput, exportPostsCsvButton, exportPostsJsonButton;
        let showSavedOnlyCheckbox, showFollowedOnlyCheckbox, trendingHashtagsDiv, editPostModal, editPostContentInput;
        let editPostMediaUpload, editMediaImagePreview, editMediaVideoPreview, removeEditMediaButton;
        let cancelEditPostButton, saveEditedPostButton;
        // Theme switcher functionality
        let currentTheme = 'theme-dark-mode'; // Default theme
        const themeSwitcherThemes = ['theme-light-mode', 'theme-dark-mode', 'theme-sunset-mode', 'theme-glass-mode', 'theme-ocean-mode', 'theme-forest-mode', 'theme-cosmic-mode', 'theme-retro-mode', 'theme-neon-mode', 'theme-elegant-mode', 'theme-quantum-nexus', 'theme-holographic-matrix', 'theme-stellar-genesis', 'theme-circus-maximus', 'theme-temporal-paradox'];
        
        // Theme catalog with pricing and product IDs - Premium themes locked (NGN pricing)
        const themeCatalog = {
            'theme-light-mode': { name: 'Light Mode', price: 0, currency: 'NGN', isFree: true, productId: null },
            'theme-dark-mode': { name: 'Dark Mode', price: 0, currency: 'NGN', isFree: true, productId: null },
            'theme-sunset-mode': { name: 'Sunset Theme', price: 0, currency: 'NGN', isFree: true, productId: null },
            'theme-glass-mode': { name: 'Glass Mode', price: 0, currency: 'NGN', isFree: true, productId: null },
            'theme-ocean-mode': { name: 'Ocean Theme', price: 1500, currency: 'NGN', isFree: false, productId: 'theme_ocean_premium' },
            'theme-forest-mode': { name: 'Forest Theme', price: 1800, currency: 'NGN', isFree: false, productId: 'theme_forest_premium' },
            'theme-cosmic-mode': { name: 'Cosmic Theme', price: 2000, currency: 'NGN', isFree: false, productId: 'theme_cosmic_premium' },
            'theme-retro-mode': { name: 'Retro Theme', price: 2200, currency: 'NGN', isFree: false, productId: 'theme_retro_premium' },
            'theme-neon-mode': { name: 'Neon Theme', price: 2500, currency: 'NGN', isFree: false, productId: 'theme_neon_premium' },
            'theme-elegant-mode': { name: 'Elegant Theme', price: 2800, currency: 'NGN', isFree: false, productId: 'theme_elegant_premium' },
            'theme-quantum-nexus': { name: '🌌 Quantum Nexus', price: 3000, currency: 'NGN', isFree: false, productId: 'theme_quantum_nexus_premium' },
            'theme-holographic-matrix': { name: '🎭 Holographic Matrix', price: 3300, currency: 'NGN', isFree: false, productId: 'theme_holographic_matrix_premium' },
            'theme-stellar-genesis': { name: '🌟 Stellar Genesis', price: 3600, currency: 'NGN', isFree: false, productId: 'theme_stellar_genesis_premium' },
            'theme-circus-maximus': { name: '🎪 Circus Maximus', price: 4000, currency: 'NGN', isFree: false, productId: 'theme_circus_maximus_premium' },
            'theme-temporal-paradox': { name: '🔮 Temporal Paradox (VIP)', price: 5000, currency: 'NGN', isFree: false, productId: 'theme_temporal_paradox_premium', isVip: true }
        };

        // Theme purchase/lock state
        let purchasedThemeProductIds = new Set();
        let pendingThemeProductIds = new Set();

        // Mapping between shop product IDs and theme classes
        const productIdToThemeClass = {
            'theme_ocean_premium': 'theme-ocean-mode',
            'theme_forest_premium': 'theme-forest-mode',
            'theme_cosmic_premium': 'theme-cosmic-mode',
            'theme_retro_premium': 'theme-retro-mode',
            'theme_neon_premium': 'theme-neon-mode',
            'theme_elegant_premium': 'theme-elegant-mode',
            'theme_quantum_nexus_premium': 'theme-quantum-nexus',
            'theme_holographic_matrix_premium': 'theme-holographic-matrix',
            'theme_stellar_genesis_premium': 'theme-stellar-genesis',
            'theme_circus_maximus_premium': 'theme-circus-maximus',
            'theme_temporal_paradox_premium': 'theme-temporal-paradox'
        };

        const themeClassToProductId = {
            'theme-ocean-mode': 'theme_ocean_premium',
            'theme-forest-mode': 'theme_forest_premium',
            'theme-cosmic-mode': 'theme_cosmic_premium',
            'theme-retro-mode': 'theme_retro_premium',
            'theme-neon-mode': 'theme_neon_premium',
            'theme-elegant-mode': 'theme_elegant_premium',
            'theme-quantum-nexus': 'theme_quantum_nexus_premium',
            'theme-holographic-matrix': 'theme_holographic_matrix_premium',
            'theme-stellar-genesis': 'theme_stellar_genesis_premium',
            'theme-circus-maximus': 'theme_circus_maximus_premium',
            'theme-temporal-paradox': 'theme_temporal_paradox_premium'
        };

        // Currency configuration
        const CURRENCIES = {
            'US': { code: 'USD', symbol: '$', name: 'US Dollar' },
            'GB': { code: 'GBP', symbol: '£', name: 'British Pound' },
            'EU': { code: 'EUR', symbol: '€', name: 'Euro' },
            'CA': { code: 'CAD', symbol: 'C$', name: 'Canadian Dollar' },
            'AU': { code: 'AUD', symbol: 'A$', name: 'Australian Dollar' },
            'IN': { code: 'INR', symbol: '₹', name: 'Indian Rupee' },
            'JP': { code: 'JPY', symbol: '¥', name: 'Japanese Yen' },
            'KR': { code: 'KRW', symbol: '₩', name: 'South Korean Won' },
            'BR': { code: 'BRL', symbol: 'R$', name: 'Brazilian Real' },
            'MX': { code: 'MXN', symbol: '$', name: 'Mexican Peso' },
            'NG': { code: 'NGN', symbol: '₦', name: 'Nigerian Naira' }
        };

        // Default to NGN since theme prices are set in NGN
        let userCurrency = CURRENCIES['NG'];
        let exchangeRates = { NGN: 1 };
        let isRatesLoading = false;

        // Currency detection and exchange rate management
        async function detectUserCurrency() {
            try {
                // Try to get user's country from IP
                const response = await fetch('https://ipapi.co/json/');
                const data = await response.json();
                
                if (data.country_code && CURRENCIES[data.country_code]) {
                    userCurrency = CURRENCIES[data.country_code];
                    console.log(`Currency detected: ${userCurrency.name} (${userCurrency.code})`);
                }
                
                // Store user's currency preference
                localStorage.setItem('jchat-user-currency', userCurrency.code);
                
                // Fetch exchange rates
                await fetchExchangeRates();
                
            } catch (error) {
                console.log('Currency detection failed, using USD as default:', error);
                // Fallback to stored preference or USD
                const storedCurrency = localStorage.getItem('jchat-user-currency');
                if (storedCurrency) {
                    const currencyEntry = Object.values(CURRENCIES).find(c => c.code === storedCurrency);
                    if (currencyEntry) userCurrency = currencyEntry;
                }
                
                // Still try to fetch exchange rates even if detection failed
                await fetchExchangeRates();
            }
        }

        async function fetchExchangeRates() {
            if (isRatesLoading) return;
            isRatesLoading = true;
            
            try {
                // Use a free exchange rate API (NGN base)
                const response = await fetch(`https://api.exchangerate-api.com/v4/latest/NGN`);
                const data = await response.json();
                
                if (data.rates) {
                    exchangeRates = data.rates;
                    console.log('Exchange rates updated successfully');
                    // Update theme picker prices if it's open
                    if (document.querySelector('.theme-picker')) {
                        updateThemePickerPrices();
                    }
                }
            } catch (error) {
                console.error('Failed to fetch exchange rates:', error);
                // Fallback to approximate rates (NGN base)
                exchangeRates = {
                    USD: 0.0012, EUR: 0.0011, GBP: 0.0009, CAD: 0.0016,
                    AUD: 0.0018, INR: 0.10, JPY: 0.18, KRW: 1.62,
                    BRL: 0.006, MXN: 0.020, NGN: 1
                };
            } finally {
                isRatesLoading = false;
            }
        }

        // Convert price from USD to user's currency
        function convertPrice(priceUSD, targetCurrency = userCurrency.code) {
            if (targetCurrency === 'USD') return priceUSD;
            const rate = exchangeRates[targetCurrency] || 1;
            const converted = priceUSD * rate;
            
            // Round to 2 decimal places for most currencies, 0 for JPY/KRW
            if (targetCurrency === 'JPY' || targetCurrency === 'KRW') {
                return Math.round(converted);
            }
            return Math.round(converted * 100) / 100;
        }

        // Format price in user's currency
        function formatPrice(price, currency = userCurrency) {
            if (!currency) return `$${price}`;
            
            // Special formatting for different currencies
            if (currency.code === 'JPY' || currency.code === 'KRW') {
                return `${currency.symbol}${Math.round(price)}`;
            }
            
            return `${currency.symbol}${price.toFixed(2)}`;
        }

                // Update theme picker prices with current currency
        function updateThemePickerPrices() {
            const priceElements = document.querySelectorAll('.theme-picker-btn[data-locked="true"] .price-display');
            priceElements.forEach(el => {
                const theme = el.closest('.theme-picker-btn').getAttribute('data-theme');
                const themeInfo = themeCatalog[theme];
                if (themeInfo && !themeInfo.isFree) {
                    const convertedPrice = convertPrice(themeInfo.price);
                    el.textContent = ` (${formatPrice(convertedPrice)})`;
                }
            });
        }

        // Redirect to shop with specific theme pre-selected
        function redirectToShop(themeKey) {
            const themeInfo = themeCatalog[themeKey];
            if (themeInfo) {
                const shopUrl = `Shop.html?theme=${themeKey}&name=${encodeURIComponent(themeInfo.name)}&price=${themeInfo.price}`;
                window.location.href = shopUrl;
            } else {
                // Fallback to general shop
                window.location.href = 'Shop.html';
            }
        }

        // Add currency selector to theme picker
        function addCurrencySelector() {
            const picker = document.querySelector('.theme-picker');
            if (!picker || picker.querySelector('.currency-selector')) return;
            
            const currencyDiv = document.createElement('div');
            currencyDiv.className = 'currency-selector';
            currencyDiv.innerHTML = `
                <div style="padding: 15px 20px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.08);">
                    <label style="color: rgba(255,255,255,0.9); font-size: 0.85rem; margin-bottom: 8px; display: block; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Currency</label>
                    <select id="currencySelect" style="width: 100%; padding: 10px 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; color: white; font-size: 0.9rem; font-weight: 500; transition: all 0.2s ease;">
                        ${Object.entries(CURRENCIES).map(([code, currency]) => 
                            `<option value="${currency.code}" ${currency.code === userCurrency.code ? 'selected' : ''}>
                                ${currency.symbol} ${currency.code} - ${currency.name}
                            </option>`
                        ).join('')}
                    </select>
                </div>
            `;
            
            picker.insertBefore(currencyDiv, picker.firstChild);
            
            // Handle currency change
            document.getElementById('currencySelect').addEventListener('change', (e) => {
                const newCurrencyCode = e.target.value;
                const newCurrency = Object.values(CURRENCIES).find(c => c.code === newCurrencyCode);
                if (newCurrency) {
                    userCurrency = newCurrency;
                    localStorage.setItem('jchat-user-currency', newCurrency.code);
                    updateThemePickerPrices();
                }
            });
        }

        // Initialize theme switcher
        async function initializeThemeSwitcher() {
            // Detect user currency and fetch exchange rates
            await detectUserCurrency();
            await fetchExchangeRates();
            
            // Load saved theme from localStorage
            const savedTheme = localStorage.getItem('jchat-theme') || 'theme-dark-mode';
            
            // Check if the saved theme is locked
            if (isThemeLocked(savedTheme)) {
                // If locked, fall back to a free theme
                setTheme('theme-dark-mode');
            } else {
                setTheme(savedTheme);
            }
            
            // Add event listener to theme switcher button
            themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
            if (themeSwitcherBtn) {
                themeSwitcherBtn.addEventListener('click', openThemePicker);
            }
            
            // Subscribe to real-time theme unlocks for authenticated users
            if (typeof onAuthStateChanged !== 'undefined') {
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        subscribeToThemeUnlocks(user.uid);
                    }
                });
            }
        }

        // Check if a theme is locked (requires purchase)
        function isThemeLocked(theme) {
            if (themeCatalog[theme].isFree) return false;
            const productId = themeClassToProductId[theme];
            return !purchasedThemeProductIds.has(productId);
        }

        // Set theme
        function setTheme(theme) {
            // Check if theme is locked
            if (isThemeLocked(theme)) {
                // Redirect to shop to purchase the specific theme
                redirectToShop(theme);
                return;
            }

            const body = document.body;
            
            // Remove all theme classes
            body.classList.remove('theme-light-mode', 'theme-dark-mode', 'theme-sunset-mode', 'theme-glass-mode', 'theme-ocean-mode', 'theme-forest-mode', 'theme-cosmic-mode', 'theme-retro-mode', 'theme-neon-mode', 'theme-elegant-mode', 'theme-quantum-nexus', 'theme-holographic-matrix', 'theme-stellar-genesis', 'theme-circus-maximus', 'theme-temporal-paradox');
            
            // Add the new theme class
            body.classList.add(theme);
            
            // Update current theme
            currentTheme = theme;
            
            // Save theme to localStorage
            localStorage.setItem('jchat-theme', theme);
            
            // Update theme switcher button icon
            if (themeSwitcherBtn) {
                const icon = themeSwitcherBtn.querySelector('i');
                if (icon) {
                    icon.className = themeIcons[theme] || 'fas fa-palette';
                }
            }
            
            // Show theme change notification
            const themeName = themeCatalog[theme].name;
            if (typeof showMessageBox === 'function') { 
                showMessageBox(`Theme changed to ${themeName}`, 'success'); 
            }
        }
        // Theme picker functionality
        let themePickerEl = null;

        // ===== GLOBAL ANNOUNCEMENT SYSTEM =====
        
        /**
         * Checks for and displays global announcements from admin
         */
        async function checkGlobalAnnouncements() {
            try {
                const systemSettingsDoc = await getDoc(SYSTEM_SETTINGS_DOC_REF);
                if (systemSettingsDoc.exists()) {
                    const settings = systemSettingsDoc.data();
                    if (settings.globalAnnouncement && typeof settings.globalAnnouncement === 'object') {
                        displayGlobalAnnouncement(settings.globalAnnouncement);
                    } else {
                        hideGlobalAnnouncement();
                    }
                    // People you may know
                    try { await loadAndRenderPymk(); } catch (e) { console.warn('PYMK failed:', e); }
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error checking global announcements:", error);
            }
        }

        // ===== People You May Know (Find_Friends logic) =====
        let _pymkUnsubRequests = null;
        let _pymkUnsubFriends = null;
        let _pymkFriendsSet = new Set();
        let _pymkSentRequests = new Set();
        let _pymkReceivedRequests = new Set();

        function _pymkGetFriendshipId(uid1, uid2) {
            return uid1 < uid2 ? `${uid1}_${uid2}` : `${uid2}_${uid1}`;
        }

        async function _pymkSendFriendRequest(targetUserId, buttonEl) {
            if (!currentUser) return;
            try {
                if (buttonEl) { buttonEl.disabled = true; }
                const publicFriendRequestsRef = collection(db, "artifacts", appId, "public", "data", "friend_requests");
                const newRequestDocRef = doc(publicFriendRequestsRef);
                await setDoc(newRequestDocRef, {
                    senderId: currentUser.uid,
                    receiverId: targetUserId,
                    status: 'pending',
                    timestamp: serverTimestamp()
                });
                if (buttonEl) { buttonEl.textContent = 'Requested'; }
                if (typeof showMessageBox === 'function') showMessageBox('Friend request sent!', 'success');
            } catch (e) {
                console.error('PYMK send request failed', e);
                if (buttonEl) { buttonEl.disabled = false; }
                if (typeof showMessageBox === 'function') showMessageBox(`Failed to send request: ${e.message}`, 'error');
            }
        }

        async function _pymkCancelFriendRequest(targetUserId, buttonEl) {
            if (!currentUser) return;
            try {
                if (buttonEl) { buttonEl.disabled = true; }
                const publicFriendRequestsRef = collection(db, "artifacts", appId, "public", "data", "friend_requests");
                const qReq = query(publicFriendRequestsRef,
                    where("senderId", "==", currentUser.uid),
                    where("receiverId", "==", targetUserId),
                    where("status", "==", "pending")
                );
                const snap = await getDocs(qReq);
                if (!snap.empty) {
                    const id = snap.docs[0].id;
                    await deleteDoc(doc(db, "artifacts", appId, "public", "data", "friend_requests", id));
                }
                if (typeof showMessageBox === 'function') showMessageBox('Request cancelled', 'info');
            } catch (e) {
                console.error('PYMK cancel request failed', e);
                if (typeof showMessageBox === 'function') showMessageBox(`Failed to cancel request: ${e.message}`, 'error');
            } finally {
                if (buttonEl) { buttonEl.disabled = false; }
            }
        }

        async function _pymkAcceptFriendRequest(senderId, buttonEl) {
            if (!currentUser) return;
            try {
                if (buttonEl) { buttonEl.disabled = true; }
                const publicFriendRequestsRef = collection(db, "artifacts", appId, "public", "data", "friend_requests");
                const qReq = query(publicFriendRequestsRef,
                    where("senderId", "==", senderId),
                    where("receiverId", "==", currentUser.uid),
                    where("status", "==", "pending")
                );
                const snap = await getDocs(qReq);
                if (snap.empty) return;
                const reqDoc = snap.docs[0];
                await updateDoc(reqDoc.ref, { status: 'accepted', updatedAt: serverTimestamp() });
                const friendshipId = _pymkGetFriendshipId(currentUser.uid, senderId);
                await setDoc(doc(db, "artifacts", appId, "public", "data", "friends", friendshipId), {
                    user1Id: currentUser.uid < senderId ? currentUser.uid : senderId,
                    user2Id: currentUser.uid < senderId ? senderId : currentUser.uid,
                    addedAt: serverTimestamp()
                });
                if (typeof showMessageBox === 'function') showMessageBox('Friend request accepted!', 'success');
            } catch (e) {
                console.error('PYMK accept failed', e);
                if (typeof showMessageBox === 'function') showMessageBox(`Failed to accept: ${e.message}`, 'error');
            } finally {
                if (buttonEl) { buttonEl.disabled = false; }
            }
        }

        async function _pymkRejectFriendRequest(senderId, buttonEl) {
            if (!currentUser) return;
            try {
                if (buttonEl) { buttonEl.disabled = true; }
                const publicFriendRequestsRef = collection(db, "artifacts", appId, "public", "data", "friend_requests");
                const qReq = query(publicFriendRequestsRef,
                    where("senderId", "==", senderId),
                    where("receiverId", "==", currentUser.uid),
                    where("status", "==", "pending")
                );
                const snap = await getDocs(qReq);
                if (!snap.empty) {
                    await deleteDoc(doc(db, "artifacts", appId, "public", "data", "friend_requests", snap.docs[0].id));
                    if (typeof showMessageBox === 'function') showMessageBox('Friend request rejected', 'info');
                }
            } catch (e) {
                console.error('PYMK reject failed', e);
                if (typeof showMessageBox === 'function') showMessageBox(`Failed to reject: ${e.message}`, 'error');
            } finally {
                if (buttonEl) { buttonEl.disabled = false; }
            }
        }

        function _pymkRenderCards(candidatesArr) {
            const scroller = document.getElementById('pymkScroller');
            if (!scroller) return;
            scroller.innerHTML = '';
            candidatesArr.forEach(p => {
                const card = document.createElement('div');
                card.style.display = 'flex';
                card.style.flexDirection = 'column';
                card.style.alignItems = 'center';
                card.style.gap = '6px';
                card.style.minWidth = '120px';

                const img = document.createElement('img');
                const url = getCloudinaryImageUrl(p.profilePicId, 'w_70,h_70,c_fill,g_face,r_max') || `https://placehold.co/70x70/00d5ff/ffffff?text=${p.displayName.charAt(0).toUpperCase()}`;
                img.src = url;
                img.style.width = '70px';
                img.style.height = '70px';
                img.style.borderRadius = '50%';
                img.style.objectFit = 'cover';
                img.style.border = '2px solid var(--border-color)';

                const name = document.createElement('div');
                name.textContent = p.displayName;
                name.style.fontSize = '12px';
                name.style.maxWidth = '110px';
                name.style.color = 'var(--white)';
                name.style.whiteSpace = 'nowrap';
                name.style.overflow = 'hidden';
                name.style.textOverflow = 'ellipsis';

                const badge = document.createElement('div');
                badge.textContent = `${p.mutuals} mutual` + (p.mutuals === 1 ? '' : 's');
                badge.style.fontSize = '11px';
                badge.style.color = 'var(--text-light)';

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.gap = '6px';

                const isFriend = _pymkFriendsSet.has(p.id);
                const hasSent = _pymkSentRequests.has(p.id);
                const hasReceived = _pymkReceivedRequests.has(p.id);

                if (isFriend) {
                    const chatBtn = document.createElement('button');
                    chatBtn.className = 'icon-btn';
                    chatBtn.textContent = 'Chat';
                    chatBtn.addEventListener('click', () => {
                        window.location.href = `/chat.html?partnerId=${p.id}`;
                    });
                    actions.appendChild(chatBtn);
                } else if (hasSent) {
                    const sentBtn = document.createElement('button');
                    sentBtn.className = 'icon-btn';
                    sentBtn.textContent = 'Requested';
                    sentBtn.disabled = true;
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'icon-btn';
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.addEventListener('click', () => _pymkCancelFriendRequest(p.id, cancelBtn));
                    actions.appendChild(sentBtn);
                    actions.appendChild(cancelBtn);
                } else if (hasReceived) {
                    const acceptBtn = document.createElement('button');
                    acceptBtn.className = 'icon-btn';
                    acceptBtn.textContent = 'Accept';
                    acceptBtn.addEventListener('click', () => _pymkAcceptFriendRequest(p.id, acceptBtn));
                    const rejectBtn = document.createElement('button');
                    rejectBtn.className = 'icon-btn';
                    rejectBtn.textContent = 'Reject';
                    rejectBtn.addEventListener('click', () => _pymkRejectFriendRequest(p.id, rejectBtn));
                    actions.appendChild(acceptBtn);
                    actions.appendChild(rejectBtn);
                } else {
                    const addBtn = document.createElement('button');
                    addBtn.className = 'icon-btn';
                    addBtn.textContent = 'Add friend';
                    addBtn.addEventListener('click', () => _pymkSendFriendRequest(p.id, addBtn));
                    actions.appendChild(addBtn);
                }

                card.appendChild(img);
                card.appendChild(name);
                card.appendChild(badge);
                card.appendChild(actions);
                scroller.appendChild(card);
            });
        }

        async function loadAndRenderPymk() {
            const wrap = document.getElementById('peopleMayKnow');
            const scroller = document.getElementById('pymkScroller');
            if (!wrap || !scroller || !currentUser) return;
            wrap.style.display = 'block';

            // Listen to friend requests and friends like Find_Friends.html
            if (_pymkUnsubRequests) _pymkUnsubRequests();
            if (_pymkUnsubFriends) _pymkUnsubFriends();

            const publicFriendRequestsRef = collection(db, 'artifacts', appId, 'public', 'data', 'friend_requests');
            _pymkUnsubRequests = onSnapshot(publicFriendRequestsRef, (snapshot) => {
                _pymkSentRequests.clear();
                _pymkReceivedRequests.clear();
                snapshot.forEach(docSnap => {
                    const r = docSnap.data();
                    if (r.status === 'pending') {
                        if (r.senderId === currentUser.uid) _pymkSentRequests.add(r.receiverId);
                        else if (r.receiverId === currentUser.uid) _pymkReceivedRequests.add(r.senderId);
                    }
                });
            });

            const publicFriendsRef = collection(db, 'artifacts', appId, 'public', 'data', 'friends');
            const friendships = [];
            _pymkUnsubFriends = onSnapshot(publicFriendsRef, async (snapshot) => {
                _pymkFriendsSet.clear();
                const myFriends = new Set();
                friendships.length = 0;
                snapshot.forEach(docSnap => {
                    const f = docSnap.data();
                    friendships.push(f);
                    if (f.user1Id === currentUser.uid) myFriends.add(f.user2Id);
                    else if (f.user2Id === currentUser.uid) myFriends.add(f.user1Id);
                });
                // Compute candidates and mutuals
                const candidateToMutuals = new Map();
                friendships.forEach(f => {
                    const a = f.user1Id, b = f.user2Id;
                    if (myFriends.has(a) && b !== currentUser.uid && !myFriends.has(b)) {
                        candidateToMutuals.set(b, (candidateToMutuals.get(b) || 0) + 1);
                    }
                    if (myFriends.has(b) && a !== currentUser.uid && !myFriends.has(a)) {
                        candidateToMutuals.set(a, (candidateToMutuals.get(a) || 0) + 1);
                    }
                });
                myFriends.forEach(uid => _pymkFriendsSet.add(uid));

                // Build profile list
                const entries = Array.from(candidateToMutuals.entries()).slice(0, 40);
                const profiles = await Promise.all(entries.map(async ([uid, mutuals]) => {
                    const pRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', uid);
                    const pSnap = await getDoc(pRef);
                    if (!pSnap.exists()) return null;
                    const p = pSnap.data();
                    return { id: uid, displayName: p.displayName || p.username || 'User', username: p.username || 'user', profilePicId: p.profilePicId || null, mutuals };
                }));
                const filtered = profiles.filter(Boolean).sort((a, b) => b.mutuals - a.mutuals).slice(0, 20);
                _pymkRenderCards(filtered);
            });

            document.getElementById('refreshPymkBtn')?.addEventListener('click', () => loadAndRenderPymk());
        }

        /**
         * Displays a global announcement to the user
         */
        function displayGlobalAnnouncement(announcementData) {
            const announcementsSection = document.getElementById('globalAnnouncementsSection');
            const announcementTypeBadge = document.getElementById('announcementTypeBadge');
            const announcementPriorityBadge = document.getElementById('announcementPriorityBadge');
            const announcementMessage = document.getElementById('announcementMessage');
            const announcementTimestamp = document.getElementById('announcementTimestamp');

            if (announcementsSection && announcementData) {
                // Set announcement type
                if (announcementTypeBadge) {
                    announcementTypeBadge.textContent = getAnnouncementTypeLabel(announcementData.type);
                }

                // Set announcement priority
                if (announcementPriorityBadge) {
                    announcementPriorityBadge.textContent = getAnnouncementPriorityLabel(announcementData.priority);
                    announcementPriorityBadge.setAttribute('data-priority', announcementData.priority);
                }

                // Set announcement message
                if (announcementMessage) {
                    announcementMessage.textContent = announcementData.message;
                }

                // Set timestamp
                if (announcementTimestamp) {
                    const timestamp = announcementData.publishedAt?.toDate?.() || new Date();
                    announcementTimestamp.textContent = `Published: ${timestamp.toLocaleString()}`;
                }

                // Show the announcement section
                announcementsSection.style.display = 'block';
                
                // Store announcement in localStorage to remember dismissal
                localStorage.setItem('jchat-last-announcement', JSON.stringify({
                    id: announcementData.publishedAt?.toMillis?.() || Date.now(),
                    dismissed: false
                }));
            }
        }

        /**
         * Hides the global announcement section
         */
        function hideGlobalAnnouncement() {
            const announcementsSection = document.getElementById('globalAnnouncementsSection');
            if (announcementsSection) {
                announcementsSection.style.display = 'none';
            }
        }

        /**
         * Dismisses the current global announcement
         */
        function dismissGlobalAnnouncement() {
            const announcementsSection = document.getElementById('globalAnnouncementsSection');
            if (announcementsSection) {
                announcementsSection.style.display = 'none';
                
                // Mark as dismissed in localStorage
                const lastAnnouncement = localStorage.getItem('jchat-last-announcement');
                if (lastAnnouncement) {
                    try {
                        const announcementData = JSON.parse(lastAnnouncement);
                        announcementData.dismissed = true;
                        localStorage.setItem('jchat-last-announcement', JSON.stringify(announcementData));
                    } catch (error) {
                        console.error("JCHAT_ERROR: Error updating announcement dismissal:", error);
                    }
                }
            }
        }

        /**
         * Gets the display label for announcement type
         */
        function getAnnouncementTypeLabel(type) {
            const typeLabels = {
                'info': 'ℹ️ Information',
                'warning': '⚠️ Warning',
                'success': '✅ Success',
                'maintenance': '🔧 Maintenance',
                'update': '🆕 Update'
            };
            return typeLabels[type] || 'ℹ️ Information';
        }

        /**
         * Gets the display label for announcement priority
         */
        function getAnnouncementPriorityLabel(priority) {
            const priorityLabels = {
                'low': '🟢 Low',
                'medium': '🟡 Medium',
                'high': '🔴 High',
                'urgent': '🚨 Urgent'
            };
            return priorityLabels[priority] || '🟡 Medium';
        }

        // Ensure theme picker element exists
        function ensureThemePicker() {
            if (themePickerEl) return themePickerEl;
            
            themePickerEl = document.createElement('div');
            themePickerEl.id = 'themePicker';
            themePickerEl.className = 'theme-picker';
            themePickerEl.style.cssText = `
                position: fixed;
                background: var(--card-background);
                border: 1px solid var(--border-light);
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                min-width: 250px;
                max-height: 400px;
                overflow-y: auto;
                backdrop-filter: blur(10px);
                animation: fadeIn 0.2s ease;
                display: none;
            `;
            
            document.body.appendChild(themePickerEl);
            return themePickerEl;
        }
        // Theme icons mapping
        const themeIcons = {
            'theme-light-mode': 'fas fa-sun',
            'theme-dark-mode': 'fas fa-moon',
            'theme-glass-mode': 'fas fa-gem',
            'theme-sunset-mode': 'fas fa-mountain',
            'theme-ocean-mode': 'fas fa-water',
            'theme-forest-mode': 'fas fa-tree',
            'theme-cosmic-mode': 'fas fa-star',
            'theme-retro-mode': 'fas fa-tv',
            'theme-neon-mode': 'fas fa-bolt',
            'theme-elegant-mode': 'fas fa-crown',
            'theme-quantum-nexus': 'fas fa-atom',
            'theme-holographic-matrix': 'fas fa-cube',
            'theme-stellar-genesis': 'fas fa-rocket',
            'theme-circus-maximus': 'fas fa-theater-masks',
            'theme-temporal-paradox': 'fas fa-clock'
        };

        // Build theme picker list
        function buildThemePickerList() {
            const picker = ensureThemePicker();
            picker.innerHTML = '';
            
            // Add professional title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'theme-picker-title';
            titleDiv.innerHTML = `
                <div style="text-align: center; padding: 20px 20px 15px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="margin: 0; font-size: 1.4rem; font-weight: 700; color: var(--white); font-family: 'Poppins', sans-serif;">
                        🎨 Premium Themes
                    </h3>
                    <p style="margin: 8px 0 0 0; font-size: 0.9rem; color: rgba(255,255,255,0.7); font-weight: 400;">
                        Choose your perfect theme experience
                    </p>
                </div>
            `;
            picker.appendChild(titleDiv);
            
            // Add currency selector below title
            addCurrencySelector();
            
            themeSwitcherThemes.forEach(theme => {
                const themeInfo = themeCatalog[theme];
                const isLocked = isThemeLocked(theme);
                const isCurrent = currentTheme === theme;
                const isOwned = !isLocked;
                const icon = themeIcons[theme] || 'fas fa-palette';
                
                const button = document.createElement('button');
                button.className = 'theme-picker-btn';
                button.setAttribute('data-theme', theme);
                button.setAttribute('data-locked', isLocked);
                
                let statusText = '';
                if (isCurrent) statusText = ' (Current)';
                else if (isOwned) statusText = ' (Owned)';
                else {
                    const convertedPrice = convertPrice(themeInfo.price);
                    statusText = ` (${formatPrice(convertedPrice)})`;
                }
                
                button.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><i class="${icon}"></i> ${themeInfo.name}${statusText}</span>
                        ${isLocked ? '<i class="fas fa-lock" style="color: #ff6b6b;"></i>' : ''}
                    </div>
                `;
                
                button.addEventListener('click', () => {
                    if (isLocked) {
                        redirectToShop(theme);
                        closeThemePicker();
                    } else {
                        setTheme(theme);
                        closeThemePicker();
                    }
                });
                
                picker.appendChild(button);
            });
        }

        // Open theme picker
        function openThemePicker() {
            const picker = ensureThemePicker();
            buildThemePickerList();
            
            // Center the picker on screen
            const pickerWidth = 300; // Fixed width for consistent centering
            const pickerHeight = 500; // Approximate height
            
            const top = Math.max(20, (window.innerHeight - pickerHeight) / 2);
            const left = Math.max(20, (window.innerWidth - pickerWidth) / 2);
            
            picker.style.top = `${top}px`;
            picker.style.left = `${left}px`;
            picker.style.display = 'block';
            
            // Close picker when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeThemePickerOnOutsideClick);
            }, 100);
        }

        // Close theme picker
        function closeThemePicker() {
            if (themePickerEl) {
                themePickerEl.style.display = 'none';
            }
            document.removeEventListener('click', closeThemePickerOnOutsideClick);
        }

        // Close theme picker when clicking outside
        function closeThemePickerOnOutsideClick(event) {
            if (themePickerEl && !themePickerEl.contains(event.target) && event.target !== document.getElementById('themeSwitcherBtn')) {
                closeThemePicker();
            }
        }

        // Subscribe to theme entitlements from Firebase
        function subscribeThemeEntitlements(userId) {
            if (!userId) return;
            
            const userDocRef = doc(db, 'users', userId);
            
            return onSnapshot(userDocRef, (doc) => {
                if (doc.exists()) {
                    const userData = doc.data();
                    if (userData.purchasedProducts) {
                        purchasedThemeProductIds = new Set(
                            userData.purchasedProducts
                                .filter(productId => productIdToThemeClass[productId])
                        );
                    }
                    if (userData.pendingProducts) {
                        pendingThemeProductIds = new Set(
                            userData.pendingProducts
                                .filter(productId => productIdToThemeClass[productId])
                        );
                    }
                }
            });
        }

        // Subscribe to real-time theme unlocks from new system
        function subscribeToThemeUnlocks(userId) {
            if (!userId) return;
            
            // Check if Firebase is available
            if (typeof db === 'undefined' || typeof appId === 'undefined') {
                console.log('Firebase not available for theme unlocks');
                return;
            }
            
            const userEntitlementsRef = doc(db, 'artifacts', appId, 'users', userId, 'profiles', 'user_entitlements');
            
            return onSnapshot(userEntitlementsRef, (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    
                    // Check if any new themes were unlocked
                    if (data.themes && Array.isArray(data.themes)) {
                        data.themes.forEach(themeKey => {
                            if (themeCatalog[themeKey]) {
                                // Theme is now unlocked - add to purchased set
                                const productId = themeClassToProductId[themeKey];
                                if (productId) {
                                    purchasedThemeProductIds.add(productId);
                                }
                            }
                        });
                        
                        // Refresh theme picker if open
                        if (document.querySelector('.theme-picker')) {
                            buildThemePickerList();
                        }
                        
                        // One-time and incremental unlock notifications per user (persisted per user)
                        const premiumThemeKeys = Object.keys(themeCatalog).filter(k => !themeCatalog[k].isFree);
                        const userKeyPrefix = `jchat_theme_unlocks_${userId}`;
                        const countKey = `${userKeyPrefix}_count`;
                        const ackKey = `${userKeyPrefix}_all_ack`;
                        const prevCount = parseInt(localStorage.getItem(countKey) || '0', 10);
                        const currentUnlocked = (Array.isArray(data.themes) ? data.themes : []).filter(k => themeCatalog[k] && !themeCatalog[k].isFree);
                        const currentCount = currentUnlocked.length;
                        const ackShown = !!data.ackAllThemesShown;

                        if (!ackShown) {
                            if (currentCount === premiumThemeKeys.length) {
                                showMessageBox('🎉 All premium themes unlocked!', 'success');
                                localStorage.setItem(ackKey, 'true');
                                localStorage.setItem(countKey, String(currentCount));
                                try {
                                    updateDoc(userEntitlementsRef, { ackAllThemesShown: true, ackAllThemesShownAt: serverTimestamp() }).catch(() => {});
                                } catch (_) {}
                            } else if (currentCount > prevCount) {
                                const delta = currentCount - prevCount;
                                showMessageBox(`🎉 ${delta} premium theme(s) unlocked!`, 'success');
                                localStorage.setItem(countKey, String(currentCount));
                            }
                        } else {
                            if (localStorage.getItem(ackKey) !== 'true') localStorage.setItem(ackKey, 'true');
                            if (prevCount !== currentCount) localStorage.setItem(countKey, String(currentCount));
                        }
                    }
                }
            });
        }

        // Function to initialize all DOM elements safely
        function initializeDOMElements() {
            try {
                // Header elements
                themeSwitcherBtn = document.getElementById('themeSwitcherBtn');
                headerProfilePic = document.getElementById('headerProfilePic');
                headerAvatarIcon = document.getElementById('headerAvatarIcon');
                headerDisplayName = document.getElementById('headerDisplayName');
                // home chips & strips
                window.homeChipsRow = document.getElementById('homeChipsRow');
                window.levelChipIcon = document.getElementById('levelChipIcon');
                window.levelChipName = document.getElementById('levelChipName');
                window.levelChipPercent = document.getElementById('levelChipPercent');
                window.levelChipProgressFill = document.getElementById('levelChipProgressFill');
                window.walletChipLink = document.getElementById('walletChipLink');
                window.walletChipAmount = document.getElementById('walletChipAmount');
                window.jcoinRateSpan = document.getElementById('jcoinRate');
                window.highlightsSection = document.getElementById('highlightsSection');
                window.highlightsStrip = document.getElementById('highlightsStrip');

                window.savedWidgetSection = document.getElementById('savedWidgetSection');
                window.savedWidget = document.getElementById('savedWidget');
                notificationCountElement = document.getElementById('notificationCount');
                adminIconLink = document.getElementById('adminIconLink');
                profileLink = document.getElementById('profileLink');

                // Daily Inspiration section elements
                inspirationQuoteElement = document.getElementById('inspirationQuote');
                inspirationAuthorElement = document.getElementById('inspirationAuthor');
                sharePostInspirationButton = document.getElementById('sharePostInspirationButton');
                customizeInspirationButton = document.getElementById('customizeInspirationButton');
                claimDailyBonusButton = document.getElementById('claimDailyBonusButton');
                if (enableFixedInspirationOverride && customizeInspirationButton) {
                    customizeInspirationButton.disabled = true;
                    customizeInspirationButton.setAttribute('title', 'Inspiration is locked by admin.');
                }

                // Customize Inspiration Modal elements
                customizeInspirationModal = document.getElementById('customizeInspirationModal');
                inspirationTypeRadios = document.querySelectorAll('input[name="inspirationType"]');
                cancelCustomizeButton = document.getElementById('cancelCustomize');
                saveCustomizeButton = document.getElementById('saveCustomize');

                // Post Creation section elements
                postCreationSection = document.getElementById('postCreationSection');
                postContentInput = document.getElementById('postContent');
                postMediaUpload = document.getElementById('postMediaUpload');
                mediaImagePreview = document.getElementById('mediaImagePreview');
                mediaVideoPreview = document.getElementById('mediaVideoPreview');
                createPostButton = document.getElementById('createPostButton');
                postsFeed = document.getElementById('postsFeed');
                loadingPostsMessage = document.getElementById('loadingPostsMessage');
                postTypeFilter = document.getElementById('postTypeFilter');
                postSearchInput = document.getElementById('postSearchInput');
                postDateFromInput = document.getElementById('postDateFrom');
                postDateToInput = document.getElementById('postDateTo');
                showFollowedOnlyCheckbox = document.getElementById('filterFollowedOnly');
                exportPostsCsvButton = document.getElementById('exportPostsCsvButton');
                exportPostsJsonButton = document.getElementById('exportPostsJsonButton');
                showSavedOnlyCheckbox = document.getElementById('showSavedOnly');
                trendingHashtagsDiv = document.getElementById('trendingHashtags');

                // Edit Post Modal elements
                editPostModal = document.getElementById('editPostModal');
                editPostContentInput = document.getElementById('editPostContent');
                editPostMediaUpload = document.getElementById('editPostMediaUpload');
                editMediaImagePreview = document.getElementById('editMediaImagePreview');
                editMediaVideoPreview = document.getElementById('editMediaVideoPreview');
                removeEditMediaButton = document.getElementById('removeEditMedia');
                cancelEditPostButton = document.getElementById('cancelEditPost');
                saveEditedPostButton = document.getElementById('saveEditedPost');

                // Additional elements
                confirmationModal = document.getElementById('confirmationModal');
                confirmationTitle = document.getElementById('confirmationTitle');
                confirmationMessage = document.getElementById('confirmationMessage');
                confirmCancelButton = document.getElementById('confirmCancelButton');
                confirmProceedButton = document.getElementById('confirmProceedButton');
                messageBox = document.getElementById('messageBox');
                sidebarNav = document.getElementById('sidebarNav');
                sidebarToggleFab = document.getElementById('sidebarToggleFab');
                sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
                sidebarNavItems = document.querySelectorAll('.sidebar-nav-item');
                sidebarLogoutLink = document.getElementById('sidebarLogoutLink');
                chatLink = document.getElementById('chatLink');
                findFriendsLink = document.getElementById('findFriendsLink');
                friendsLink = document.getElementById('friendsLink');
                groupsLink = document.getElementById('groupsLink');
                jcoinShopLink = document.getElementById('jcoinShopLink');
                maintenanceOverlay = document.getElementById('maintenanceOverlay');
                maintenanceAnnouncementText = document.getElementById('maintenanceAnnouncementText');
                callOverlay = document.getElementById('callOverlay');
                callStatusIcon = document.getElementById('callStatusIcon');
                callStatusText = document.getElementById('callStatusText');
                callTimerDisplay = document.getElementById('callTimer');
                callActions = document.getElementById('callActions');
                acceptCallBtn = document.getElementById('acceptCallBtn');
                declineCallBtn = document.getElementById('declineCallBtn');
                endCallBtn = document.getElementById('endCallBtn');
                localVideo = document.getElementById('localVideo');
                remoteVideo = document.getElementById('remoteVideo');
                toggleMuteBtn = document.getElementById('toggleMuteBtn');
                toggleVideoBtn = document.getElementById('toggleVideoBtn');

                console.log('JCHAT_DEBUG: DOM elements initialized successfully');
            } catch (error) {
                console.error('JCHAT_ERROR: Error initializing DOM elements:', error);
            }
        }

        // Additional DOM elements - will be initialized in initializeDOMElements
        let confirmationModal, confirmationTitle, confirmationMessage;
        let confirmCancelButton, confirmProceedButton, messageBox;

        // All DOM elements - will be initialized in initializeDOMElements  
        let sidebarNav, sidebarToggleFab, sidebarCloseBtn, sidebarNavItems, sidebarLogoutLink;
        let chatLink, findFriendsLink, friendsLink, groupsLink, jcoinShopLink;
        let maintenanceOverlay, maintenanceAnnouncementText, callOverlay, callStatusIcon;
        let callStatusText, callTimerDisplay, callActions, acceptCallBtn, declineCallBtn;
        let endCallBtn, localVideo, remoteVideo, toggleMuteBtn, toggleVideoBtn;

        // --- Global State Variables ---
        let currentUser = null; // Stores the Firebase authenticated user object.
        let currentUserProfileData = null; // Stores the authenticated user's own profile data from Firestore.
        let inspirationIntervalId = null; // Interval ID for refreshing daily inspiration.
        let dailyBonusCountdownInterval = null; // Interval for daily bonus cooldown countdown.
        let currentMediaFile = null; // Stores the file object for new post media.
        let currentEditPostId = null; // Stores the ID of the post being edited.
        let currentEditMediaFile = null; // Stores the new file object for edited post media.
        let currentEditMediaUrl = null; // Stores the existing media URL for edited post.
        let currentEditMediaType = null; // Stores the existing media type for edited post.
        let isAuthReady = false; // Flag indicating if Firebase authentication state has been determined.
        let unsubscribeListeners = []; // Array to store all onSnapshot unsubscribe functions for cleanup.
        let currentSystemSettings = {}; // Stores global system settings fetched from Firestore.

        // --- Notification Badge Management ---
        function updateNotificationBadge(count) {
            const notificationWrapper = document.querySelector('.notification-icon-wrapper');
            const badge = document.getElementById('notificationCount');
            
            if (badge && notificationWrapper) {
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.style.display = 'flex';
                    notificationWrapper.classList.add('has-notifications');
                    console.log("JCHAT_DEBUG: Notification bell is now shaking with", count, "unread notifications");
                } else {
                    badge.style.display = 'none';
                    notificationWrapper.classList.remove('has-notifications');
                    console.log("JCHAT_DEBUG: Notification bell stopped shaking - no unread notifications");
                }
            }
        }

        // WebRTC Call State Variables
        let localStream; // Local media stream (audio/video).
        let remoteStream; // Remote media stream from the other peer.
        let peerConnection; // RTCPeerConnection object.
        let currentCallType; // 'voice' or 'video'.
        let isMuted = false; // Mute state for local audio.
        let isVideoOff = false; // Video off state for local video.
        let callState = 'idle'; // Current call state: 'idle', 'calling', 'ringing', 'connected', 'busy', 'declined', 'ended', 'no-answer'.
        let callDuration = 0; // Duration of the current call in seconds.
        let callDurationInterval; // Interval ID for updating call timer.
        let callTimeoutId; // Timeout ID for incoming call no-answer.
        let callRef; // Firestore document reference for the current call.
        let isIncomingCall = false; // Flag to differentiate initiator from receiver.
        let recipientUserProfileData = null; // To store caller's profile for display in incoming calls.

        // --- Theme Management Variables ---
        const themes = [
            'theme-light-mode',
            'theme-dark-mode',
            'theme-glass-mode',
            'theme-sunset-mode'
        ];

        // --- Inspiration Quotes Data (Local Fallback) ---
        // These are used as the primary source of inspiration quotes.
        const enableFixedInspirationOverride = false;
const fixedInspirationQuote = 'Breathe: peace finds its way in.';
const fixedInspirationAuthor = 'JCHAT';
const pick = arr => arr[Math.floor(Math.random() * arr.length)];
        const quoteTemplates = {
            motivational: { openers:["Keep going","Start small","Believe in yourself","Stay consistent","Trust the process"], bridges:["—"," because ",": ",", and ","; "], endings:["every step counts.","tomorrow thanks you for today's effort.","progress loves momentum.","you're closer than you think.","discipline builds destiny."] },
            peaceful: { openers:["Breathe","Slow down","Be gentle","Find quiet","Let go"], bridges:["—"," and ",", then "," as ",": "], endings:["clarity will meet you.","peace finds its way in.","the heart softens.","the mind untangles.","you return to yourself."] },
            funny: { openers:["Reminder","Breaking news","Pro tip","True story","PSA"], bridges:[": "," — "," �� ",": "], endings:["motivation will arrive after snacks.","I'm on a seafood diet—I see food and I code.","sleep is a patch we never apply.","tomorrow is just today with a wig.","coffee is my personality driver."] },
            wisdom: { openers:["Growth","Curiosity","Patience","Listening","Kindness"], bridges:[" reveals that "," teaches that "," reminds us "," shows that ",": "], endings:["there's more to learn than to prove.","small habits shape great outcomes.","the quietest lessons echo the longest.","consistency outlives talent.","clarity follows attention."] },
            love: { openers:["Love","Compassion","Care","Gratitude","Warmth"], bridges:[" grows where "," lives when "," begins when "," multiplies when ",": "], endings:["we show up for each other.","we choose patience.","we listen before we speak.","small gestures carry big meaning.","we forgive and rebuild."] }
        };
        // Large-scale combinatorial lexicon per category to yield millions of unique quotes without storing them all.
const inspirationLexicon = {
    motivational: {
        adjectives: ["small","steady","bold","patient","focused","consistent","resilient","brave","curious","determined","calm","disciplined","creative","mindful","grateful","hopeful","humble","persistent","energetic","adaptive"],
        nouns: ["steps","habits","efforts","actions","choices","dreams","goals","routines","ideas","projects","focus","practice","progress","patience","courage","attention","learning","craft","path","journey"],
        verbs: ["build","create","shape","fuel","move","grow","become","unlock","guide","strengthen","elevate","refine","transform","anchor","sharpen","accelerate","steady","expand","align","carry"],
        objects: ["tomorrow","results","momentum","character","mastery","clarity","direction","outcomes","resilience","opportunities","potential","growth","impact","progress","confidence","purpose","vision","skills","habits","change"],
        adverbs: ["today","each day","with heart","with care","with courage","with patience","with focus","with intent","with kindness","with discipline","with curiosity","with energy","bit by bit","step by step","all the way","steadily","with grace","through effort","through practice","over time"],
        closers: ["every step counts","start now","progress loves momentum","consistency compounds","small moves build great things","discipline builds destiny","you are closer than you think","make the day proud","begin where you are","keep going","show up and the path appears","practice makes possible","direction beats speed","the work works","tiny wins stack up","persistence rewrites outcomes","be a little braver","craft over chaos","you've got this","let effort lead"]
    },
    peaceful: {
        adjectives: ["slow","gentle","quiet","soft","steady","deep","warm","tender","calm","open","kind","patient","light","spacious","grounded","present","relaxed","centered","clear","soothing"],
        nouns: ["breath","moments","pauses","mornings","evenings","thoughts","heart","mind","awareness","space","silence","attention","presence","steps","routines","rituals","focus","stillness","gratitude","posture"],
        verbs: ["welcomes","softens","unclutters","clears","settles","restores","eases","untangles","nourishes","steadies","centers","refreshes","calms","opens","quiets","loosens","brightens","grounds","slows","aligns"],
        objects: ["the mind","the heart","the day","the noise","the tension","the pace","the storm","the worries","the doubts","the rush","the room","the body","the breath","the chatter","the wall within","the fatigue","the weight","the clutter","the loop","the fog"],
        adverbs: ["gently","slowly","with ease","with warmth","with patience","with kindness","like a tide","like sunrise","like a whisper","like rain","without force","in silence","in stillness","in small ways","one breath at a time","with grace","softly","kindly","quietly","steadily"],
        closers: ["peace finds its way in","you return to yourself","clarity appears","softness wins","stillness speaks","you can hear the day again","calm grows from inside","the heart loosens","lightness returns","presence holds you","you are safe here","the moment holds everything","exhale, and begin again","choose gentle over perfect","be here now","ease is allowed","rest is productive","quiet is wisdom","soft is strong","let today be lighter"]
    },
    funny: {
        adjectives: ["legendary","sleepy","spicy","chaotic","accidental","unverified","snack-powered","overcaffeinated","wifi-dependent","bug-friendly","pixel-perfect-ish","keyboard-slammed","tab-hoarding","meme-certified","semi-functional","confetti-ready","deadline-adjacent","lazy","heroic","introverted"],
        nouns: ["braincells","ideas","deadlines","snacks","tabs","meetings","excuses","dreams","dishes","emails","patches","updates","alarms","calendars","todos","shortcuts","memes","eyebags","pixels","coffee"],
        verbs: ["chase","debug","ignore","refactor","procrastinate on","speedrun","overthink","optimize","ship","yeet","delay","pretend to schedule","misplace","google","reboot","stretch","nuke","silence","summon","overclock"],
        objects: ["motivation","laundry","life choices","bugs","feelings","meetings","responsibilities","plots","sleep","notifications","typos","leftovers","gym plans","tasks","calories","adulting","mess","tabs","spreadsheets","confidence"],
        adverbs: ["after snacks","tomorrow","eventually","with dramatic music","with zero context","like a ninja","like a potato","on airplane mode","with Wi‑Fi permission","under supervision","with flair","in slippers","with caution","with vibes","at 2 AM","with jazz hands","probably","respectfully","unnecessarily","on hard mode"],
        closers: ["results may vary","send help","at least we tried","nap first","snacks required","chaos contained","ship it anyway","we ball","schedule feelings later","coffee approves","per my last vibe","embrace the scuff","done is fun","pixels forgive us","oops but confident","remember to hydrate","retry after snacks","mission: acceptable","laugh and proceed","still counts"]
    },
    wisdom: {
        adjectives: ["patient","curious","humble","present","attentive","open","honest","steady","thoughtful","deliberate","observant","kind","balanced","reflective","brave","generous","playful","resilient","disciplined","simple"],
        nouns: ["mind","learner","question","path","habit","choice","craft","process","story","lens","practice","attention","journey","silence","doubt","failure","lesson","data","pattern","principle"],
        verbs: ["reveals","teaches","reminds","shapes","tests","guides","clarifies","simplifies","widens","focuses","grounds","strengthens","questions","balances","compounds","connects","aligns","lights","organizes","transforms"],
        objects: ["character","understanding","patience","outcomes","direction","humility","action","clarity","perspective","confidence","purpose","effort","progress","skill","attention","intention","learning","choices","focus","time"],
        adverbs: ["slowly","through practice","by listening","by observing","over seasons","under pressure","when tested","with others","in solitude","with care","with rigor","with kindness","without ego","with curiosity","in the long run","when repeated","in the margins","with awareness","through failure","with gratitude"],
        closers: ["small truths outlive loud opinions","consistency beats intensity","listening creates understanding","humility opens every door","skills follow attention","wisdom begins with curiosity","practice changes identity","clarity follows action","trade pride for progress","what you repeat is what you become","the map is not the terrain","start with questions","seek first to understand","simple scales, complex fails","direction is a decision","discipline is liberating","make it obvious","choose long-term over loud","measure what matters","learn, unlearn, relearn"]
    },
    love: {
        adjectives: ["kind","warm","gentle","patient","soft","steady","brave","open","tender","honest","careful","hopeful","loyal","humble","playful","faithful","joyful","present","whole","true"],
        nouns: ["words","hands","eyes","time","attention","gestures","moments","morning notes","small favors","promises","presence","listening","effort","apologies","boundaries","laughter","memories","choices","gifts","care"],
        verbs: ["make","carry","build","hold","heal","forgive","notice","choose","guard","nourish","protect","restore","light","soften","anchor","celebrate","welcome","strengthen","grow","multiply"],
        objects: ["trust","safety","home","hope","us","tomorrow","each other","the hard days","the quiet moments","the little things","honesty","patience","understanding","respect","friendship","joy","grace","we","our story","the bond"],
        adverbs: ["daily","in small ways","in the mess","when tired","in public and private","when no one sees","without keeping score","with patience","with time","with presence","with laughter","when it’s hard","with gentleness","with wonder","with gratitude","through storms","through change","with steady hands","with open hearts","forever learning"],
        closers: ["love is a practice","small care builds big trust","kindness is love’s first language","choose each other again","soft is strong","we grow by giving","together beats perfect","show up and stay","make room for grace","we is greater than me","true love is daily work","attention is affection","patience makes love durable","be quick to listen","forgive often, repair always","speak gently, act clearly","gratitude turns houses into homes","hold hands through seasons","care louder than words","let love lead"]
    }
};
function generateProceduralQuote(type) { const t = quoteTemplates[type] || quoteTemplates.motivational; return { quote: `${pick(t.openers)}${pick(t.bridges)}${pick(t.endings)}`, author: 'JCHAT' }; }
        const inspirationalQuotes = {
            motivational: [
                { quote: "Every sunrise is an invitation to brighten your world.", author: "JCHAT" },
                { quote: "Your potential is limitless; dare to explore it.", author: "JCHAT" },
                { quote: "Small steps forward still lead to great destinations.", author: "JCHAT" },
                { quote: "Embrace challenges, for they forge your strength.", author: "JCHAT" },
                { quote: "The best time for new beginnings is now.", author: "JCHAT" },
            ],
            peaceful: [
                { quote: "Find your calm in the rhythm of your breath.", author: "JCHAT" },
                { quote: "Let go of what was, embrace the serenity of what is.", author: "JCHAT" },
                { quote: "Peace is not the absence of trouble, but the presence of calm within it.", author: "JCHAT" },
                { quote: "In stillness, discover the answers you seek.", author: "JCHAT" },
                { quote: "May your mind be clear, and your heart be light.", author: "JCHAT" },
            ],
            funny: [
                { quote: "I'm not lazy, I'm just on energy-saving mode.", author: "JCHAT" },
                { quote: "My bed is a magical place where I suddenly remember everything I forgot to do.", author: "JCHAT" },
                { quote: "I used to think I was indecisive, but now I'm not so sure.", author: "JCHAT" },
                { quote: "Life is short. Smile while you still have teeth.", author: "JCHAT" },
                { quote: "My favorite exercise is a cross between a lunge and a crunch. I call it lunch.", author: "JCHAT" },
            ],
            wisdom: [
                { quote: "True wisdom lies in knowing the depth of your own ignorance.", author: "JCHAT" },
                { quote: "The greatest teacher is experience.", author: "JCHAT" },
                { quote: "A mind stretched by new experiences never returns to its old dimensions.", author: "JCHAT" },
                { quote: "Listen more than you speak; learn more than you teach.", author: "JCHAT" },
                { quote: "The only true wisdom is in knowing you know nothing.", author: "JCHAT" },
            ],
            love: [
                { quote: "Kindness is love's simplest language.", author: "JCHAT" },
                { quote: "Love grows in the space between patience and care.", author: "JCHAT" },
                { quote: "Where gratitude lives, love multiplies.", author: "JCHAT" },
                { quote: "Choose love, even on the small days.", author: "JCHAT" },
            ]
        };
        // --- Level and XP Progression Logic ---
        /**
         * Provides information about user levels, XP requirements, and rewards.
         * @param {number} level - The current level of the user.
         * @returns {object} An object containing level details.
         */
        // Global cumulative Gas helper matching Profile.html
        function getTotalGasRequiredToReachLevel(level) {
            if (level <= 0) return 0;
            return 1500 * level * (level + 1) / 2;
        }
        function getLevelInfo(level) {
            let jCoinReward = 0;
            let gasReward = 0;
            let name = `Level ${level}`;
            let icon = "fas fa-question-circle";
            let otherRewards = [];

            // Base JCoin and Gas rewards scale linearly
            // Starting values and increments are adjusted to provide a smoother curve up to 500
            if (level >= 1 && level <= 25) { // Tier 1: Early Explorer
                jCoinReward = 10 + (level - 1) * 5; // Start 10, +5/level
                gasReward = 5 + (level - 1) * 2;   // Start 5, +2/level
                const levelNames = [
                    "Novice", "Beginner", "Apprentice", "Explorer", "Pioneer",
                    "Communicator", "Socialite", "Networker", "Influencer", "Trendsetter",
                    "Innovator", "Creator", "Visionary", "Architect", "Maestro",
                    "Strategist", "Guardian", "Champion", "Hero", "Legend",
                    "Mythic", "Celestial", "Divine", "Transcendent", "Cosmic Being"
                ];
                const levelIcons = [
                    "fas fa-leaf", "fas fa-seedling", "fas fa-user-graduate", "fas fa-map-marker-alt", "fas fa-compass",
                    "fas fa-comments", "fas fa-users", "fas fa-share-alt", "fas fa-star", "fas fa-fire",
                    "fas fa-lightbulb", "fas fa-paint-brush", "fas fa-eye", "fas fa-building", "fas fa-music",
                    "fas fa-chess", "fas fa-shield-alt", "fas fa-trophy", "fas fa-mask", "fas fa-dragon",
                    "fas fa-meteor", "fas fa-galaxy", "fas fa-hand-sparkles", "fas fa-infinity", "fas fa-atom"
                ];
                name = levelNames[level - 1] || `Level ${level}`;
                icon = levelIcons[level - 1] || "fas fa-question-circle";

                // Specific other rewards for Tier 1
                if (level === 1) otherRewards.push("Badge: 'Newbie'");
                if (level === 3) otherRewards.push("Unlock: 1-Hour XP Boost");
                if (level === 5) otherRewards.push("Badge: 'Chat Starter'", "Unlock: Basic Profile Picture Frame");
                if (level === 8) otherRewards.push("Unlock: Common Emote Pack (Set 1)");
                if (level === 10) otherRewards.push("Title: 'Friendly Face'", "Increased Message Character Limit (+10)");
                if (level === 13) otherRewards.push("Unlock: 3-Hour XP Boost");
                if (level === 15) otherRewards.push("Badge: 'Community Contributor'", "Unlock: Basic Chat Bubble Style");
                if (level === 18) otherRewards.push("Unlock: Common Emote Pack (Set 2)");
                if (level === 20) otherRewards.push("Title: 'Early Explorer'", "Increased Message Character Limit (+15)");
                if (level === 25) otherRewards.push("Badge: 'Veteran Chatter'", "Unlock: Gradient Profile Picture Frame");

            } else if (level >= 26 && level <= 100) { // Tier 2: Active Member (Levels 26 - 100)
                jCoinReward = 120 + (level - 26) * 8; // Starts higher, increases more
                gasReward = 30 + (level - 26) * 3;
                const tierNames = ["Active Member", "Group Enthusiast", "Social Butterfly", "Community Builder"];
                const tierIcons = ["fas fa-user-check", "fas fa-users-cog", "fas fa-globe-europe", "fas fa-handshake"];
                const tierIndex = Math.floor((level - 26) / 19); // Cycle every ~19 levels for 4 names
                name = `${tierNames[tierIndex % tierNames.length]} Lv. ${level}`;
                icon = tierIcons[tierIndex % tierIcons.length];

                // Specific other rewards for Tier 2
                if (level === 30) otherRewards.push("Badge: 'Active Member'", "Unlock: Uncommon Emote Pack (Set 1)");
                if (level === 35) otherRewards.push("Increased Friend Limit (+10)");
                if (level === 40) otherRewards.push("Unlock: New Chat Bubble Style (Set 2)");
                if (level === 45) otherRewards.push("Unlock: 1-Day XP Boost");
                if (level === 50) otherRewards.push("Title: 'Centurion'", "Permanent: 1% JCoin Shop Discount", "Badge: '50-Level Achiever'");
                if (level === 55) otherRewards.push("Unlock: Uncommon Emote Pack (Set 3)");
                if (level === 60) otherRewards.push("Increased Message Character Limit (+20)");
                if (level === 65) otherRewards.push("Unlock: Basic Profile Theme (Solid Color)");
                if (level === 70) otherRewards.push("Increased Friend Limit (+15)");
                if (level === 75) otherRewards.push("Title: 'Dedicated User'", "Unlock: Rare Emote Pack (Set 1)");
                if (level === 80) otherRewards.push("Unlock: New Chat Bubble Style (Set 3)");
                if (level === 85) otherRewards.push("Unlock: 3-Day XP Boost");
                if (level === 90) otherRewards.push("Increased Group Creation Limit (+1)");
                if (level === 95) otherRewards.push("Unlock: Uncommon Profile Picture Frame");
                if (level === 100) otherRewards.push("Title: 'Master Conversationalist'", "Badge: 'Century Mark'", "Permanent: 2% JCoin Shop Discount", "Unlock: Exclusive 'Golden' Profile Picture Frame");

            } else if (level >= 101 && level <= 250) { // Tier 3: Dedicated User (Levels 101 - 250)
                jCoinReward = 750 + (level - 101) * 12;
                gasReward = 150 + (level - 101) * 5;
                const tierNames = ["Dedicated User", "JCHAT Elite", "Master Communicator", "Community Architect"];
                const tierIcons = ["fas fa-user-shield", "fas fa-gem", "fas fa-microphone-alt", "fas fa-sitemap"];
                const tierIndex = Math.floor((level - 101) / 37); // Cycle every ~37 levels for 4 names
                name = `${tierNames[tierIndex % tierNames.length]} Lv. ${level}`;
                icon = tierIcons[tierIndex % tierIcons.length];

                // Specific other rewards for Tier 3
                if (level === 110) otherRewards.push("Unlock: Animated Emote Pack (Set 1)");
                if (level === 120) otherRewards.push("Increased Media Upload Size (+5MB)");
                if (level === 125) otherRewards.push("Title: 'Rising Star'", "Unlock: Custom Chat Font (Style 1)");
                if (level === 130) otherRewards.push("Unlock: 7-Day XP Boost");
                if (level === 140) otherRewards.push("Permanent: 3% JCoin Shop Discount");
                if (level === 150) otherRewards.push("Badge: 'JCHAT Expert'", "Unlock: Premium Profile Theme (Animated 1)");
                if (level === 160) otherRewards.push("Increased Group Member Capacity (+5)");
                if (level === 170) otherRewards.push("Unlock: Animated Emote Pack (Set 2)");
                if (level === 175) otherRewards.push("Title: 'Elite Communicator'", "Unlock: Custom Chat Font (Style 2)");
                if (level === 180) otherRewards.push("Increased Message Character Limit (+25)");
                if (level === 190) otherRewards.push("Permanent: 4% JCoin Shop Discount");
                if (level === 200) otherRewards.push("Badge: 'Double Century'", "Title: 'JCHAT Champion'", "Unlock: Exclusive 'Diamond' Profile Picture Frame", "Voucher: 1-Day Free Group Promotion");
                if (level === 210) otherRewards.push("Increased Media Upload Size (+10MB)");
                if (level === 220) otherRewards.push("Unlock: Premium Profile Theme (Animated 2)");
                if (level === 230) otherRewards.push("Unlock: Rare Emote Pack (Set 2)");
                if (level === 240) otherRewards.push("Priority Support Access");
                if (level === 250) otherRewards.push("Badge: 'Quarter-Millennium'", "Title: 'The Architect'", "Early Access: Next Major Feature Beta");

            } else if (level >= 251 && level <= 400) { // Tier 4: JCHAT Legend (Levels 251 - 400)
                jCoinReward = 2500 + (level - 251) * 20;
                gasReward = 500 + (level - 251) * 10;
                const tierNames = ["JCHAT Legend", "Grandmaster", "Cosmic Converser", "Eternal Speaker"];
                const tierIcons = ["fas fa-star-half-alt", "fas fa-chess-king", "fas fa-galaxy", "fas fa-infinity"];
                const tierIndex = Math.floor((level - 251) / 37); // Cycle every ~37 levels for 4 names
                name = `${tierNames[tierIndex % tierNames.length]} Lv. ${level}`;
                icon = tierIcons[tierIndex % tierIcons.length];

                // Specific other rewards for Tier 4
                if (level === 260) otherRewards.push("Permanent: 5% JCoin Shop Discount");
                if (level === 275) otherRewards.push("Title: 'Grand Strategist'", "Unlock: Legendary Emote Pack (Set 1)");
                if (level === 290) otherRewards.push("Increased Group Creation Limit (+2)");
                if (level === 300) otherRewards.push("Badge: 'Triple Century'", "Title: 'JCHAT Grandmaster'", "Voucher: 3-Day Free Group Promotion", "Unlock: Exclusive VIP Chat Room Access");
                if (level === 310) otherRewards.push("Increased Media Upload Size (+15MB)");
                if (level === 325) otherRewards.push("Title: 'Cosmic Weaver'", "Unlock: Custom Chat Font (Style 3)");
                if (level === 340) otherRewards.push("Permanent: 7% JCoin Shop Discount");
                if (level === 350) otherRewards.push("Badge: 'JCHAT Luminary'", "Unlock: Personalized Emote Slot (1 custom upload)");
                if (level === 360) otherRewards.push("Increased Group Member Capacity (+10)");
                if (level === 375) otherRewards.push("Title: 'The Eternal Flame'", "Unlock: Legendary Emote Pack (Set 2)");
                if (level === 390) otherRewards.push("Ad-Free Experience (1 Month)");
                if (level === 400) otherRewards.push("Badge: 'Quad Century'", "Title: 'The Unrivaled'", "Permanent: 10% JCoin Shop Discount", "Unlock: Unique Profile Aura (Tier 1)");

            } else if (level >= 401 && level <= 500) { // Tier 5: The Unrivaled (Levels 401 - 500)
                jCoinReward = 5000 + (level - 401) * 30;
                gasReward = 1000 + (level - 401) * 15;
                const tierNames = ["The Unrivaled", "Cosmic Creator", "JCHAT Deity", "Apex Being"];
                const tierIcons = ["fas fa-infinity", "fas fa-solar-system", "fas fa-hand-holding-heart", "fas fa-star-and-crescent"];
                const tierIndex = Math.floor((level - 401) / 25); // Cycle every 25 levels for 4 names
                name = `${tierNames[tierIndex % tierNames.length]} Lv. ${level}`;
                icon = tierIcons[tierIndex % tierIcons.length];

                // Specific other rewards for Tier 5
                if (level === 410) otherRewards.push("Ad-Free Experience (3 Months)");
                if (level === 425) otherRewards.push("Title: 'Pinnacle Performer'", "Unlock: Unique Profile Aura (Tier 2)");
                if (level === 440) otherRewards.push("Increased Media Upload Size (+20MB)");
                if (level === 450) otherRewards.push("Badge: 'Near-God'", "Unlock: Mythic Emote Pack (Set 1)");
                if (level === 460) otherRewards.push("Permanent: 12% JCoin Shop Discount");
                if (level === 475) otherRewards.push("Title: 'Cosmic Architect'", "Voucher: 7-Day Free Group Promotion");
                if (level === 480) otherRewards.push("Ad-Free Experience (6 Months)");
                if (level === 490) otherRewards.push("Unlock: Exclusive 'Cosmic' Animated Avatar Frame");
                if (level === 500) {
                    otherRewards.push(
                        "Badge: 'JCHAT Deity'",
                        "Title: 'The Absolute'",
                        "Lifetime Premium Status (Ad-Free, All Cosmetics Unlocked)",
                        "Personalized Group Creation Perk (Custom starting benefits for new groups)",
                        "Acknowledgment on JCHAT Hall of Fame (Your name/ID listed on a special page)",
                        "Exclusive Discord Role (if applicable)",
                        "Voting Rights on Future Feature Development"
                    );
                }
            } else if (level > 500) {
                // Beyond level 500, continue scaling rewards and use a generic "Master" tier
                jCoinReward = 5000 + (500 - 401) * 30 + (level - 500) * 50;
                gasReward = 1000 + (500 - 401) * 8 + (level - 500) * 15;
                name = `Master Lv. ${level}`;
                icon = "fas fa-star";
                otherRewards.push("Continued JCoin & Gas Rewards", "Exclusive Recognition (Tier 6)");
                if (level % 100 === 0) otherRewards.push("Special Milestone Bonus");
            }

            const xpToNextLevel = getTotalGasRequiredToReachLevel(level);
            const timeEstimate = "Unknown";

            return {
                level: level,
                name: name,
                icon: icon,
                jCoinReward: jCoinReward,
                gasReward: gasReward,
                xpToNextLevel: xpToNextLevel,
                timeEstimate: timeEstimate,
                otherRewards: otherRewards
            };
        }

        // --- NEW: Pending Activity Reward Creation Function ---
        /**
         * Creates a pending activity reward document for admin review.
         * This system allows for manual approval of XP/JCoin rewards, preventing abuse.
         * @param {string} userId - The ID of the user who performed the activity.
         * @param {string} username - The username of the user.
         * @param {string} activityType - The type of activity (e.g., 'daily_login', 'react_like', 'post_comment', 'post_creation', 'post_deletion').
         * @param {number} suggestedXpReward - The suggested XP amount to award (can be negative for deductions).
         * @param {number} suggestedJCoinReward - The suggested JCoin amount to award (can be negative for deductions).
         * @param {string} [activityId=null] - Optional: ID of the specific activity (e.g., commentId, reactionId).
         * @param {string} [postId=null] - Optional: ID of the post related to the activity.
         */
        async function createPendingActivityReward(
            userId,
            username,
            activityType,
            suggestedXpReward,
            suggestedJCoinReward,
            activityId = null,
            postId = null
        ) {
            try {
                const pendingRewardsCollectionRef = collection(db, "artifacts", appId, "public", "data", "pending_activity_rewards");

                const newRewardDocRef = await addDoc(pendingRewardsCollectionRef, {
                    userId: userId,
                    username: username,
                    activityType: activityType,
                    suggestedXpReward: suggestedXpReward,
                    suggestedJCoinReward: suggestedJCoinReward,
                    status: 'pending', // Always pending for admin review
                    timestamp: serverTimestamp(),
                    activityId: activityId, // Store activity ID if relevant
                    postId: postId // Store postId if relevant
                });

                console.log(`JCHAT_DEBUG: Pending activity reward created with ID: ${newRewardDocRef.id}`);
            } catch (error) {
                console.error("JCHAT_ERROR: Error creating pending activity reward:", error);
            }
        }

        // --- Daily Login Bonus Logic ---
        /**
         * Updates the countdown timer and state of the daily bonus button.
         * This function is called every second by an interval.
         */
        function updateDailyBonusCountdown() {
            // If user or profile data is not available, stop the timer and disable the button.
            if (!currentUserProfileData || !claimDailyBonusButton) {
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            const now = new Date();
            // Convert Firestore Timestamp to Date object if it exists.
            const lastClaimedTimestamp = currentUserProfileData.lastLoginBonusClaimed ?
                currentUserProfileData.lastLoginBonusClaimed.toDate() : null;

            // If no previous claim, enable the button immediately.
            if (!lastClaimedTimestamp) {
                claimDailyBonusButton.disabled = false;
                claimDailyBonusButton.querySelector('.button-text').textContent = "Claim Daily Bonus";
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            // Calculate the next available claim time (24 hours after last claim).
            const nextClaimTime = new Date(lastClaimedTimestamp.getTime() + (24 * 60 * 60 * 1000));
            const timeLeft = nextClaimTime.getTime() - now.getTime();

            if (timeLeft <= 0) {
                // If cooldown is over, enable the button.
                claimDailyBonusButton.disabled = false;
                claimDailyBonusButton.querySelector('.button-text').textContent = "Claim Daily Bonus";
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
            } else {
                // If still in cooldown, display the countdown.
                claimDailyBonusButton.disabled = true;
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                claimDailyBonusButton.querySelector('.button-text').textContent = `Next in ${hours}h ${minutes}m ${seconds}s`;
            }
        }
        /**
         * Checks the daily bonus status and starts/stops the countdown timer.
         * This is called on auth state change and after claiming a bonus.
         */
        // Compute daily bonus (Hard mode): only if checklist met AND streak ≥ 3; small 1–3 J
        function computeDailyBonusFromStreak(streakCount, userId) {
            const baseXp = 3; // tiny XP
            const jc = Math.max(0, Math.min(3, streakCount >= 3 ? 1 + Math.floor(Math.sqrt(streakCount)) : 0));
            const xp = baseXp + Math.min(streakCount, 10);
            return { xp, jc };
        }
        // Read the current streak count for the logged-in user (no side effects)
        async function getCurrentStreakCount() {
            try {
                if (!currentUser) return 0;
                const streakDocRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'streak');
                const streakSnap = await getDoc(streakDocRef);
                if (streakSnap.exists()) {
                    const d = streakSnap.data();
                    return d.count || 0;
                }
            } catch (e) { console.warn('JCHAT_WARN: getCurrentStreakCount failed', e); }
            return 0;
        }
        // Local daily activity counters and unified reward computation for posts, reactions, comments
        function _dailyKey(activity){ const d=new Date(); d.setHours(0,0,0,0); const uid=currentUser?.uid||'guest'; return `jchat-activity-count-${activity}-${uid}-${d.getTime()}`; }
function getDailyActivityCount(activity){ try{ return parseInt(localStorage.getItem(_dailyKey(activity))||'0',10)||0; }catch{ return 0; } }
function incrementDailyActivityCount(activity){ try{ const k=_dailyKey(activity); const n=(parseInt(localStorage.getItem(k)||'0',10)||0)+1; localStorage.setItem(k,String(n)); }catch{} }
function _dailyAccruedKey(){ const d=new Date(); d.setHours(0,0,0,0); const uid=currentUser?.uid||'guest'; return `jchat-daily-jc-${uid}-${d.getTime()}`; }
function _monthlyAccruedKey(){ const uid=currentUser?.uid||'guest'; const y=new Date().getFullYear(); const m=(new Date().getMonth()+1).toString().padStart(2,'0'); return `jchat-monthly-jc-${uid}-${y}${m}`; }
function getAccrued(name){ try{ return parseInt(localStorage.getItem(name)||'0',10)||0; }catch{ return 0; } }
function addAccruedDailyMonthly(jc){ try{ localStorage.setItem(_dailyAccruedKey(), String(getAccrued(_dailyAccruedKey())+jc)); localStorage.setItem(_monthlyAccruedKey(), String(getAccrued(_monthlyAccruedKey())+jc)); }catch{} }
function meetsDailyChecklist(){ return getDailyActivityCount('post')>=15 && getDailyActivityCount('comment')>=50 && getDailyActivityCount('reaction')>=100; }
function capsReduce(jc){ const DAILY_CAP=10, MONTHLY_CAP=400; const d=getAccrued(_dailyAccruedKey()); const m=getAccrued(_monthlyAccruedKey()); const remainD=Math.max(0,DAILY_CAP-d); const remainM=Math.max(0,MONTHLY_CAP-m); return Math.max(0, Math.min(jc, remainD, remainM)); }
async function computeActivityReward(activityType, ctx={}){
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,Math.floor(v)));
  // Negative activities pass through
  if (activityType==='unreact_like'||activityType==='unreact_love'||activityType==='unreact_haha') return {xp:-3,jc:-1};
  if (activityType==='comment_deletion') return {xp:-4,jc:-3};
  if (activityType==='post_deletion') return {xp:-18,jc:-6};
  // Hard mode gate: require checklist before earning JCoins
  const checklistOK = meetsDailyChecklist();
  // Minimal XP always; JCoins only if checklist satisfied
  if (activityType==='post_creation'){
    const len = clamp(ctx.contentLen||0,0,5000);
    const valid = len>=140; // long-form only
    let xp = valid ? 6 : 1;
    let jc = valid && checklistOK ? 0.2 : 0; // 0.2 J per post
    jc = capsReduce(Math.floor(jc*100)/100); // keep two decimals, then cap
    if (jc>0) addAccruedDailyMonthly(jc);
    return { xp, jc };
  }
  if (activityType && activityType.startsWith('react_')){
    // Reactions do not pay JCoins; tiny XP only
    return { xp: 1, jc: 0 };
  }
  if (activityType==='post_comment'){
    const len = clamp(ctx.contentLen||0,0,5000);
    const valid = len>=60;
    let xp = valid ? 2 : 1;
    let jc = valid && checklistOK ? 0.05 : 0; // 0.05 J per comment
    jc = capsReduce(Math.floor(jc*100)/100);
    if (jc>0) addAccruedDailyMonthly(jc);
    return { xp, jc };
  }
  // Default: no coins
  return { xp: 0, jc: 0 };
}
async function checkAndStartDailyBonusTimer() {
            // Disable button and clear timer if not authenticated or profile not loaded.
            if (!currentUser || !currentUserProfileData) {
                if (claimDailyBonusButton) {
                    claimDailyBonusButton.disabled = true;
                    claimDailyBonusButton.querySelector('.button-text').textContent = "Login to Claim Bonus";
                }
                if (dailyBonusCountdownInterval) {
                    clearInterval(dailyBonusCountdownInterval);
                    dailyBonusCountdownInterval = null;
                }
                return;
            }

            // Perform an initial update to set the correct state immediately.
            updateDailyBonusCountdown();

            // Clear any existing interval before setting a new one to prevent duplicates.
            if (dailyBonusCountdownInterval) {
                clearInterval(dailyBonusCountdownInterval);
            }

            // Start the interval only if the button is currently disabled (meaning there's an active cooldown).
            if (claimDailyBonusButton && claimDailyBonusButton.disabled) {
                dailyBonusCountdownInterval = setInterval(updateDailyBonusCountdown, 1000); // Update every second
            }
        }
        /**
         * Handles the click event for claiming the daily bonus.
         * Checks cooldown, updates Firestore, and creates a pending reward.
         */
        async function handleClaimDailyBonusClick() {
            // Pre-checks for authentication and profile data.
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("Please log in to claim daily bonus.", 'error');
                return;
            }

            const now = new Date();
            const lastClaimedTimestamp = currentUserProfileData.lastLoginBonusClaimed ?
                currentUserProfileData.lastLoginBonusClaimed.toDate() : null;

            // Check if the bonus has already been claimed within the last 24 hours.
            if (lastClaimedTimestamp) {
                const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                if (lastClaimedTimestamp > twentyFourHoursAgo) {
                    showMessageBox("Daily bonus already claimed today. Check back tomorrow!", 'info');
                    return;
                }
            }

            // Show loading state for the button and message box.
            toggleButtonLoading(claimDailyBonusButton, true);
            showMessageBox("Claiming daily bonus...", 'loading', true);

            try {
                if (!meetsDailyChecklist()) {
                    showMessageBox("Complete today’s checklist first: 15 posts, 50 comments, 100 reactions.", 'warning');
                    return;
                }
                const userProfileDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "profiles", "user_profile");

                // Determine strict reward based on streak
                const streakCount = await getCurrentStreakCount();
                if (streakCount < 3) {
                    showMessageBox("Build a 3‑day streak to unlock the Daily Bonus.", 'warning');
                    return;
                }
                const reward = computeDailyBonusFromStreak(streakCount, currentUser.uid);

                // Update the lastLoginBonusClaimed timestamp in the user's private profile.
                await updateDoc(userProfileDocRef, {
                    lastLoginBonusClaimed: serverTimestamp(),
                    updatedAt: serverTimestamp()
                });

                // Cap daily/monthly
                const jcCapped = (function(){ const v = Math.max(0, reward.jc|0); const capped = capsReduce(v); if (capped<=0) return 0; addAccruedDailyMonthly(capped); return capped; })();

                // Create a pending reward for admin review instead of directly awarding.
                await createPendingActivityReward(
                    currentUser.uid,
                    currentUserProfileData.username,
                    'daily_login',
                    reward.xp,
                    jcCapped
                );

                showMessageBox(`Daily bonus claimed! +${reward.xp} XP and +${reward.jc} JCoins (streak-based) pending admin review.`, 'success');
                playNotificationSound('success');

                // Update local profile data immediately for UI consistency (especially for the timer).
                currentUserProfileData.lastLoginBonusClaimed = { toDate: () => new Date() };
                checkAndStartDailyBonusTimer(); // Re-evaluate status and start/stop timer.
            } catch (error) {
                console.error("JCHAT_ERROR: Error claiming daily bonus:", error);
                showMessageBox(`Failed to claim bonus: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(claimDailyBonusButton, false); // Revert button loading state.
            }
        }

        // --- Tone.js Synths for Notification Sounds ---
        // Initialize various synths for different notification types.
        const successSynth = new Tone.Synth().toDestination();
        const errorSynth = new Tone.Synth().toDestination();
        const infoSynth = new Tone.Synth().toDestination();
        const ringingSynth = new Tone.Synth().toDestination(); // For incoming call ring

        // Configure basic sound properties for each synth.
        successSynth.oscillator.type = "sine";
        successSynth.envelope.attack = 0.01;
        successSynth.envelope.decay = 0.2;
        successSynth.envelope.sustain = 0.0;
        successSynth.envelope.release = 0.5;

        errorSynth.oscillator.type = "sawtooth";
        errorSynth.envelope.attack = 0.01;
        errorSynth.envelope.decay = 0.3;
        errorSynth.envelope.sustain = 0.0;
        errorSynth.envelope.release = 0.5;

        infoSynth.oscillator.type = "triangle";
        infoSynth.envelope.attack = 0.01;
        infoSynth.envelope.decay = 0.1;
        infoSynth.envelope.sustain = 0.0;
        infoSynth.envelope.release = 0.3;

        // Ringing sound (similar to a phone ring) pattern setup.
        ringingSynth.oscillator.type = "square";
        ringingSynth.envelope.attack = 0.01;
        ringingSynth.envelope.decay = 0.6;
        ringingSynth.envelope.sustain = 0.0;
        ringingSynth.envelope.release = 0.8;
        const ringingPattern = new Tone.Pattern(function(time, note){
            ringingSynth.triggerAttackRelease(note, "8n", time);
        }, ["C5", "C5", "C5", "C5"]).start(0);
        ringingPattern.interval = "1s"; // Adjust interval for ringing pattern.
        ringingPattern.humanize = true;
        ringingPattern.playbackRate = 1;
        ringingPattern.loop = true;
        ringingPattern.autostart = false; // Will be started manually.

        // --- Comprehensive Notification System ---
        let notifications = [];
        let unreadNotificationCount = 0;
        let notificationSoundEnabled = true;

        /**
         * Creates a new notification
         * @param {string} type - 'success', 'error', 'info', 'warning', 'friend_request', 'message', 'level_up'
         * @param {string} title - Notification title
         * @param {string} message - Notification message
         * @param {string} icon - FontAwesome icon class (optional, will auto-select based on type)
         * @param {boolean} persistent - Whether notification should persist
         */
        function createNotification(type, title, message, icon = null, persistent = false) {
            // Auto-select icon based on type if not provided
            if (!icon) {
                switch (type) {
                    case 'success':
                        icon = 'fas fa-check-circle';
                        break;
                    case 'error':
                        icon = 'fas fa-exclamation-circle';
                        break;
                    case 'info':
                        icon = 'fas fa-info-circle';
                        break;
                    case 'warning':
                        icon = 'fas fa-exclamation-triangle';
                        break;
                    case 'friend_request':
                        icon = 'fas fa-user-plus';
                        break;
                    case 'message':
                        icon = 'fas fa-comment';
                        break;
                    case 'level_up':
                        icon = 'fas fa-star';
                        break;
                    default:
                        icon = 'fas fa-bell';
                }
            }
            const notification = {
                id: Date.now() + Math.random(),
                type: type,
                title: title,
                message: message,
                icon: icon,
                timestamp: new Date(),
                read: false,
                persistent: persistent
            };

            notifications.unshift(notification);
            if (!notification.read) {
                unreadNotificationCount++;
            }

            // Limit notifications to 50
            if (notifications.length > 50) {
                notifications = notifications.slice(0, 50);
            }

            updateNotificationBadge(unreadNotificationCount);
            
            // Play sound if enabled
            if (notificationSoundEnabled) {
                playNotificationSound(type);
            }

            // Save to localStorage
            saveNotificationsToStorage();

            return notification;
        }
        /**
         * Plays a notification sound based on type.
         * @param {string} type - 'success', 'error', 'info', 'warning', 'friend_request', 'message', 'level_up'.
         */
        function playNotificationSound(type) {
            try {
                // Create audio element for the new notification sound
                const audio = new Audio('ne.mp3');
                audio.volume = 0.6; // Set volume to 60%
                
                // Play the notification sound
                audio.play().catch(error => {
                    console.log('JCHAT_DEBUG: Could not play notification sound:', error);
                    // Fallback to Tone.js if audio file fails
                    Tone.start();
                    if (type === 'success') {
                        successSynth.triggerAttackRelease("C5", "8n");
                    } else if (type === 'error') {
                        errorSynth.triggerAttackRelease("C3", "8n");
                    } else if (type === 'info') {
                        infoSynth.triggerAttackRelease("E4", "16n");
                    } else if (type === 'warning') {
                        errorSynth.triggerAttackRelease("A3", "8n");
                    } else if (type === 'friend_request') {
                        infoSynth.triggerAttackRelease("G4", "8n");
                    } else if (type === 'message') {
                        infoSynth.triggerAttackRelease("D4", "8n");
                    } else if (type === 'level_up') {
                        successSynth.triggerAttackRelease("C6", "4n");
                    }
                });
            } catch (error) {
                console.log('JCHAT_DEBUG: Error playing notification sound:', error);
                // Fallback to Tone.js
                Tone.start();
                if (type === 'success') {
                    successSynth.triggerAttackRelease("C5", "8n");
                } else if (type === 'error') {
                    errorSynth.triggerAttackRelease("C3", "8n");
                } else if (type === 'info') {
                    infoSynth.triggerAttackRelease("E4", "16n");
                } else if (type === 'warning') {
                    errorSynth.triggerAttackRelease("A3", "8n");
                } else if (type === 'friend_request') {
                    infoSynth.triggerAttackRelease("G4", "8n");
                } else if (type === 'message') {
                    infoSynth.triggerAttackRelease("D4", "8n");
                } else if (type === 'level_up') {
                    successSynth.triggerAttackRelease("C6", "4n");
                }
            }
        }

        /**
         * Starts the ringing sound for incoming calls.
         */
        function startRingingSound() {
            Tone.start();
            ringingPattern.start();
        }

        /**
         * Stops the ringing sound.
         */
        function stopRingingSound() {
            ringingPattern.stop();
        }
        // --- Utility Functions ---
        /**
         * Displays a custom message box with a given message, type, and persistence.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', 'info', 'warning', or 'loading'.
         * @param {boolean} isPersistent - If true, the message box will not auto-hide.
         */
        function showMessageBox(message, type, isPersistent = false) {
            if (!messageBox) {
                messageBox = document.getElementById('messageBox');
                if (!messageBox) {
                    console.error("JCHAT_ERROR: messageBox element not found.");
                    return;
                }
            }
            // Clear any existing auto-hide timeout.
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }

            // Set inner HTML with icon and text elements.
            messageBox.innerHTML = `<i id=\"messageBoxIcon\"></i><span id=\"messageBoxText\"></span><button id=\"messageBoxClose\" aria-label=\"Close\" style=\"margin-left:8px;border:none;background:transparent;color:inherit;cursor:pointer;\"><i class=\"fas fa-times\"></i></button>`;
            const messageBoxIcon = document.getElementById('messageBoxIcon');
            const messageBoxText = document.getElementById('messageBoxText');

            messageBoxText.textContent = message;
            // Apply CSS classes for styling and visibility.
            messageBox.className = 'message-box show ' + type;

            // Set icon based on message type.
            if (messageBoxIcon) {
                messageBoxIcon.className = ''; // Clear existing classes.
                if (type === 'success') {
                    messageBoxIcon.classList.add('fas', 'fa-check-circle');
                } else if (type === 'error') {
                    messageBoxIcon.classList.add('fas', 'fa-times-circle');
                } else if (type === 'info') {
                    messageBoxIcon.classList.add('fas', 'fa-info-circle');
                } else if (type === 'warning') {
                    messageBoxIcon.classList.add('fas', 'fa-exclamation-triangle');
                } else if (type === 'loading') {
                    messageBoxIcon.classList.add('fas', 'fa-spinner', 'fa-spin'); // Spinner for loading.
                }
            }

            // Apply pulsing animation for loading messages.
            if (type === 'loading') {
                messageBox.classList.add('loading-pulse');
            } else {
                messageBox.classList.remove('loading-pulse');
            }

            // Make the message box visible.
            messageBox.style.display = 'flex';
            messageBox.style.opacity = '1';

            // Manual close handler
            const messageBoxClose = document.getElementById('messageBoxClose');
            if (messageBoxClose) {
                messageBoxClose.onclick = () => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', function handler() {
                        messageBox.style.display = 'none';
                        messageBox.removeEventListener('transitionend', handler);
                        messageBox.classList.remove('loading-pulse');
                    }, { once: true });
                };
            }

            // Set auto-hide timeout if not persistent.
            if (!isPersistent) {
                messageBox.timeoutId = setTimeout(() => {
                    messageBox.style.opacity = '0';
                    messageBox.addEventListener('transitionend', function handler() {
                        messageBox.style.display = 'none';
                        messageBox.removeEventListener('transitionend', handler);
                        messageBox.classList.remove('loading-pulse');
                    }, { once: true });
                }, 3000);
            }
        }

        /**
         * Displays a confirmation modal and returns a Promise that resolves to true if confirmed, false otherwise.
         * @param {string} title - The title of the confirmation modal.
         * @param {string} message - The message to display in the confirmation modal.
         * @returns {Promise<boolean>}
         */
        function showConfirmationModal(title, message) {
            return new Promise((resolve) => {
                // Check if all necessary modal elements exist.
                if (!confirmationTitle || !confirmationMessage || !confirmationModal || !confirmProceedButton || !confirmCancelButton) {
                    console.error("JCHAT_ERROR: Confirmation modal elements not found.");
                    resolve(false); // Resolve false if elements are missing.
                    return;
                }

                confirmationTitle.textContent = title;
                confirmationMessage.textContent = message;
                confirmationModal.classList.add('active'); // Show the modal.

                // Event handler for confirming the action.
                const handleConfirm = () => {
                    confirmationModal.classList.remove('active'); // Hide modal.
                    // Remove event listeners to prevent memory leaks and duplicate calls.
                    confirmProceedButton.removeEventListener('click', handleConfirm);
                    confirmCancelButton.removeEventListener('click', handleCancel);
                    resolve(true); // Resolve with true (confirmed).
                };

                // Event handler for canceling the action.
                const handleCancel = () => {
                    confirmationModal.classList.remove('active'); // Hide modal.
                    // Remove event listeners.
                    confirmProceedButton.removeEventListener('click', handleConfirm);
                    confirmCancelButton.removeEventListener('click', handleCancel);
                    resolve(false); // Resolve with false (canceled).
                };

                // Attach event listeners to buttons.
                confirmProceedButton.addEventListener('click', handleConfirm);
                confirmCancelButton.addEventListener('click', handleCancel);

                // Close modal if clicking outside the content area.
                confirmationModal.addEventListener('click', function outsideClickListener(event) {
                    if (event.target === confirmationModal) {
                        handleCancel(); // Treat outside click as a cancel.
                        confirmationModal.removeEventListener('click', outsideClickListener);
                    }
                });
            });
        }

        /**
         * Generates a Cloudinary image URL with specified transformations.
         * Handles both public IDs and existing Cloudinary URLs.
         * @param {string} urlOrPublicId - The Cloudinary public ID or an existing Cloudinary URL.
         * @param {string} transformations - Cloudinary transformation string (e.g., "w_auto,f_auto,q_auto").
         * @returns {string|null} The transformed Cloudinary URL or null if input is invalid.
         */
        function getCloudinaryImageUrl(urlOrPublicId, transformations = "w_auto,f_auto,q_auto") {
            if (!urlOrPublicId) return null;
            if (urlOrPublicId.startsWith('http://') || urlOrPublicId.startsWith('https://')) {
                // If it's already a full URL, ensure it's a Cloudinary URL before transforming.
                if (urlOrPublicId.includes('res.cloudinary.com')) {
                    // This is a basic attempt to insert transformations into an existing Cloudinary URL.
                    // More robust parsing might be needed for complex existing URLs.
                    const parts = urlOrPublicId.split('/upload/');
                    if (parts.length === 2) {
                        // Check if transformations are already present to avoid duplication.
                        const currentTransformations = parts[1].split('/')[0];
                        if (currentTransformations.includes(transformations.split(',')[0])) {
                            return urlOrPublicId; // Assume already transformed.
                        }
                        return `${parts[0]}/upload/${transformations}/${parts[1]}`;
                    }
                }
                return urlOrPublicId; // Return as is if not a recognizable Cloudinary URL or already transformed.
            }
            // Construct URL from public ID.
            return `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/image/upload/${transformations}/${urlOrPublicId}`;
        }

        /**
         * Displays a profile picture or a placeholder icon based on the provided profilePicId.
         * @param {HTMLImageElement} imgElement - The <img> element to display the picture.
         * @param {HTMLElement} iconElement - The <i> element to display the placeholder icon.
         * @param {string|null} profilePicId - The Cloudinary public ID of the profile picture, or null.
         * @param {string} usernameInitial - The first letter of the username for the placeholder.
         * @param {string} transformations - Cloudinary transformation string for the image.
         */
        function displayProfilePicture(imgElement, iconElement, profilePicId, usernameInitial, transformations) {
            if (!imgElement || !iconElement) return;
            const placeholder = '/assets/User.png';
            if (profilePicId) {
                const imageUrl = getCloudinaryImageUrl(profilePicId, transformations);
                imgElement.onerror = () => { imgElement.onerror = null; imgElement.src = placeholder; };
                imgElement.src = imageUrl || placeholder;
                imgElement.style.display = 'block';
                iconElement.style.display = 'none';
            } else {
                imgElement.onerror = null;
                imgElement.src = placeholder;
                imgElement.style.display = 'block';
                iconElement.style.display = 'none';
            }
        }

        /**
         * Resizes an image file using a canvas and returns it as a Blob.
         * @param {File} file - The image file to resize.
         * @param {number} maxWidth - Maximum width for the resized image.
         * @param {number} maxHeight - Maximum height for the resized image.
         * @param {number} quality - JPEG quality (0.0 to 1.0).
         * @returns {Promise<Blob>} A Promise that resolves with the resized image Blob.
         */
        function resizeImage(file, maxWidth = 800, maxHeight = 800, quality = 0.8) {
            return new Promise((resolve, reject) => {
                if (!(file instanceof Blob)) {
                    reject(new Error('Invalid file input.'));
                    return;
                }
                const objectUrl = URL.createObjectURL(file);
                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        let width = img.width;
                        let height = img.height;

                        // Calculate new dimensions to fit within maxWidth/maxHeight while maintaining aspect ratio.
                        if (width > maxWidth) {
                            height = height * (maxWidth / width);
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = width * (maxHeight / height);
                            height = maxHeight;
                        }

                        canvas.width = width;
                        canvas.height = height;

                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert canvas content to a Blob.
                        canvas.toBlob((blob) => {
                            URL.revokeObjectURL(objectUrl);
                            if (blob) {
                                resolve(blob);
                            } else {
                                reject(new Error('Canvas to Blob conversion failed: Resulting blob was null.'));
                            }
                        }, 'image/jpeg', quality);
                    } catch (err) {
                        URL.revokeObjectURL(objectUrl);
                        reject(err);
                    }
                };
                img.onerror = (error) => {
                    URL.revokeObjectURL(objectUrl);
                    console.error("Image element loading error:", error);
                    reject(new Error(`Image loading failed: ${error.message || 'Unknown image loading error.'}`));
                };
                img.src = objectUrl;
            });
        }

        /**
         * Checks whether the MIME type is supported for in-browser image resizing.
         * @param {string} mimeType - e.g., 'image/jpeg'
         * @returns {boolean}
         */
        function isResizableImageType(mimeType) {
            const supported = ['image/jpeg','image/jpg','image/png','image/webp','image/gif','image/bmp'];
            return supported.includes((mimeType || '').toLowerCase());
        }

        /**
         * Uploads a media file (image or video) to Cloudinary.
         * @param {File|Blob} file - The file to upload.
         * @returns {Promise<string|null>} The secure URL of the uploaded media, or null if upload fails.
         */
        async function uploadMediaToCloudinary(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', cloudinaryConfig.uploadPreset);

                const resourceType = file.type.startsWith('image/') ? 'image' : 'video';

                const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/${resourceType}/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Cloudinary upload error:", errorData);
                    throw new Error(`Cloudinary upload failed: ${errorData.error.message || response.statusText}`);
                }

                const data = await response.json();
                return data.secure_url;
            } catch (error) {
                console.error("Error uploading to Cloudinary:", error);
                return null;
            }
        }

        /**
         * Applies the selected theme to the document body.
         * @param {string} themeName - The CSS class name for the theme (e.g., 'theme-dark-mode').
         */
        function applyTheme(themeName) {
            document.body.classList.remove(...themes); // Remove all existing theme classes.
            document.body.classList.add(themeName); // Add the new theme class.
            localStorage.setItem('jchat-theme', themeName); // Save theme preference to local storage.
        }

        /**
         * Toggles the loading state of a button, showing/hiding a spinner.
         * @param {HTMLButtonElement} buttonElement - The button element to toggle.
         * @param {boolean} isLoading - True to show loading state, false to hide.
         */
        function toggleButtonLoading(buttonElement, isLoading) {
            if (!buttonElement) return;
            
            const text = buttonElement.querySelector('.button-text');

            if (isLoading) {
                buttonElement.disabled = true; // Disable button during loading.
                buttonElement.classList.add('loading');
                
                if (text) text.style.display = 'none';
            } else {
                buttonElement.disabled = false; // Re-enable button.
                buttonElement.classList.remove('loading');
                
                if (text) text.style.display = 'block';
            }
        }
        /**
         * Enables or disables all interactive elements on the page based on a global state.
         * This is primarily used for maintenance mode or initial loading.
         * @param {boolean} enable - True to enable, false to disable.
         * @param {boolean} isCurrentUserAdmin - True if the current user is an admin (allows bypass for some features).
         */
        function toggleInteractiveElements(enable, isCurrentUserAdmin = false) {
            console.log(`JCHAT_DEBUG: toggleInteractiveElements called with enable: ${enable}, isAdmin: ${isCurrentUserAdmin}`);

            // If enabling, and it's an admin, we want to ensure everything is truly enabled.
            // Otherwise, apply the 'enable' state universally.
            const finalEnableState = enable || isCurrentUserAdmin; // If enable is true, or if it's an admin, enable.

            // Main content buttons/inputs
            if (sharePostInspirationButton) sharePostInspirationButton.disabled = !finalEnableState;
            if (customizeInspirationButton) customizeInspirationButton.disabled = !finalEnableState;
            if (claimDailyBonusButton) claimDailyBonusButton.disabled = !finalEnableState;
            if (postContentInput) postContentInput.disabled = !finalEnableState;
            if (postMediaUpload) postMediaUpload.disabled = !finalEnableState;
            if (createPostButton) createPostButton.disabled = !finalEnableState;

            // Dynamically created elements (posts, comments) - these will be refined by applySystemSettings later.
            // These are selected globally and then their disabled state is set.
            document.querySelectorAll('.comment-input').forEach(input => {
                input.disabled = !finalEnableState;
            });
            document.querySelectorAll('.submit-comment-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.react-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.comment-toggle-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.post-options-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.edit-post-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            // The delete-post-button is removed from here as per user request.
            document.querySelectorAll('.share-post-button').forEach(button => {
                button.disabled = !finalEnableState;
            });
            document.querySelectorAll('.delete-comment-button').forEach(button => {
                button.disabled = !finalEnableState;
            });

            // Modals (buttons within modals)
            if (cancelCustomizeButton) cancelCustomizeButton.disabled = !finalEnableState;
            if (saveCustomizeButton) saveCustomizeButton.disabled = !finalEnableState;
            if (editPostContentInput) editPostContentInput.disabled = !finalEnableState;
            if (editPostMediaUpload) editPostMediaUpload.disabled = !finalEnableState;
            if (removeEditMediaButton) removeEditMediaButton.disabled = !finalEnableState;
            if (cancelEditPostButton) cancelEditPostButton.disabled = !finalEnableState;
            if (saveEditedPostButton) saveEditedPostButton.disabled = !finalEnableState;
            if (confirmCancelButton) confirmCancelButton.disabled = !finalEnableState;
            if (confirmProceedButton) confirmProceedButton.disabled = !finalEnableState;

            // Sidebar links (pointer-events and opacity, as they are not 'disabled' attributes).
            // These will be further refined by applySystemSettings for specific toggles.
            if (chatLink) {
                chatLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                chatLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (findFriendsLink) {
                findFriendsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                findFriendsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (friendsLink) {
                friendsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                friendsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (groupsLink) {
                groupsLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                groupsLink.style.opacity = finalEnableState ? '1' : '0.5';
            }
            if (jcoinShopLink) {
                jcoinShopLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                jcoinShopLink.style.opacity = finalEnableState ? '1' : '0.5';
            }

            // Guide link - also controlled by global enable state.
            const guideLink = document.querySelector('.sidebar-nav-item[href="/Guide.html"]');
            if (guideLink) {
                guideLink.style.pointerEvents = finalEnableState ? 'auto' : 'none';
                guideLink.style.opacity = finalEnableState ? '1' : '0.5';
            }

            console.log(`JCHAT_DEBUG: Finished toggling interactive elements. Post content input disabled state: ${postContentInput ? postContentInput.disabled : 'N/A (element not found)'}`);
        }

        /**
         * Handles user logout, signs out from Firebase, updates inCall status, and redirects.
         */
        async function handleLogout() {
            if (!isAuthReady || !currentUser) {
                showMessageBox("Not ready to log out or no user found.", 'info');
                return;
            }

            try {
                // Set user's inCall status to false in public profile on logout.
                if (currentUser && currentUserProfileData) {
                    const userPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                    await updateDoc(userPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on logout:", e));
                }

                // End any active WebRTC call before logging out.
                if (callState !== 'idle') {
                    await endCall(false); // End call without updating Firestore status to avoid conflicts during logout.
                }

                await signOut(auth); // Sign out from Firebase.
                showMessageBox("Logged out successfully! 👋", 'success');
                // Redirect to login page after a short delay.
                setTimeout(() => {
                    window.location.href = '/login.html';
                }, 1500);

            } catch (error) {
                console.error("JCHAT_ERROR: Error logging out:", error);
                showMessageBox(`Failed to log out: ${error.message}. Please try again.`, 'error');
            }
        }

        /**
         * Updates the profile picture URL for all posts authored by a specific user.
         * This ensures consistency across the feed when a user changes their profile picture.
         * @param {string} userId - The ID of the user whose posts need updating.
         * @param {string} newProfilePicId - The new Cloudinary public ID for the profile picture.
         */
        async function updatePostsWithNewProfilePic(userId, newProfilePicId) {
            if (!isAuthReady) return;
            try {
                const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
                const q = query(postsCollectionRef, where("authorId", "==", userId));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const batch = writeBatch(db); // Use a batch write for efficiency.
                    querySnapshot.forEach(docSnap => {
                        const postRef = doc(db, "artifacts", appId, "public", "data", "posts", docSnap.id);
                        batch.update(postRef, { profilePhoto: newProfilePicId });
                    });
                    await batch.commit(); // Commit all batched updates.
                    console.log(`JCHAT_DEBUG: Updated profile picture for ${querySnapshot.size} posts by user ${userId}.`);
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating posts with new profile picture:", error);
            }
        }
        /**
         * Fetches and displays the current user's profile information in the header.
         * Creates a new profile if one doesn't exist.
         * Also syncs public profile data and updates posts if profile pic changes.
         * @param {object} user - The Firebase user object.
         */
        async function fetchAndDisplayHeaderProfile(user) {
            console.log("JCHAT_DEBUG: Entering fetchAndDisplayHeaderProfile for user:", user.uid);
            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", user.uid, "profiles", "user_profile");
                const publicProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);

                const privateDocSnap = await getDoc(privateProfileDocRef);
                let profileData = null;
                let oldProfilePicId = null;

                if (privateDocSnap.exists()) {
                    profileData = privateDocSnap.data();
                    oldProfilePicId = profileData.profilePicId;
                    console.log("JCHAT_DEBUG: Fetched existing private profile data:", profileData);
                } else {
                    // Create a new default profile if one doesn't exist.
                    profileData = {
                        username: user.displayName || `User_${user.uid.substring(0, 8)}`,
                        email: user.email || "",
                        profilePicId: user.photoURL || null,
                        bio: "",
                        location: "",
                        friendsCount: 0,
                        followersCount: 0,
                        followingCount: 0,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp(),
                        inspirationType: "motivational",
                        visibility: {
                            displayName: true, profilePic: true, bio: false, location: false,
                            emailPublic: false, allowFriendRequests: true, allowMessages: true,
                        },
                        totalPosts: 0,
                        jCoins: 0, // Ensure jCoins is initialized
                        gas: 0, // Ensure gas is initialized
                        level: 1, // Ensure level is initialized
                        currentXp: 0, // Ensure currentXp is initialized
                        xpToNextLevel: getLevelInfo(1).xpToNextLevel, // Ensure xpToNextLevel is initialized
                        lastLoginBonusClaimed: null, // Ensure lastLoginBonusClaimed is initialized
                        inCall: false, // Ensure inCall is initialized
                    };
                    await setDoc(privateProfileDocRef, profileData);
                    console.log("JCHAT_DEBUG: Created new private profile data:", profileData);
                }

                // Ensure new fields are present if they were added after initial profile creation (for existing users).
                const updates = {};
                if (profileData.gas === undefined) updates.gas = 0;
                if (profileData.level === undefined) updates.level = 1;
                if (profileData.currentXp === undefined) updates.currentXp = 0;
                if (profileData.xpToNextLevel === undefined || profileData.xpToNextLevel !== getLevelInfo(profileData.level || 1).xpToNextLevel) {
                     updates.xpToNextLevel = getLevelInfo(profileData.level || 1).xpToNextLevel;
                }
                if (profileData.lastLoginBonusClaimed === undefined) updates.lastLoginBonusClaimed = null;
                if (profileData.jCoins === undefined) updates.jCoins = 0; // Ensure jCoins is initialized
                if (profileData.inCall === undefined) updates.inCall = false; // Ensure inCall is initialized

                if (Object.keys(updates).length > 0) {
                    await updateDoc(privateProfileDocRef, updates);
                    const updatedSnap = await getDoc(privateProfileDocRef);
                    profileData = updatedSnap.data(); // Get the latest data after update.
                    console.log("JCHAT_DEBUG: Updated private profile with new fields:", updates);
                }

                currentUserProfileData = profileData; // Store the fetched/updated profile data globally.

                // For public profile, only include genuinely public fields and handle createdAt.
                const publicProfileUpdates = {
                    username: profileData.username,
                    profilePicId: profileData.profilePicId,
                    userId: user.uid,
                    totalPosts: profileData.totalPosts, // Ensure totalPosts is synced.
                    visibility: profileData.visibility, // Ensure visibility is synced.
                    updatedAt: serverTimestamp(),
                    inCall: profileData.inCall, // Sync inCall status to public profile.
                };
                // Only explicitly set createdAt if the public profile document does NOT exist.
                const publicDocSnap = await getDoc(publicProfileDocRef);
                if (!publicDocSnap.exists()) {
                    publicProfileUpdates.createdAt = serverTimestamp();
                }
                await setDoc(publicProfileDocRef, publicProfileUpdates, { merge: true }); // Use merge to avoid overwriting.
                console.log("JCHAT_DEBUG: Updated public profile summary:", publicProfileUpdates);

                const usernameInitial = (profileData.username || "J").charAt(0).toUpperCase();
                // Update header UI for profile picture and display name.
                if (headerProfilePic && headerAvatarIcon && headerDisplayName) {
                    displayProfilePicture(headerProfilePic, headerAvatarIcon, profileData?.profilePicId, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                    headerDisplayName.textContent = profileData.username || "JCHAT User";
                }

                // Ensure profile link is correct.
                if (profileLink) profileLink.href = `./Profile.html?userId=${user.uid}`;

                // If profile picture has changed, update all posts by this user.
                if (oldProfilePicId !== profileData.profilePicId) {
                    await updatePostsWithNewProfilePic(user.uid, profileData.profilePicId);
                }

                // Start displaying daily inspiration based on user's preference.
                startInspirationDisplay(currentUserProfileData.inspirationType || "motivational");
                await fetchNotificationCount(user.uid); // Fetch unread notification count.

                // Display admin icon if the current user is the admin.
                if (adminIconLink) {
                    if (user.uid === ADMIN_UID) {
                        adminIconLink.style.display = 'block';
                        console.log("JCHAT_DEBUG: Admin icon displayed.");
                    } else {
                        adminIconLink.style.display = 'none';
                        console.log("JCHAT_DEBUG: Admin icon hidden.");
                    }
                }

                console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile completed successfully.");
                if (typeof setLoaderStage === 'function') setLoaderStage('profile');
                // Hide loader once profile is loaded
                setTimeout(() => {
                    if (typeof setLoaderStage === 'function') setLoaderStage('feed');
                    hideLoader();
                }, 600);

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching or creating profile for header:", error);
                // Fallback UI update in case of error.
                const usernameInitial = (user.displayName || "J").charAt(0).toUpperCase();
                if (headerProfilePic && headerAvatarIcon && headerDisplayName) {
                    displayProfilePicture(headerProfilePic, headerAvatarIcon, user.photoURL, usernameInitial, "w_70,h_70,c_fill,g_face,r_max");
                    headerDisplayName.textContent = user.displayName || "JCHAT User";
                }
                showMessageBox(`Error loading header profile: ${error.message}`, 'error');

                console.log("JCHAT_DEBUG: fetchAndDisplayHeaderProfile failed. Interactive elements might still be enabled if auth succeeded.");
                
                // Hide loader even on error to prevent infinite loading
                setTimeout(() => {
                    hideLoader();
                }, 1000);
            }
        }

        /**
         * Fetches the count of unread notifications for the current user.
         * @param {string} userId - The ID of the current user.
         */
        async function fetchNotificationCount(userId) {
            if (!isAuthReady) return;
            try {
                const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                const q = query(notificationsCollectionRef, where("read", "==", false));
                const querySnapshot = await getDocs(q);
                const unreadCount = querySnapshot.size;

                // Use the new updateNotificationBadge function
                updateNotificationBadge(unreadCount);
            }
            catch (error) {
                console.error("JCHAT_ERROR: Error fetching notification count:", error);
                updateNotificationBadge(0);
            }
        }

        /**
         * Fetches and displays recent notifications in the dropdown
         * @param {string} userId - The ID of the current user
         */
        async function fetchRecentNotifications(userId) {
            if (!isAuthReady) return;
            
            const notificationList = document.getElementById('notificationList');
            if (!notificationList) return;
            
            try {
                const notificationsCollectionRef = collection(db, "artifacts", appId, "users", userId, "notifications");
                const q = query(notificationsCollectionRef, orderBy("timestamp", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    notificationList.innerHTML = `
                        <div class="notification-empty">
                            <i class="fas fa-bell-slash"></i>
                            <p>No notifications yet</p>
                        </div>
                    `;
                    return;
                }
                
                notificationList.innerHTML = '';
                
                querySnapshot.docs.forEach(doc => {
                    const notification = { id: doc.id, ...doc.data() };
                    const notificationElement = createNotificationElement(notification);
                    notificationList.appendChild(notificationElement);
                });
                
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching recent notifications:", error);
                notificationList.innerHTML = `
                    <div class="notification-empty">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Failed to load notifications</p>
                    </div>
                `;
            }
        }

        /**
         * Creates a notification element for the dropdown
         * @param {Object} notification - The notification data
         * @returns {HTMLElement} The notification element
         */
        function createNotificationElement(notification) {
            const notificationDiv = document.createElement('div');
            notificationDiv.className = `notification-item ${notification.read ? '' : 'unread'}`;
            notificationDiv.dataset.notificationId = notification.id;
            notificationDiv.dataset.notificationType = notification.type;
            
            // Determine icon based on notification type
            let iconClass = 'fas fa-info-circle';
            if (notification.type === 'message') iconClass = 'fas fa-comment-dots';
            else if (notification.type === 'friend_request') iconClass = 'fas fa-user-plus';
            else if (notification.type === 'friend_accepted') iconClass = 'fas fa-user-check';
            else if (notification.type === 'friend_rejected') iconClass = 'fas fa-user-times';
            else if (notification.type === 'coin_reward') iconClass = 'fas fa-coins';
            else if (notification.type === 'level_up') iconClass = 'fas fa-arrow-alt-circle-up';
            
            // Format timestamp
            const timestamp = notification.timestamp?.toDate ? notification.timestamp.toDate() : new Date(notification.timestamp);
            const timeAgo = formatTimeAgo(timestamp);
            
            notificationDiv.innerHTML = `
                <div class="notification-icon">
                    <i class="${iconClass}"></i>
                </div>
                <div class="notification-content">
                    <h4>${notification.message}</h4>
                    <p>${notification.senderUsername || 'System'}</p>
                    <div class="notification-time">${timeAgo}</div>
                </div>
            `;
            
            // Add click handler
            notificationDiv.addEventListener('click', () => handleNotificationClick(notification));
            
            return notificationDiv;
        }

        /**
         * Handles notification click based on type
         * @param {Object} notification - The notification data
         */
        function handleNotificationClick(notification) {
            // Mark as read
            markNotificationAsRead(notification.id);
            
            // Handle different notification types
            if (notification.type === 'message' && notification.senderId) {
                // Navigate to Chat.html with message information
                let chatUrl = `/Chat.html?partnerId=${notification.senderId}`;
                if (notification.messageId) {
                    chatUrl += `&messageId=${notification.messageId}`;
                    if (notification.messageTimestamp) {
                        const timestamp = notification.messageTimestamp;
                        const timestampValue = timestamp.seconds ? timestamp.seconds : 
                                             (timestamp.toDate ? timestamp.toDate().getTime() : 
                                              (timestamp instanceof Date ? timestamp.getTime() : timestamp));
                        chatUrl += `&messageTime=${timestampValue}`;
                    }
                }
                window.location.href = chatUrl;
            } else if (notification.type === 'friend_request' && notification.senderId) {
                // Navigate to Find Friends page
                window.location.href = `/Find_Friends.html`;
            } else if (notification.type === 'friend_accepted' && notification.senderId) {
                // Navigate to Chat.html to start chatting
                window.location.href = `/Chat.html?partnerId=${notification.senderId}`;
            } else {
                // For other types, navigate to notifications page
                window.location.href = `/notifications.html`;
            }
            
            // Hide dropdown
            hideNotificationDropdown();
        }

        /**
         * Marks a notification as read
         * @param {string} notificationId - The notification ID
         */
        async function markNotificationAsRead(notificationId) {
            if (!currentUser) return;
            
            try {
                const notificationRef = doc(db, "artifacts", appId, "users", currentUser.uid, "notifications", notificationId);
                await updateDoc(notificationRef, { read: true });
                console.log(`JCHAT_DEBUG: Marked notification ${notificationId} as read`);
            } catch (error) {
                console.error("JCHAT_ERROR: Error marking notification as read:", error);
            }
        }

        /**
         * Shows the notification dropdown
         */
        function showNotificationDropdown() {
            const dropdown = document.getElementById('notificationDropdown');
            if (dropdown) {
                dropdown.style.display = 'block';
                // Fetch recent notifications when dropdown is shown
                if (currentUser) {
                    fetchRecentNotifications(currentUser.uid);
                }
            }
        }

        /**
         * Hides the notification dropdown
         */
        function hideNotificationDropdown() {
            const dropdown = document.getElementById('notificationDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
        }

        /**
         * Formats a timestamp to "time ago" format
         * @param {Date} timestamp - The timestamp to format
         * @returns {string} Formatted time string
         */
        function formatTimeAgo(timestamp) {
            const now = new Date();
            const diffMs = now - timestamp;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            return timestamp.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        // --- Inspiration Quotes Display (No LLM) ---
        /**
         * Retrieves a random quote from the local inspirationalQuotes data based on type.
         * @param {string} type - The category of inspiration (e.g., "motivational").
         * @returns {object} A quote object with 'quote' and 'author' properties.
         */
        function getGeneratedQuote(type = "motivational") {
            if (Math.random() < 0.8) return generateProceduralQuote(type);
            const list = inspirationalQuotes[type] || inspirationalQuotes.motivational;
            return list[Math.floor(Math.random() * list.length)];
        }

        /**
         * Deterministic, time-based inspiration (no randomness).
         * Varies by weekday, month, and part of day. Updates every minute.
         */
        function pickDeterministic(arr, seed) {
            if (!arr || arr.length === 0) return '';
            const idx = Math.abs(seed) % arr.length;
            return arr[idx];
        }
        function getPartOfDay(h) {
            if (h >= 5 && h < 12) return 'morning';
            if (h >= 12 && h < 17) return 'afternoon';
            if (h >= 17 && h < 21) return 'evening';
            return 'night';
        }
        function selectTypeByTime() {
            const now = new Date();
            const weekday = now.getDay(); // 0-6
            const hour = now.getHours();
            const part = getPartOfDay(hour);
            if (part === 'evening' && (weekday === 5 || weekday === 6)) return 'love';
            if ((weekday === 0 && (part === 'evening' || part === 'night'))) return 'peaceful';
            const map = ['motivational','wisdom','love','peaceful','funny','motivational','funny'];
            return map[weekday] || 'motivational';
        }
        function generateTimeBasedQuote(preferredType) {
            const now = new Date();
            const type = preferredType && preferredType !== 'off' ? preferredType : selectTypeByTime();
            // Per-minute seed with user salt so each user gets a unique stream; changes every 60s
            const minuteIndex = Math.floor(Date.now() / 60000);
            const userSalt = (currentUser?.uid || 'guest').split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const typeSalt = Object.keys(inspirationLexicon).indexOf(type) + 1;
            const seed = minuteIndex * 131 + userSalt * 17 + typeSalt * 7;
            const lex = inspirationLexicon[type];
            if (lex) {
                const cap = s => s.charAt(0).toUpperCase() + s.slice(1);
                const a1 = pickDeterministic(lex.adjectives, seed + 11);
                const n1 = pickDeterministic(lex.nouns, seed + 13);
                const v1 = pickDeterministic(lex.verbs, seed + 17);
                const oAdj = pickDeterministic(lex.adjectives, seed + 19);
                const oObj = pickDeterministic(lex.objects, seed + 23);
                const adv = pickDeterministic(lex.adverbs, seed + 29);
                const close = pickDeterministic(lex.closers, seed + 31);
                const pattern = (seed % 3);
                let sentence;
                if (pattern === 0) {
                    sentence = `${cap(a1)} ${n1} ${v1} ${oAdj} ${oObj} ${adv}.`;
                } else if (pattern === 1) {
                    sentence = `${cap(v1)} ${oAdj} ${oObj} ${adv}; ${close}.`;
                } else {
                    sentence = `When ${a1} ${n1} ${v1} ${oObj}, ${close}.`;
                }
                return { quote: sentence, author: 'JCHAT' };
            }
            // Fallback to simple templates
            const t = quoteTemplates[type] || quoteTemplates.motivational;
            const open = pickDeterministic(t.openers, seed + 17);
            const bridge = pickDeterministic(t.bridges, seed + 31);
            const end = pickDeterministic(t.endings, seed + 53);
            return { quote: `${open}${bridge}${end}`, author: 'JCHAT' };
        }
        /**
         * Displays the time-based inspiration quote.
         */
        async function displayInspiration() {
            if (enableFixedInspirationOverride) {
                if (inspirationQuoteElement) inspirationQuoteElement.textContent = `"${fixedInspirationQuote}"`;
                if (inspirationAuthorElement) inspirationAuthorElement.textContent = `- ${fixedInspirationAuthor}`;
                return;
            }
            const chosen = (currentUserProfileData?.inspirationType) || null;
            if (chosen === 'off') {
                if (inspirationQuoteElement) inspirationQuoteElement.textContent = "Inspiration is turned off.";
                if (inspirationAuthorElement) inspirationAuthorElement.textContent = "";
                return;
            }
            const quoteData = generateTimeBasedQuote(chosen);
            if (inspirationQuoteElement) inspirationQuoteElement.textContent = `"${quoteData.quote}"`;
            if (inspirationAuthorElement) inspirationAuthorElement.textContent = `- ${quoteData.author}`;
        }

        /**
         * Starts the interval for displaying new inspiration quotes periodically.
         * @param {string} type - The inspiration type to display.
         */
        function startInspirationDisplay(type) {
            if (inspirationIntervalId) {
                clearInterval(inspirationIntervalId); // Clear any existing interval.
            }
            if (enableFixedInspirationOverride) {
                inspirationIntervalId = null; // Do not rotate when locked.
                displayInspiration();
                return;
            }
            if (currentUserProfileData) {
                currentUserProfileData.inspirationType = type; // Update local profile data.
            }
            displayInspiration(); // Display initial quote immediately.
            inspirationIntervalId = setInterval(displayInspiration, 60 * 1000); // Refresh every 1 minute.
        }

        /**
         * Opens the customization modal for daily inspiration.
         */
        function openCustomizeModal() {
            if (!isAuthReady) {
                showMessageBox("Please log in to customize inspiration.", 'error');
                return;
            }
            const currentType = currentUserProfileData?.inspirationType || "motivational";
            // Set the radio button corresponding to the current inspiration type.
            if (inspirationTypeRadios && typeof inspirationTypeRadios.forEach === 'function') {
                inspirationTypeRadios.forEach(radio => {
                    radio.checked = (radio.value === currentType);
                });
            }
            if (customizeInspirationModal) customizeInspirationModal.classList.add('active'); // Show modal.
        }
        /**
         * Closes the customization modal.
         */
        function closeCustomizeModal() {
            if (customizeInspirationModal) customizeInspirationModal.classList.remove('active');
        }
        /**
         * Saves the selected inspiration type to Firestore.
         */
        async function saveInspirationType() {
            if (!isAuthReady || !currentUser) {
                showMessageBox("You must be logged in to save settings.", 'error');
                return;
            }

            const selectedRadio = document.querySelector('input[name="inspirationType"]:checked');
            if (!selectedRadio) {
                showMessageBox("Please select an inspiration type.", 'info');
                return;
            }
            const newType = selectedRadio.value;

            try {
                const privateProfileDocRef = doc(db, "artifacts", appId, "users", currentUser.uid, "profiles", "user_profile");
                await updateDoc(privateProfileDocRef, {
                    inspirationType: newType,
                    updatedAt: serverTimestamp()
                });
                if (currentUserProfileData) {
                    currentUserProfileData.inspirationType = newType; // Update local state.
                }
                startInspirationDisplay(newType); // Restart inspiration display with new type.
                showMessageBox("Inspiration type saved!", 'success');
                closeCustomizeModal();
            } catch (error) {
                console.error("JCHAT_ERROR: Error saving inspiration type:", error);
                showMessageBox(`Failed to save inspiration type: ${error.message}`, 'error');
            }
        }
        // Event listener for post media upload input.
        if (postMediaUpload) {
            postMediaUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                currentMediaFile = file; // Store the selected file.
                // Reset previews.
                if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                if (mediaImagePreview) mediaImagePreview.src = '';
                if (mediaVideoPreview) mediaVideoPreview.src = '';

                if (file) {
                    const objectUrl = URL.createObjectURL(file);
                    if (file.type.startsWith('image/')) {
                        if (mediaImagePreview) {
                            mediaImagePreview.onload = () => URL.revokeObjectURL(objectUrl);
                            mediaImagePreview.src = objectUrl;
                            mediaImagePreview.style.display = 'block';
                        }
                    } else if (file.type.startsWith('video/')) {
                        if (mediaVideoPreview) {
                            const revoke = () => { URL.revokeObjectURL(objectUrl); mediaVideoPreview.removeEventListener('loadeddata', revoke); mediaVideoPreview.removeEventListener('loadedmetadata', revoke); };
                            mediaVideoPreview.addEventListener('loadeddata', revoke);
                            mediaVideoPreview.addEventListener('loadedmetadata', revoke);
                            mediaVideoPreview.src = objectUrl;
                            mediaVideoPreview.style.display = 'block';
                        }
                    }
                }
            });
        }

        /**
         * Creates a new post with content and optional media.
         * Handles media upload, Firestore transaction, and pending reward creation.
         */
        async function createNewPost() {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("Please log in to create a post.", 'error');
                return;
            }

            // Check if post creation is enabled by system settings (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post creation is currently disabled by administrators.", 'warning');
                return;
            }

            const content = postContentInput.value.trim();
            if (!content && !currentMediaFile) {
                showMessageBox("Post content or media cannot be empty.", 'info');
                return;
            }

            toggleButtonLoading(createPostButton, true); // Show loading spinner.
            showMessageBox("Creating post...", 'loading', true); // Show persistent loading message.

            let mediaUrl = null;
            let mediaType = 'text';

            try {
                if (currentMediaFile) {
                    showMessageBox('Uploading media...', 'loading', true);
                    let fileToUpload = currentMediaFile;
                    // Resize image files before upload for optimization when browser can decode them; otherwise fall back to original.
                    if (currentMediaFile.type.startsWith('image/')) {
                        const imgType = (currentMediaFile.type || '').toLowerCase();
                        if (isResizableImageType(imgType)) {
                            try {
                                fileToUpload = await resizeImage(currentMediaFile);
                            } catch (e) {
                                console.warn("Image resize failed, uploading original file instead:", e);
                                fileToUpload = currentMediaFile;
                            }
                        } else {
                            console.warn("Unsupported image type for in-browser resize; uploading original:", imgType);
                            fileToUpload = currentMediaFile;
                        }
                    }
                    mediaUrl = await uploadMediaToCloudinary(fileToUpload);
                    if (mediaUrl) {
                        mediaType = currentMediaFile.type.startsWith('image/') ? 'image' : 'video';
                        showMessageBox('Media uploaded!', 'success');
                    } else {
                        throw new Error("Failed to upload media."); // Throw error if Cloudinary upload fails.
                    }
                }

                // Poll handling
                const pollEnabled = !!document.getElementById('addPollCheckbox')?.checked;
                let poll = null;
                if (pollEnabled) {
                    const optionEls = [...document.querySelectorAll('#pollComposer .poll-option-input')];
                    const options = optionEls.map(o => o.value.trim()).filter(Boolean).slice(0,6);
                    if (options.length >= 2) {
                        poll = { options: options.map(o => ({ text:o, votes:0 })), allowMultiple:false };
                    }
                }

                const postData = {
                    authorId: currentUser.uid,
                    username: currentUserProfileData.username || "JCHAT User",
                    profilePhoto: currentUserProfileData.profilePicId || null,
                    content: content,
                    timestamp: serverTimestamp(),
                    likesCount: 0,
                    commentsCount: 0,
                    isEdited: false,
                    status: 'active',
                    reactions: { like: 0, love: 0, haha: 0 },
                    mediaUrl: mediaUrl,
                    mediaType: mediaType,
                    visibility: (document.getElementById('postVisibilitySelect')?.value || 'public'),
                    tags: [],
                    location: {},
                    poll: poll
                };

                let postId = null; // To store the ID of the newly created post.

                // Use a Firestore transaction to ensure atomicity for post creation.
                await runTransaction(db, async (transaction) => {
                    // Note: totalPosts update is removed here as it's now handled by admin approval of pending reward.
                    const newPostRef = doc(collection(db, "artifacts", appId, "public", "data", "posts"));
                    transaction.set(newPostRef, postData);
                    postId = newPostRef.id; // Get the ID of the new post.
                });

                // Create a pending reward for post creation for admin review.
                if (postId) {
                    const reward = await computeActivityReward('post_creation', { contentLen: content.length, mediaType, poll });
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        'post_creation',
                        reward.xp,
                        reward.jc,
                        null,
                        postId
                    );
                    incrementDailyActivityCount('post');
                    showMessageBox(`Post created! +${reward.xp} XP and +${reward.jc} JCoins pending admin review.`, 'success', true);
                }
                playNotificationSound('success');
                // Clear input fields and previews after successful post creation.
                postContentInput.value = '';
                if (postMediaUpload) postMediaUpload.value = '';
                if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                if (mediaImagePreview) mediaImagePreview.src = '';
                if (mediaVideoPreview) mediaVideoPreview.src = '';
                currentMediaFile = null;

            } catch (error) {
                console.error("JCHAT_ERROR: Error creating post:", error);
                showMessageBox(`Failed to create post: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(createPostButton, false); // Hide loading spinner.
            }
        }
        /**
         * Handles user reactions (like, love, haha) to a post.
         * Uses a transaction to update reaction counts and user's reaction status.
         * Creates a pending reward for the reaction.
         * @param {string} postId - The ID of the post being reacted to.
         * @param {string} reactionType - The type of reaction ('like', 'love', 'haha').
         */
        async function handleReaction(postId, reactionType) {
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("You must be logged in to react.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled by system settings (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Reactions are currently disabled by administrators.", 'warning');
                return;
            }

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
            const userReactionRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "userReactions", currentUser.uid);

            try {
                let xpReward = 0;
                let jCoinReward = 0;
                let activityType = '';

                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    const userReactionDoc = await transaction.get(userReactionRef);

                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    const postData = postDoc.data();
                    let serverReactions = postData.reactions || { like: 0, love: 0, haha: 0 };
                    let serverLikesCount = postData.likesCount || 0;
                    let serverUserPreviousReaction = userReactionDoc.exists() ? userReactionDoc.data().type : null;

                    if (serverUserPreviousReaction === reactionType) {
                        // User is un-reacting: decrement count, delete user reaction document.
                        serverReactions[reactionType] = Math.max(0, serverReactions[reactionType] - 1);
                        if (reactionType === 'like') serverLikesCount = Math.max(0, serverLikesCount - 1);
                        transaction.delete(userReactionRef);
                        activityType = `unreact_${reactionType}`;
                        const neg = await computeActivityReward(activityType, { reactionType, isUndo:true });
                        xpReward = neg.xp; jCoinReward = neg.jc;
                    } else {
                        // User is reacting or changing reaction:
                        // If there was a previous reaction, decrement its count.
                        if (serverUserPreviousReaction) {
                            serverReactions[serverUserPreviousReaction] = Math.max(0, serverReactions[serverUserPreviousReaction] - 1);
                            if (serverUserPreviousReaction === 'like') serverLikesCount = Math.max(0, serverLikesCount - 1);
                        }
                        // Increment the new reaction type's count.
                        serverReactions[reactionType] = (serverReactions[reactionType] || 0) + 1;
                        if (reactionType === 'like') serverLikesCount = (serverLikesCount || 0) + 1;

                        // Set/update the user's reaction document.
                        transaction.set(userReactionRef, { type: reactionType, userId: currentUser.uid, timestamp: serverTimestamp() });
                        activityType = `react_${reactionType}`;
                        const pos = await computeActivityReward(activityType, { reactionType });
                        xpReward = pos.xp; jCoinReward = pos.jc;
                    }

                    // Update the post document with new reaction counts.
                    transaction.update(postRef, {
                        reactions: serverReactions,
                        likesCount: serverLikesCount,
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for the reaction (or deduction for un-reaction).
                if (xpReward !== 0 || jCoinReward !== 0) {
                    incrementDailyActivityCount('reaction');
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        activityType,
                        xpReward,
                        jCoinReward,
                        null,
                        postId
                    );
                }

                showMessageBox(`Reaction recorded! ${xpReward} XP and ${jCoinReward} JCoins pending admin review.`, 'success');
                playNotificationSound('info');
            } catch (error) {
                console.error("JCHAT_ERROR: Error handling reaction (Firestore update failed):", error);
                showMessageBox(`Failed to update reaction: ${error.message}. Please refresh.`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Adds a new comment to a post.
         * Uses a transaction to update comment count on the post.
         * Creates a pending reward for the comment.
         * @param {string} postId - The ID of the post to comment on.
         * @param {string} commentText - The content of the comment.
         */
        async function addComment(postId, commentText) {
            const replyingTo = (addComment.replyContext && addComment.replyContext.postId===postId) ? addComment.replyContext.commentId : null;
            if (!isAuthReady || !currentUser || !currentUserProfileData) {
                showMessageBox("You must be logged in to comment.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Commenting is currently disabled by administrators.", 'warning');
                return;
            }

            if (!commentText.trim()) {
                showMessageBox("Comment cannot be empty.", 'info');
                return;
            }

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
            const commentsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts", postId, "comments");

            try {
                let commentId = null;
                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    const newCommentRef = doc(commentsCollectionRef); // Create a new document reference for the comment.
                    const newComment = {
                        userId: currentUser.uid,
                        username: currentUserProfileData.username || "JCHAT User",
                        profilePhoto: currentUserProfileData.profilePicId || null,
                        content: commentText.trim(),
                        timestamp: serverTimestamp(),
                        replyingTo: replyingTo || null
                    };
                    transaction.set(newCommentRef, newComment); // Set the new comment data.
                    commentId = newCommentRef.id; // Get the ID of the new comment.

                    const currentCommentsCount = postDoc.data().commentsCount || 0;
                    transaction.update(postRef, {
                        commentsCount: currentCommentsCount + 1, // Increment comments count on the post.
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for the comment for admin review.
                if (commentId) {
                    const reward = await computeActivityReward('post_comment', { contentLen: commentText.length, isReply: !!replyingTo, isFirstOnPost: wasFirstComment });
                    await createPendingActivityReward(
                        currentUser.uid,
                        currentUserProfileData.username,
                        'post_comment',
                        reward.xp,
                        reward.jc,
                        commentId,
                        postId
                    );
                    incrementDailyActivityCount('comment');
                }

                addComment.replyContext = null;
                // Show result using computed reward
                if (typeof computeActivityReward === 'function') {
                    const reward = await computeActivityReward('post_comment', { contentLen: commentText.length, isReply: !!replyingTo, isFirstOnPost: wasFirstComment });
                    showMessageBox(`Comment added! +${reward.xp} XP and +${reward.jc} JCoins pending admin review.`, 'success');
                } else {
                    showMessageBox('Comment added! Pending admin review.', 'success');
                }
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error adding comment:", error);
                showMessageBox(`Failed to add comment: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Deletes a comment from a post.
         * Only the comment author or an admin can delete a comment.
         * Uses a transaction to decrement comment count on the post.
         * Creates a pending reward for the deletion (negative XP/JCoins).
         * @param {string} postId - The ID of the post the comment belongs to.
         * @param {string} commentId - The ID of the comment to delete.
         * @param {string} commentAuthorId - The ID of the user who authored the comment.
         */
        async function deleteComment(postId, commentId, commentAuthorId) {
            // Check permissions: current user must be the comment author or an admin.
            if (!isAuthReady || !currentUser || (currentUser.uid !== commentAuthorId && currentUser.uid !== ADMIN_UID)) {
                showMessageBox("You can only delete your own comments unless you are an admin.", 'error');
                return;
            }
            // Check if public chat/interactions are enabled (unless current user is admin).
            if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Commenting is currently disabled by administrators, so deletion is also restricted.", 'warning');
                return;
            }

            // Show confirmation modal before proceeding with deletion.
            const confirmed = await showConfirmationModal(
                "Delete Comment",
                "Are you sure you want to delete this comment? This action cannot be undone."
            );
            if (!confirmed) {
                return;
            }

            showMessageBox("Deleting comment...", 'loading', true);

            const commentRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "comments", commentId);
            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);

            try {
                await runTransaction(db, async (transaction) => {
                    const postDoc = await transaction.get(postRef);
                    if (!postDoc.exists()) {
                        throw new Error("Post does not exist.");
                    }

                    transaction.delete(commentRef); // Delete the comment document.

                    const currentCommentsCount = postDoc.data().commentsCount || 0;
                    transaction.update(postRef, {
                        commentsCount: Math.max(0, currentCommentsCount - 1), // Decrement comments count.
                        updatedAt: serverTimestamp()
                    });
                });

                // Create a pending reward for comment deletion (negative XP/JCoins).
                const pen = await computeActivityReward('comment_deletion');
                await createPendingActivityReward(
                    commentAuthorId, // The user who originally posted the comment.
                    currentUserProfileData.username, // Using current user's username for logging purposes.
                    'comment_deletion',
                    pen.xp,
                    pen.jc,
                    commentId,
                    postId
                );

                showMessageBox("Comment deleted successfully!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting comment:", error);
                showMessageBox(`Failed to delete comment: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }

        /**
         * Opens the edit post modal and populates it with existing post data.
         * @param {string} postId - The ID of the post to edit.
         * @param {string} currentContent - The current text content of the post.
         * @param {string|null} currentMediaUrl - The current media URL of the post.
         * @param {string} currentMediaType - The current media type of the post ('image', 'video', 'text').
         */
        async function openEditPostModal(postId, currentContent, currentMediaUrl, currentMediaType, currentVisibility) {
            if (!isAuthReady || !currentUser) {
                showMessageBox("You must be logged in to edit posts.", 'error');
                return;
            }
            // Check if post creation (and thus editing) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post editing is currently disabled by administrators.", 'warning');
                return;
            }

            // Verify ownership from Firestore to prevent editing others' posts
            try {
                const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);
                const postSnap = await getDoc(postRef);
                if (!postSnap.exists() || postSnap.data().authorId !== currentUser.uid) {
                    showMessageBox("You can only edit your own post.", 'error');
                    return;
                }
            } catch (e) {
                console.error('JCHAT_ERROR: Failed to verify post ownership before editing:', e);
                showMessageBox('Unable to verify post ownership. Please try again.', 'error');
                return;
            }

            currentEditPostId = postId;
            if (editPostContentInput) editPostContentInput.value = currentContent;
            currentEditMediaUrl = currentMediaUrl;
            currentEditMediaType = currentMediaType;
            const visSel = document.getElementById('editPostVisibilitySelect');
            if (visSel) visSel.value = (currentVisibility || 'public');
            currentEditMediaFile = null; // Clear any previously selected new media file.

            // Reset media previews and remove media button.
            if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
            if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.src = '';
            if (editMediaVideoPreview) editMediaVideoPreview.src = '';
            if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

            // Display existing media if available.
            if (currentMediaUrl) {
                if (currentMediaType === 'image') {
                    if (editMediaImagePreview) {
                        editMediaImagePreview.src = currentMediaUrl;
                        editMediaImagePreview.style.display = 'block';
                    }
                } else if (currentMediaType === 'video') {
                    if (editMediaVideoPreview) {
                        editMediaVideoPreview.src = currentMediaUrl;
                        editMediaVideoPreview.style.display = 'block';
                    }
                }
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'inline-block'; // Show remove media button.
            }

            if (editPostModal) editPostModal.classList.add('active'); // Show edit modal.
        }

        // Event listener for edit post media upload input.
        if (editPostMediaUpload) {
            editPostMediaUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                currentEditMediaFile = file; // Store the newly selected file.
                // Reset previews and hide remove media button.
                if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                if (editMediaImagePreview) editMediaImagePreview.src = '';
                if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

                if (file) {
                    const objectUrl = URL.createObjectURL(file);
                    if (file.type.startsWith('image/')) {
                        if (editMediaImagePreview) {
                            editMediaImagePreview.onload = () => URL.revokeObjectURL(objectUrl);
                            editMediaImagePreview.src = objectUrl;
                            editMediaImagePreview.style.display = 'block';
                        }
                    } else if (file.type.startsWith('video/')) {
                        if (editMediaVideoPreview) {
                            const revoke = () => { URL.revokeObjectURL(objectUrl); editMediaVideoPreview.removeEventListener('loadeddata', revoke); editMediaVideoPreview.removeEventListener('loadedmetadata', revoke); };
                            editMediaVideoPreview.addEventListener('loadeddata', revoke);
                            editMediaVideoPreview.addEventListener('loadedmetadata', revoke);
                            editMediaVideoPreview.src = objectUrl;
                            editMediaVideoPreview.style.display = 'block';
                        }
                    }
                }
            });
        }

        // Event listener for removing media from an edited post.
        if (removeEditMediaButton) {
            removeEditMediaButton.addEventListener('click', () => {
                currentEditMediaFile = null;
                currentEditMediaUrl = null;
                currentEditMediaType = 'text';
                // Clear and hide all media related elements.
                if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                if (editMediaImagePreview) editMediaImagePreview.src = '';
                if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                if (editPostMediaUpload) editPostMediaUpload.value = ''; // Clear file input.
                if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
                showMessageBox("Media removed.", "info");
            });
        }
        /**
         * Saves the changes made to an edited post.
         * Handles new media upload, updates Firestore, and shows messages.
         */
        async function saveEditedPost() {
            if (!isAuthReady || !currentUser || !currentEditPostId) {
                showMessageBox("No post selected for editing.", 'error');
                return;
            }
            // Check if post creation (and thus editing) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post editing is currently disabled by administrators.", 'warning');
                return;
            }

            // Ensure only the post owner can save edits
            try {
                const postRefCheck = doc(db, "artifacts", appId, "public", "data", "posts", currentEditPostId);
                const postSnapCheck = await getDoc(postRefCheck);
                if (!postSnapCheck.exists() || postSnapCheck.data().authorId !== currentUser.uid) {
                    showMessageBox("You can only edit your own post.", 'error');
                    return;
                }
            } catch (e) {
                console.error('JCHAT_ERROR: Ownership re-check failed on save:', e);
                showMessageBox('Unable to verify post ownership. Please try again.', 'error');
                return;
            }

            const newContent = editPostContentInput.value.trim();
            if (!newContent && !currentEditMediaFile && !currentEditMediaUrl) {
                showMessageBox("Post content or media cannot be empty.", 'info');
                return;
            }

            toggleButtonLoading(saveEditedPostButton, true); // Show loading spinner.
            showMessageBox("Saving changes...", 'loading', true); // Show persistent loading message.

            let finalMediaUrl = currentEditMediaUrl;
            let finalMediaType = currentEditMediaType;

            try {
                if (currentEditMediaFile) {
                    showMessageBox('Uploading new media...', 'loading', true);
                    let fileToUpload = currentEditMediaFile;
                    // Resize image files before upload when browser can decode them; otherwise fall back to original.
                    if (currentEditMediaFile.type.startsWith('image/')) {
                        const imgType = (currentEditMediaFile.type || '').toLowerCase();
                        if (isResizableImageType(imgType)) {
                            try {
                                fileToUpload = await resizeImage(currentEditMediaFile);
                            } catch (e) {
                                console.warn("Image resize failed, uploading original file instead:", e);
                                fileToUpload = currentEditMediaFile;
                            }
                        } else {
                            console.warn("Unsupported image type for in-browser resize; uploading original:", imgType);
                            fileToUpload = currentEditMediaFile;
                        }
                    }
                    finalMediaUrl = await uploadMediaToCloudinary(fileToUpload);
                    if (finalMediaUrl) {
                        finalMediaType = currentEditMediaFile.type.startsWith('image/') ? 'image' : 'video';
                        showMessageBox('New media uploaded!', 'success');
                    } else {
                        throw new Error("Failed to upload new media.");
                    }
                } else if (!currentEditMediaUrl && !currentEditMediaFile) {
                    // If no existing media and no new media, set to null/text.
                    finalMediaUrl = null;
                    finalMediaType = 'text';
                }

                const postRef = doc(db, "artifacts", appId, "public", "data", "posts", currentEditPostId);
                await updateDoc(postRef, {
                    content: newContent,
                    mediaUrl: finalMediaUrl,
                    mediaType: finalMediaType,
                    visibility: (document.getElementById('editPostVisibilitySelect')?.value || 'public'),
                    isEdited: true, // Mark post as edited.
                    updatedAt: serverTimestamp()
                });

                showMessageBox("Post updated successfully!", 'success');
                playNotificationSound('success');
                closeEditPostModal(); // Close the modal after successful save.
            } catch (error) {
                console.error("JCHAT_ERROR: Error saving edited post:", error);
                showMessageBox(`Failed to save changes: ${error.message}`, 'error');
                playNotificationSound('error');
            } finally {
                toggleButtonLoading(saveEditedPostButton, false); // Hide loading spinner.
            }
        }

        /**
         * Closes the edit post modal and resets its fields.
         */
        function closeEditPostModal() {
            if (editPostModal) editPostModal.classList.remove('active');
            if (editPostContentInput) editPostContentInput.value = '';
            if (editPostMediaUpload) editPostMediaUpload.value = '';
            if (mediaImagePreview) mediaImagePreview.style.display = 'none';
            if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
            if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
            if (editMediaImagePreview) editMediaImagePreview.src = '';
            if (editMediaVideoPreview) editMediaVideoPreview.src = '';
            if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
            // Reset global state variables for editing.
            currentEditPostId = null;
            currentEditMediaFile = null;
            currentEditMediaUrl = null;
            currentEditMediaType = null;
        }

        // The deletePost function is no longer called from the UI, but it's kept here just in case it's needed elsewhere.
        /**
         * Deletes a post from Firestore.
         * Only the post author or an admin can delete a post.
         * Creates a pending reward for the deletion (negative XP/JCoins).
         * @param {string} postId - The ID of the post to delete.
         * @param {string} postAuthorId - The ID of the user who authored the post.
         */
        async function deletePost(postId, postAuthorId) {
            // Check permissions: current user must be the post author or an admin.
            if (!isAuthReady || !currentUser || (currentUser.uid !== postAuthorId && currentUser.uid !== ADMIN_UID)) {
                showMessageBox("You can only delete your own posts unless you are an admin.", 'error');
                return;
            }
            // Check if post creation (and thus deletion) is enabled (unless current user is admin).
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) {
                showMessageBox("Post deletion is currently disabled by administrators.", 'warning');
                return;
            }

            // Show confirmation modal before proceeding.
            const confirmed = await showConfirmationModal(
                "Delete Post",
                "Are you sure you want to delete this post? This action cannot be undone."
            );
            if (!confirmed) {
                return;
            }

            showMessageBox("Deleting post...", 'loading', true);

            const postRef = doc(db, "artifacts", appId, "public", "data", "posts", postId);

            try {
                await runTransaction(db, async (transaction) => {
                    transaction.delete(postRef); // Delete the post document.
                });

                // Create a pending reward for post deletion (negative XP/JCoins).
                const penDel = await computeActivityReward('post_deletion');
                await createPendingActivityReward(
                    postAuthorId, // The user who originally posted.
                    currentUserProfileData.username, // Using current user's username for logging purposes.
                    'post_deletion',
                    penDel.xp,
                    penDel.jc,
                    null,
                    postId
                );

                showMessageBox("Post deleted successfully!", 'success');
                playNotificationSound('success');
            } catch (error) {
                console.error("JCHAT_ERROR: Error deleting post:", error);
                showMessageBox(`Failed to delete post: ${error.message}`, 'error');
                playNotificationSound('error');
            }
        }
        /**
         * Renders a single post HTML element.
         * @param {object} post - The post data object from Firestore.
         * @param {string} postId - The ID of the post.
         * @returns {HTMLElement} The created post HTML element.
         */
        function renderPost(post, postId) {
            const isAuthor = currentUser && currentUser.uid === post.authorId;
            const authorInitial = (post.username || 'J').charAt(0).toUpperCase();

            const postElement = document.createElement('div');
            postElement.classList.add('post-card');
            postElement.setAttribute('data-post-id', postId);

            // Construct the inner HTML for the post card.
            postElement.innerHTML = `
                <div class="post-header">
                    <a href="/Profile.html?userId=${post.authorId}" aria-label="View ${post.username || 'Anonymous'}'s Profile">
                        <div class="author-pic-wrapper">
                            ${post.profilePhoto ?
                                `<img src="${getCloudinaryImageUrl(post.profilePhoto, 'w_80,h_80,c_fill,g_face,r_max')}" alt="Author Pic" class="author-pic" loading="lazy" decoding="async" onerror="this.onerror=null; this.src='https://placehold.co/80x80/CCCCCC/000000?text=${authorInitial}';">` :
                                `<i class="fas fa-user-circle author-pic-placeholder" role="img" aria-label="Author Avatar"></i>`
                            }
                        </div>
                    </a>
                    <div class="author-info">
                        <a href="/Profile.html?userId=${post.authorId}" class="author-name">${post.username || 'Anonymous'}</a>
                        <p class="post-timestamp">${post.timestamp ? new Date(post.timestamp.toDate()).toLocaleString() : 'N/A'} ${post.isEdited ? '(Edited)' : ''}</p>
                    </div>
                    <div class="post-visibility-badge" title="${post.visibility || 'public'}">${(post.visibility||'public')==='public' ? '<i class=\'fas fa-globe\'></i> Public' : (post.visibility==='friends' ? '<i class=\'fas fa-user-friends\'></i> Friends' : '<i class=\'fas fa-lock\'></i> Only me')}</div>
                    ${isAuthor ? `
                    <button class="post-options-button" data-post-id="${postId}" data-author-id="${post.authorId}" data-timestamp="${post.timestamp ? post.timestamp.toDate().getTime() : 0}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation) ? 'disabled' : ''} aria-label="Post Options">
                        <i class="fas fa-ellipsis-h"></i>
                    </button>
                    <div class="post-options-dropdown" id="dropdown-${postId}">
                        <button class="edit-post-button" data-post-id="${postId}" data-author-id="${post.authorId}" data-content="${post.content}" data-media-url="${post.mediaUrl || ''}" data-media-type="${post.mediaType || 'text'}" data-visibility="${post.visibility || 'public'}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation) ? 'disabled' : ''} aria-label="Edit Post">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="delete-post-button" data-post-id="${postId}" data-author-id="${post.authorId}" style="display:none;" aria-label="Delete Post">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                        <button class="share-post-button" data-post-id="${postId}" data-content="${post.content}" ${!isAuthReady || (!currentSystemSettings.enablePostCreation) ? 'disabled' : ''} aria-label="Share Post">
                            <i class="fas fa-share"></i> Share
                        </button>
                        <button class="add-to-highlights-button" data-post-id="${postId}" ${!isAuthReady ? 'disabled' : ''} aria-label="Add to Highlights">
                            <i class="fas fa-bookmark"></i> Add to Highlights
                        </button>
                    </div>
                    ` : ''}
                </div>
                <div class="post-content-text">
                    <p>${post.content}</p>
                </div>
                ${post.poll && post.poll.options ? `
                <div class="post-poll" data-post-id="${postId}">
                    ${post.poll.options.map((opt, i)=>`<button class=\"poll-vote-button\" data-post-id=\"${postId}\" data-index=\"${i}\">${opt.text} — <span class=\"poll-votes\">${opt.votes||0}</span></button>`).join('')}
                </div>` : ''}
                ${post.mediaUrl ? `
                <div class="post-media">
                    ${post.mediaType === 'image' ?
                        `<img src="${post.mediaUrl}" alt="Post Media" onerror="this.style.display='none';">` :
                        `<video src="${post.mediaUrl}" controls onerror="this.style.display='none';"></video>`
                    }
                </div>` : ''}
                <div class="post-reactions-summary">
                    <span>
                        <i class="fas fa-thumbs-up" style="color:var(--blue);"></i> <span class="like-count">${post.reactions?.like || 0}</span>
                        <i class="fas fa-heart" style="color:var(--pink);"></i> <span class="love-count">${post.reactions?.love || 0}</span>
                        <i class="fas fa-face-laugh" style="color:#ffd700;"></i> <span class="haha-count">${post.reactions?.haha || 0}</span>
                    </span>
                    <span><span class="comments-count">${post.commentsCount || 0}</span> Comments</span>
                </div>
                <div class="post-actions-row">
                    <button class="post-action-button save-post-button" data-post-id="${postId}" aria-label="Save Post">
                        <i class="fas fa-bookmark"></i> Save
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="like" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Like Post">
                        <i class="fas fa-thumbs-up"></i> Like
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="love" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Love Post">
                        <i class="fas fa-heart"></i> Love
                    </button>
                    <button class="post-action-button react-button" data-post-id="${postId}" data-reaction-type="haha" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Haha Post">
                        <i class="fas fa-face-laugh"></i> Haha
                    </button>
                    <button class="post-action-button comment-toggle-button" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Toggle Comments">
                        <i class="fas fa-comment"></i> Comment
                    </button>
                </div>
                <div class="comments-section" style="display:none;">
                    <div class="comments-list" id="comments-list-${postId}">
                        <p style="font-size:0.85rem; color:var(--text-light); text-align:left; margin-left:10px;" class="no-comments-message">No comments yet.</p>
                    </div>
                    <div class="comment-input-area">
                        <textarea placeholder="Write a comment..." class="comment-input" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Write a comment"></textarea>
                        <button class="submit-comment-button" data-post-id="${postId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Post Comment">Post</button>
                    </div>
                </div>
            `;
            return postElement;
        }
        /**
         * Renders a single comment HTML element.
         * @param {object} comment, commentId, postId
         * @returns {HTMLElement} The created comment HTML element.
         */
        function renderComment(comment, commentId, postId) {
            const commentAuthorInitial = (comment.username || 'J').charAt(0).toUpperCase();
            const isCommentOwner = currentUser && currentUser.uid === comment.userId;

            const commentElement = document.createElement('div');
            commentElement.classList.add('comment-item');
            commentElement.setAttribute('data-comment-id', commentId);
            if (comment.replyingTo) commentElement.setAttribute('data-reply', 'true');
            commentElement.innerHTML = `
                <a href="./Profile.html?userId=${comment.userId}" aria-label="View ${comment.username || 'Anonymous'}'s Profile">
                    <div class="author-pic-wrapper" style="width:30px; height:30px; border-width:1px;">
                        ${comment.profilePhoto ?
                            `<img src="${getCloudinaryImageUrl(comment.profilePhoto, 'w_60,h_60,c_fill,g_face,r_max')}" alt="Author Pic" class="comment-author-pic" loading="lazy" decoding="async" onerror="this.onerror=null; this.src='https://placehold.co/60x60/CCCCCC/000000?text=${commentAuthorInitial}';">` :
                            `<i class="fas fa-user-circle comment-author-pic-placeholder" style="font-size:30px;" role="img" aria-label="Comment Author Avatar"></i>`
                        }
                    </div>
                </a>
                <div class="comment-content-wrapper">
                    <a href="./Profile.html?userId=${comment.userId}" class="comment-author-name">${comment.username || 'Anonymous'}</a>
                    <span class="comment-text">${comment.content}</span>
                    <span class="comment-timestamp">${comment.timestamp ? new Date(comment.timestamp.toDate()).toLocaleString() : 'N/A'}</span>
                    <div class="comment-actions" style="display:inline-flex; gap:8px; margin-left:10px; align-items:center;">
                        <button class="comment-reply-button" data-post-id="${postId}" data-comment-id="${commentId}"><i class="fas fa-reply"></i> Reply</button>
                        <button class="comment-like-button" data-post-id="${postId}" data-comment-id="${commentId}"><i class="fas fa-thumbs-up"></i> <span class="comment-like-count">${comment.likes||0}</span></button>
                        <div class="comment-reactions-bar" aria-label="React to comment">
                            <button class="comment-reaction-button" data-type="like" data-post-id="${postId}" data-comment-id="${commentId}">👍</button>
                            <button class="comment-reaction-button" data-type="love" data-post-id="${postId}" data-comment-id="${commentId}">❤️</button>
                            <button class="comment-reaction-button" data-type="haha" data-post-id="${postId}" data-comment-id="${commentId}">😂</button>
                        </div>
                        <div class="comment-reactions-summary">
                            <span data-type="like">👍 <span class="count">${comment.reactions?.like||0}</span></span>
                            <span data-type="love">��️ <span class="count">${comment.reactions?.love||0}</span></span>
                            <span data-type="haha">😂 <span class="count">${comment.reactions?.haha||0}</span></span>
                        </div>
                    </div>
                    ${isCommentOwner || (currentUser && currentUser.uid === ADMIN_UID) ? `<button class="delete-comment-button" data-post-id="${postId}" data-comment-id="${commentId}" data-comment-author-id="${comment.userId}" ${!isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) || (!isCommentOwner && currentUser.uid !== ADMIN_UID) ? 'disabled' : ''} aria-label="Delete Comment"><i class="fas fa-trash-alt"></i></button>` : ''}
                </div>
            `;
            return commentElement;
        }
        /**
         * Fetches and displays posts in real-time using Firestore onSnapshot.
         * Manages post and comment listeners, and updates the UI dynamically.
         */
        let myFriendsForFeed = new Set();
async function loadMyFriendsForFeed() {
    try {
        myFriendsForFeed = new Set();
        if (!currentUser) return;
        const publicFriendsRef = collection(db, 'artifacts', appId, 'public', 'data', 'friends');
        const snap = await getDocs(publicFriendsRef);
        snap.forEach(d => {
            const f = d.data();
            if (f.user1Id === currentUser.uid) myFriendsForFeed.add(f.user2Id);
            else if (f.user2Id === currentUser.uid) myFriendsForFeed.add(f.user1Id);
        });
    } catch(_) { myFriendsForFeed = new Set(); }
}
async function fetchAndDisplayPosts() {
            console.log("JCHAT_DEBUG: fetchAndDisplayPosts called. isAuthReady:", isAuthReady);
            if (loadingPostsMessage) loadingPostsMessage.style.display = 'block'; // Show loading message.

            // Detach previous listeners to prevent memory leaks and duplicate updates.
            unsubscribeListeners.forEach(unsubscribe => {
                if (typeof unsubscribe === 'function') {
                    unsubscribe();
                }
            });
            unsubscribeListeners = []; // Clear the array of unsubscribe functions.
            if (postsFeed) postsFeed.innerHTML = ''; // Clear existing posts from the DOM.

            if (!postsFeed) {
                console.error("JCHAT_CRITICAL_ERROR: 'postsFeed' element not found in the DOM. Cannot display posts.");
                const mainContent = document.querySelector('main .content-wrapper');
                if (mainContent) {
                    mainContent.innerHTML = '<p style="text-align: center; color: var(--text-light); font-size: 1.1rem;">An error occurred loading content. Please refresh the page.</p>';
                }
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                return;
            }
            try {
                await loadMyFriendsForFeed();
                const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
                const q = query(postsCollectionRef, orderBy("timestamp", "desc")); // Order posts by timestamp descending.

                // Set up real-time listener for posts.
                const unsubscribePosts = onSnapshot(q, (querySnapshot) => {
                    console.log("JCHAT_DEBUG: onSnapshot for posts triggered. Number of posts:", querySnapshot.size);
                    const currentPostElements = new Map(); // Map to store current DOM elements by postId for efficient updates.
                    postsFeed.querySelectorAll('.post-card').forEach(card => {
                        currentPostElements.set(card.dataset.postId, card);
                    });

                    // Read filters
                    const typeFilter = postTypeFilter?.value || 'all';
                    const textSearch = (postSearchInput?.value || '').toLowerCase();
                    const fromDate = postDateFromInput?.value ? new Date(postDateFromInput.value + 'T00:00:00') : null;
                    const toDate = postDateToInput?.value ? new Date(postDateToInput.value + 'T23:59:59.999') : null;
                    const savedOnly = !!(showSavedOnlyCheckbox && showSavedOnlyCheckbox.checked);
                    const followedOnly = !!(showFollowedOnlyCheckbox && showFollowedOnlyCheckbox.checked);
                    const followedSet = new Set(JSON.parse(localStorage.getItem('jchat_followed_tags')||'[]').map(t=>t.toLowerCase()));

                    const newOrderedPostIds = []; // To maintain the correct order of posts in the DOM.

                    querySnapshot.forEach(docSnapshot => {
                        const post = docSnapshot.data();
                        const postId = docSnapshot.id;

                        // Client-side filter
                        if (typeFilter !== 'all') {
                            const pType = post.mediaType ? post.mediaType : 'text';
                            if (pType !== typeFilter) return;
                        }
                        if (textSearch && !(post.content || '').toLowerCase().includes(textSearch)) return;
                        if (followedOnly) {
                            const tags = ((post.content||'').match(/#\w{2,30}/g)||[]).map(t=>t.toLowerCase());
                            if (!tags.some(t=>followedSet.has(t))) return;
                        }
                        const ts = post.timestamp ? post.timestamp.toDate() : null;
                        if (fromDate && (!ts || ts < fromDate)) return;
                        if (toDate && (!ts || ts > toDate)) return;
                        if (savedOnly) {
                            const savedState = localStorage.getItem(`saved-post-${postId}`) === '1';
                            if (!savedState) return;
                        }
                        const vis = (post.visibility||'public');
                        if (vis === 'private' && (!currentUser || currentUser.uid !== post.authorId)) return;
                        if (vis === 'friends' && (!currentUser || (currentUser.uid !== post.authorId && !myFriendsForFeed.has(post.authorId)))) return;

                        newOrderedPostIds.push(postId);

                        if (!postId) {
                            console.error("JCHAT_DEBUG: postId is undefined for a document snapshot. Skipping post.", docSnapshot.id);
                            return;
                        }

                        let postElement = currentPostElements.get(postId);

                        if (postElement) {
                            // If post already exists in DOM, update its content.
                            const contentP = postElement.querySelector('.post-content-text p');
                            if (contentP) contentP.textContent = post.content;

                            let postMediaDiv = postElement.querySelector('.post-media');
                            if (post.mediaUrl) {
                                if (!postMediaDiv) {
                                    postMediaDiv = document.createElement('div');
                                    postMediaDiv.classList.add('post-media');
                                    postElement.insertBefore(postMediaDiv, postElement.querySelector('.post-reactions-summary'));
                                }
                                postMediaDiv.innerHTML = post.mediaType === 'image' ?
                                    `<img src="${post.mediaUrl}" alt="Post Media" loading="lazy" decoding="async" onerror="this.style.display='none';">` :
                                    `<video src="${post.mediaUrl}" controls preload="metadata" playsinline onerror="this.style.display='none';"></video>`;
                                postMediaDiv.style.display = 'block';
                            } else if (postMediaDiv) {
                                postMediaDiv.remove(); // Remove media div if media was removed from post.
                            }

                            const timestampElement = postElement.querySelector('.post-timestamp');
                            if (timestampElement) {
                                timestampElement.textContent = `${post.timestamp ? new Date(post.timestamp.toDate()).toLocaleString() : 'N/A'} ${post.isEdited ? '(Edited)' : ''}`;
                            }

                            // Update reactions summary counts.
                            const summaryLikeCountElement = postElement.querySelector('.post-reactions-summary .like-count');
                            const summaryLoveCountElement = postElement.querySelector('.post-reactions-summary .love-count');
                            const summaryHahaCountElement = postElement.querySelector('.post-reactions-summary .haha-count');
                            if (summaryLikeCountElement) summaryLikeCountElement.textContent = post.reactions?.like || 0;
                            if (summaryLoveCountElement) summaryLoveCountElement.textContent = post.reactions?.love || 0;
                            if (summaryHahaCountElement) summaryHahaCountElement.textContent = post.reactions?.haha || 0;

                            // Update comments count.
                            const commentsCountElement = postElement.querySelector('.post-reactions-summary .comments-count');
                            if (commentsCountElement) commentsCountElement.textContent = post.commentsCount || 0;

                        } else {
                            // If post is new, create and append a new element.
                            postElement = renderPost(post, postId);
                            postsFeed.appendChild(postElement); // Add to DOM.
                        }

                        // Always ensure comment inputs and buttons are enabled/disabled based on current auth state and system settings.
                        const commentInput = postElement.querySelector('.comment-input');
                        const submitCommentButton = postElement.querySelector('.submit-comment-button');
                        if (commentInput) commentInput.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID);
                        if (submitCommentButton) submitCommentButton.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID);

                        // Setup onSnapshot for comments for this specific post.
                        const commentsListElement = document.getElementById(`comments-list-${postId}`);
                        if (commentsListElement && !commentsListElement.dataset.listenerAttached) { // Prevent attaching multiple listeners.
                            const commentsQuery = query(
                                collection(db, "artifacts", appId, "public", "data", "posts", postId, "comments"),
                                orderBy("timestamp", "asc")
                            );
                            const unsubscribeComments = onSnapshot(commentsQuery, (commentsSnapshot) => {
                                if (!commentsListElement) {
                                    console.error("JCHAT_ERROR: Comments list element not found for postId:", postId);
                                    return;
                                }
                                commentsListElement.innerHTML = ''; // Clear existing comments.

                                if (commentsSnapshot.empty) {
                                    commentsListElement.innerHTML = '<p style="font-size:0.85rem; color:var(--text-light); text-align:left; margin-left:10px;" class="no-comments-message">No comments yet.</p>';
                                } else {
                                                                         commentsSnapshot.forEach(commentDoc => {
                                         const comment = commentDoc.data();
                                         const commentId = commentDoc.id;
                                         const el = renderComment(comment, commentId, postId);
                                         if (comment.replyingTo) {
                                             const replyBadge = document.createElement('div');
                                             replyBadge.style.cssText = 'font-size:0.8rem;color:var(--text-light);margin-top:2px;';
                                             replyBadge.textContent = 'Replying to a comment';
                                             el.querySelector('.comment-content-wrapper').appendChild(replyBadge);
                                         }
                                         commentsListElement.appendChild(el);
                                     });
                                }
                                // Re-apply disabled state to delete comment buttons after rendering.
                                commentsListElement.querySelectorAll('.delete-comment-button').forEach(button => {
                                    const commentAuthorId = button.dataset.commentAuthorId;
                                    const isCommentOwner = currentUser && currentUser.uid === commentAuthorId;
                                    button.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) || (!isCommentOwner && currentUser.uid !== ADMIN_UID);
                                });
                            });
                            unsubscribeListeners.push(unsubscribeComments); // Add comment listener to the unsubscribe list.
                            commentsListElement.dataset.listenerAttached = 'true'; // Mark listener as attached.
                        }

                        // Setup onSnapshot for current user's reaction to this post (for newly added posts and updates).
                        if (currentUser) {
                            const userReactionRef = doc(db, "artifacts", appId, "public", "data", "posts", postId, "userReactions", currentUser.uid);
                            // Only attach if not already attached for this post and user.
                            if (!postElement.dataset.userReactionListenerAttached) {
                                const unsubscribeUserReaction = onSnapshot(userReactionRef, (reactionSnap) => {
                                    const currentPostCard = postsFeed.querySelector(`.post-card[data-post-id="${postId}"]`);
                                    if (currentPostCard) {
                                        const likeBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="like"]`);
                                        const loveBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="love"]`);
                                        const hahaBtn = currentPostCard.querySelector(`.react-button[data-reaction-type="haha"]`);

                                        // Ensure buttons exist before manipulating classes.
                                        if (likeBtn) likeBtn.classList.remove('reacted-like');
                                        if (loveBtn) loveBtn.classList.remove('reacted-love');
                                        if (hahaBtn) hahaBtn.classList.remove('reacted-haha');

                                        if (reactionSnap.exists()) {
                                            const reactionData = reactionSnap.data();
                                            const activeReactionButton = currentPostCard.querySelector(`.react-button[data-reaction-type="${reactionData.type}"]`);
                                            if (activeReactionButton) {
                                                activeReactionButton.classList.add(`reacted-${reactionData.type}`);
                                            }
                                        }
                                    }
                                });
                                unsubscribeListeners.push(unsubscribeUserReaction); // Add user reaction listener to unsubscribe list.
                                postElement.dataset.userReactionListenerAttached = 'true'; // Mark listener as attached.
                            }
                        }
                    });

                    // Reorder posts in the DOM if necessary (important for orderBy).
                    const orderedElements = newOrderedPostIds.map(id => postsFeed.querySelector(`.post-card[data-post-id="${id}"]`));
                    orderedElements.forEach((element, index) => {
                        if (element && postsFeed.children[index] !== element) {
                            postsFeed.insertBefore(element, postsFeed.children[index]);
                        }
                    });

                    // Remove posts that no longer exist in the query snapshot (after reordering, to avoid re-inserting removed elements).
                    currentPostElements.forEach((element, id) => {
                        if (!newOrderedPostIds.includes(id)) {
                            element.remove();
                        }
                    });

                    // Display "No posts yet" message if the feed is empty.
                    if (querySnapshot.empty) {
                        if (!document.getElementById('noPostsMessage')) {
                            postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);" id="noPostsMessage">No posts yet. Be the first to post!</p>';
                        }
                    } else {
                        const noPostsMessage = document.getElementById('noPostsMessage');
                        if (noPostsMessage) noPostsMessage.remove();
                    }

                    if (loadingPostsMessage) loadingPostsMessage.style.display = 'none'; // Hide loading message.
                    if (typeof setLoaderStage === 'function') setLoaderStage('feed');
                    // After posts are rendered/updated, apply system settings to their interactive elements.
                    applySystemSettings(currentSystemSettings);

                });
                unsubscribeListeners.push(unsubscribePosts); // Add the main posts listener to the unsubscribe list.

            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching posts:", error);
                showMessageBox(`Error loading posts: ${error.message}`, 'error');
                if (postsFeed) postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);">Failed to load posts. Please try again later.</p>';
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
            }
        }

        // --- Event Delegation for Dynamic Elements ---
        // Attaches a single click listener to the document and delegates events to dynamically created elements.
        document.addEventListener('click', (event) => {
            // Handle React Buttons
            if (event.target.closest('.react-button')) {
                const button = event.target.closest('.react-button');
                if (!isAuthReady) { showMessageBox("Please log in to react.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Reactions are currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const reactionType = button.dataset.reactionType;
                handleReaction(postId, reactionType);
            }
            // Handle Poll Vote
            else if (event.target.closest('.poll-vote-button')) {
                const btn = event.target.closest('.poll-vote-button');
                const postId = btn.dataset.postId;
                const index = parseInt(btn.dataset.index, 10);
                votePoll(postId, index);
            }
            // Handle Comment Toggle Buttons
            else if (event.target.closest('.comment-toggle-button')) {
                const button = event.target.closest('.comment-toggle-button');
                const commentsSection = button.closest('.post-card').querySelector('.comments-section');
                if (commentsSection) {
                    commentsSection.style.display = commentsSection.style.display === 'none' ? 'block' : 'none';
                }
            }
            // Handle Submit Comment Buttons
            else if (event.target.closest('.submit-comment-button')) {
                const button = event.target.closest('.submit-comment-button');
                if (!isAuthReady) { showMessageBox("Please log in to comment.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Commenting is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const commentInput = button.closest('.comment-input-area').querySelector('.comment-input');
                addComment(postId, commentInput.value);
                commentInput.value = ''; // Clear comment input after submission.
            }
            // Handle Post Options Buttons (ellipsis menu)
            else if (event.target.closest('.post-options-button')) {
                const button = event.target.closest('.post-options-button');
                if (!isAuthReady) { showMessageBox("Please log in to manage posts.", 'error'); return; }
                // Admin can always manage posts, regular users only if feature is enabled.
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post management is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const dropdown = document.getElementById(`dropdown-${postId}`);
                // Close any other open dropdowns.
                document.querySelectorAll('.post-options-dropdown.active').forEach(openDropdown => {
                    if (openDropdown.id !== `dropdown-${postId}`) {
                        openDropdown.classList.remove('active');
                    }
                });
                if (dropdown) dropdown.classList.toggle('active'); // Toggle visibility of the clicked dropdown.
                // Show delete if author and post older than 5 minutes
                const postCard = button.closest('.post-card');
                const createdText = postCard?.querySelector('.post-timestamp')?.textContent || '';
                // We rely on dataset we set later; fallback: always show for author to avoid parsing date strings
                const delBtn = dropdown?.querySelector('.delete-post-button');
                const isOwner = (currentUser && button.dataset.authorId === currentUser.uid);
                if (delBtn && isOwner) delBtn.style.display = '';
                event.stopPropagation(); // Prevent document click from closing it immediately.
            }
            // Handle Edit Post Button
            else if (event.target.closest('.delete-post-button')) {
                const btn = event.target.closest('.delete-post-button');
                const postId = btn.dataset.postId;
                const authorId = btn.dataset.authorId;
                if (!currentUser || currentUser.uid !== authorId) { showMessageBox('You can only delete your own post.', 'warning'); return; }
                // Check age
                const triggerBtn = document.querySelector(`.post-options-button[data-post-id="${postId}"]`);
                const ts = parseInt(triggerBtn?.dataset.timestamp || '0', 10);
                if (Date.now() - ts < 5*60*1000) { showMessageBox('Delete becomes available 5 minutes after posting.', 'info'); return; }
                (async ()=>{
                    try {
                        await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'posts', postId));
                        showMessageBox('Post deleted.', 'success');
                    } catch(e) { console.error(e); showMessageBox('Failed to delete post.', 'error'); }
                })();
            }
            else if (event.target.closest('.add-to-highlights-button')) {
                const button = event.target.closest('.add-to-highlights-button');
                if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
                const postId = button.dataset.postId;
                (async ()=>{
                    try {
                        await addDoc(collection(db, 'artifacts', appId, 'users', currentUser.uid, 'highlights'), { postId, createdAt: serverTimestamp() });
                        showMessageBox('Added to highlights.', 'success');
                    } catch (e) { console.error(e); showMessageBox('Failed to add to highlights.', 'error'); }
                })();
            }
            else if (event.target.closest('.edit-post-button')) {
                const button = event.target.closest('.edit-post-button');
                if (!isAuthReady) { showMessageBox("Please log in to edit posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post editing is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const content = button.dataset.content;
                const mediaUrl = button.dataset.mediaUrl;
                const mediaType = button.dataset.mediaType;
                const visibility = button.dataset.visibility || 'public';
                openEditPostModal(postId, content, mediaUrl, mediaType, visibility);
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting edit.
            }
            // Handle Delete Post Button (This button is now removed from renderPost function, but keeping the handler for robustness)
            else if (event.target.closest('.delete-post-button')) {
                const button = event.target.closest('.delete-post-button');
                // This block should ideally not be reached if the button is not rendered.
                // However, for safety, if it somehow appears, it will be handled.
                if (!isAuthReady) { showMessageBox("Please log in to delete posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post deletion is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const authorId = button.dataset.authorId;
                deletePost(postId, authorId);
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting delete.
            }
            // Handle Share Post Button
            else if (event.target.closest('.share-post-button')) {
                const button = event.target.closest('.share-post-button');
                if (!isAuthReady) { showMessageBox("Please log in to share posts.", 'error'); return; }
                if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post sharing is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const content = button.dataset.content;
                const dropdown = document.getElementById(`dropdown-${postId}`);
                if (dropdown) dropdown.classList.remove('active'); // Close dropdown after selecting share.
                openShareInspirationModal();
            }
            // Handle Delete Comment Button
            else if (event.target.closest('.delete-comment-button')) {
                const button = event.target.closest('.delete-comment-button');
                if (!isAuthReady) { showMessageBox("Please log in to delete comments.", 'error'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox("Comment deletion is currently disabled by administrators.", 'warning'); return; }
                const postId = button.dataset.postId;
                const commentId = button.dataset.commentId;
                const commentAuthorId = button.dataset.commentAuthorId;
                deleteComment(postId, commentId, commentAuthorId);
            }
            // Close dropdowns if clicking anywhere else on the document (outside of a dropdown).
            else if (!event.target.closest('.post-options-dropdown')) {
                document.querySelectorAll('.post-options-dropdown.active').forEach(openDropdown => {
                    openDropdown.classList.remove('active');
                });
            }
        });

        // NEW: System Settings Logic
        // Document reference for global system settings in Firestore.
        const SYSTEM_SETTINGS_DOC_REF = doc(db, "artifacts", appId, "public", "data", "settings", "system_settings");
        /**
         * Fetches global system settings from Firestore.
         * If settings document doesn't exist, it creates it with default values.
         */
        async function fetchSystemSettings() {
            console.log("JCHAT_DEBUG: Fetching system settings...");
            try {
                const docSnap = await getDoc(SYSTEM_SETTINGS_DOC_REF);
                if (docSnap.exists()) {
                    currentSystemSettings = docSnap.data();
                    console.log("JCHAT_DEBUG: System settings fetched:", currentSystemSettings);
                    if (typeof setLoaderStage === 'function') setLoaderStage('settings');
                } else {
                    console.warn("JCHAT_WARNING: System settings document not found. Initializing with default values.");
                    // Define default system settings.
                    currentSystemSettings = {
                        jcoinNairaRate: 7.5,
                        gasJcoinRate: 0.1,
                        dailyBonusAmount: 50,
                        defaultInspirationType: "motivational",
                        profanityFilterSensitivity: 5,
                        enableUserRegistration: true,
                        enableFriendRequests: true,
                        enablePublicChat: true,
                        enablePostCreation: true,
                        enableEmailNotifications: true,
                        maintenanceMode: false,
                        globalAnnouncement: "",
                        enableCalls: true, // NEW: Default to true for calls.
                    };
                    await setDoc(SYSTEM_SETTINGS_DOC_REF, currentSystemSettings); // Create the document.
                    console.log("JCHAT_DEBUG: Default system settings created.");
                }
                applySystemSettings(currentSystemSettings); // Apply settings immediately after fetching/initializing.
                if (typeof setLoaderStage === 'function') setLoaderStage('settings');
            } catch (error) {
                console.error("JCHAT_ERROR: Error fetching system settings:", error);
                showMessageBox(`Failed to load system settings: ${error.message}`, 'error', true);
            }
        }
        /**
         * Applies the fetched system settings to various UI elements and features.
         * Controls visibility and interactivity based on admin toggles and maintenance mode.
         * @param {object} settings - The system settings object.
         */
        function applySystemSettings(settings) {
            console.log("JCHAT_DEBUG: Applying system settings to UI:", settings);

            const isCurrentUserAdmin = currentUser && currentUser.uid === ADMIN_UID;

            // First, handle the global maintenance mode.
            if (settings.maintenanceMode) {
                if (isCurrentUserAdmin) {
                    // Admin bypasses maintenance overlay and global disabling.
                    if (maintenanceOverlay) maintenanceOverlay.classList.remove('active');
                    document.body.style.overflow = 'auto';
                    showMessageBox("JCHAT is in Maintenance Mode, but you (Admin) have full access.", 'info', true);
                    toggleInteractiveElements(true, true); // Enable everything for admin, pass isAdmin true.
                } else {
                    // Regular user sees maintenance overlay and all interactions are disabled.
                    if (maintenanceOverlay) {
                        maintenanceOverlay.classList.add('active');
                        if (maintenanceAnnouncementText) {
                            maintenanceAnnouncementText.textContent = "JCHAT is currently undergoing scheduled maintenance. We'll be back online shortly!";
                        }
                    }
                    toggleInteractiveElements(false, false); // Disable all interactions for regular users, pass isAdmin false.
                    document.body.style.overflow = 'hidden';
                    return; // IMPORTANT: Stop further processing of individual toggles for regular users in maintenance.
                }
            } else {
                // Maintenance mode is OFF for everyone.
                if (maintenanceOverlay) maintenanceOverlay.classList.remove('active');
                document.body.style.overflow = 'auto';
                toggleInteractiveElements(true, isCurrentUserAdmin); // Enable all interactions initially, pass isAdmin.
            }



            // Now, apply individual feature toggles.
            // These will refine the state set by the maintenance mode logic above.
            // For admins, these will apply normally. For regular users, if maintenance was ON,
            // this part is skipped. If maintenance was OFF, these apply normally.

            // Post Creation Section visibility and input states.
            if (postCreationSection) {
                if (settings.enablePostCreation || isCurrentUserAdmin) { // Admin can always see/use.
                    postCreationSection.style.display = 'flex';
                    if (postContentInput) postContentInput.disabled = false;
                    if (postMediaUpload) postMediaUpload.disabled = false;
                    if (createPostButton) createPostButton.disabled = false;
                } else {
                    postCreationSection.style.display = 'none';
                    if (postContentInput) postContentInput.disabled = true;
                    if (postMediaUpload) postMediaUpload.disabled = true;
                    if (createPostButton) createPostButton.disabled = true;
                }
            }

            // Sidebar links (only if they correspond to features that can be toggled).
            // These need to reflect the feature toggle, but also respect the overall `toggleInteractiveElements` state
            // which is set by maintenance mode. The `pointer-events` and `opacity` are good for this.
            if (chatLink) {
                if (settings.enablePublicChat || isCurrentUserAdmin) {
                    chatLink.style.pointerEvents = 'auto';
                    chatLink.style.opacity = '1';
                } else {
                    chatLink.style.pointerEvents = 'none';
                    chatLink.style.opacity = '0.5';
                }
            }
            if (findFriendsLink) {
                if (settings.enableFriendRequests || isCurrentUserAdmin) {
                    findFriendsLink.style.pointerEvents = 'auto';
                    findFriendsLink.style.opacity = '1';
                } else {
                    findFriendsLink.style.pointerEvents = 'none';
                    findFriendsLink.style.opacity = '0.5';
                }
            }
            if (friendsLink) {
                if (settings.enableFriendRequests || isCurrentUserAdmin) {
                    friendsLink.style.pointerEvents = 'auto';
                    friendsLink.style.opacity = '1';
                } else {
                    friendsLink.style.pointerEvents = 'none';
                    friendsLink.style.opacity = '0.5';
                }
            }
            if (groupsLink) { // Assuming a toggle for groups.
                // For now, groups are not explicitly tied to a system setting.
                // If a 'settings.enableGroups' existed, it would be used here.
                // Otherwise, its state is controlled by the global `toggleInteractiveElements`.
                groupsLink.style.pointerEvents = 'auto';
                groupsLink.style.opacity = '1';
            }
            if (jcoinShopLink) { // Assuming a toggle for shop.
                // For now, shop is not explicitly tied to a system setting.
                // If a 'settings.enableJCoinShop' existed, it would be used here.
                // Otherwise, its state is controlled by the global `toggleInteractiveElements`.
                jcoinShopLink.style.pointerEvents = 'auto';
                jcoinShopLink.style.opacity = '1';
            }

            // Re-apply disabled states to dynamically rendered post/comment elements.
            // This is crucial because these elements are rendered *before* settings are applied.
            document.querySelectorAll('.post-card').forEach(postCard => {
                const postId = postCard.dataset.postId;
                const postAuthorId = postCard.querySelector('.post-options-button')?.dataset.authorId || null; // Get authorId if options button exists.

                // Post actions (reactions, comments, options menu).
                postCard.querySelectorAll('.react-button, .comment-toggle-button').forEach(button => {
                    button.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);
                });

                // Comment input and submit button.
                const commentInput = postCard.querySelector('.comment-input');
                const submitCommentButton = postCard.querySelector('.submit-comment-button');
                if (commentInput) commentInput.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);
                if (submitCommentButton) submitCommentButton.disabled = !isAuthReady || (!settings.enablePublicChat && !isCurrentUserAdmin);

                // Delete comment buttons (more complex logic: can delete own if enabled, admin can delete any).
                postCard.querySelectorAll('.delete-comment-button').forEach(button => {
                    const commentAuthorId = button.dataset.commentAuthorId;
                    const isCommentOwner = currentUser && currentUser.uid === commentAuthorId;
                    button.disabled = !isAuthReady || (!currentSystemSettings.enablePublicChat && !isCurrentUserAdmin) || (!isCommentOwner && !isCurrentUserAdmin);
                });

                // Post options (edit, share).
                postCard.querySelectorAll('.post-options-button, .edit-post-button, .share-post-button').forEach(button => {
                    // Only enable if current user is the author OR if current user is admin AND the feature is enabled.
                    // The isAuthor check is handled in renderPost, here we just control the disabled state based on settings and admin.
                    const isButtonAuthor = currentUser && currentUser.uid === postAuthorId;
                    button.disabled = !isAuthReady || ((!settings.enablePostCreation && !isCurrentUserAdmin) || (!isButtonAuthor && !isCurrentUserAdmin));
                });
            });

            // Re-evaluate daily bonus button state.
            checkAndStartDailyBonusTimer();
        }

        // WebRTC STUN/TURN servers (NEW)
        // Configuration for ICE servers, essential for WebRTC connection establishment.
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
            ]
        };

        /**
         * Initializes a new RTCPeerConnection.
         * Sets up onicecandidate and ontrack event handlers.
         * @returns {RTCPeerConnection} The initialized peer connection.
         */
        function createPeerConnection() {
            const pc = new RTCPeerConnection(iceServers);

            // Event handler for ICE candidates (network information).
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send ICE candidate to the other peer via Firestore.
                    if (callRef) {
                        const candidateData = JSON.parse(JSON.stringify(event.candidate)); // Deep copy to avoid Firestore issues.
                        if (isIncomingCall) { // If this peer is the receiver.
                            updateDoc(callRef, {
                                receiverCandidates: arrayUnion(candidateData)
                            }).catch(e => console.error("Error adding receiver candidate:", e));
                        } else { // If this peer is the caller.
                            updateDoc(callRef, {
                                callerCandidates: arrayUnion(candidateData)
                            }).catch(e => console.error("Error adding caller candidate:", e));
                        }
                    }
                }
            };

            // Event handler for remote media tracks.
            pc.ontrack = (event) => {
                // Attach remote stream to remoteVideo element.
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.style.display = 'block';
                    remoteStream = event.streams[0];
                } else {
                    // Fallback for older browsers or individual tracks.
                    if (!remoteStream) {
                        remoteStream = new MediaStream();
                        remoteVideo.srcObject = remoteStream;
                        remoteVideo.style.display = 'block';
                    }
                    remoteStream.addTrack(event.track);
                }
            };

            return pc;
        }

        /**
         * Listens for incoming calls to the current user in real-time.
         */
        let unsubscribeCallListener = null; // Declare here so it can be cleared on unload.

        function listenForIncomingCalls() {
            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Unsubscribe from previous listener to prevent duplicates.
            }
            if (!currentUser) return;

            const callsCollectionRef = collection(db, "artifacts", appId, "public", "data", "calls");
            // Query for calls where current user is the receiver and status is 'ringing'.
            const q = query(callsCollectionRef, where("receiverId", "==", currentUser.uid), where("status", "==", "ringing"));

            unsubscribeCallListener = onSnapshot(q, async (snapshot) => {
                if (snapshot.empty) {
                    // No incoming calls.
                    stopRingingSound();
                    if (callState === 'ringing') { // If we were ringing and call disappeared (e.g., caller ended).
                        showMessageBox("Incoming call ended.", "info");
                        playNotificationSound('info');
                        endCall(false);
                    }
                    return;
                }

                const incomingCallDoc = snapshot.docs[0]; // Take the first incoming call.
                const callData = incomingCallDoc.data();

                // Check if calls are enabled by system settings (unless current user is admin).
                if (!currentSystemSettings.enableCalls && currentUser.uid !== ADMIN_UID) {
                    console.log("JCHAT_DEBUG: Calls disabled by admin. Declining incoming call.");
                    await updateDoc(incomingCallDoc.ref, { status: 'declined_by_system' });
                    showMessageBox("Incoming call declined: Calls are currently disabled by administrators.", "warning", true, 5000);
                    playNotificationSound('error');
                    return;
                }

                if (callState !== 'idle') {
                    // Already in a call or busy, decline new incoming call.
                    await updateDoc(incomingCallDoc.ref, { status: 'busy' });
                    showMessageBox(`Another call from ${callData.callerId === recipientUserProfileData?.userId ? recipientUserProfileData?.username : 'someone'} is incoming, but you are busy.`, "warning");
                    playNotificationSound('info');
                    return;
                }

                // New incoming call detected.
                callRef = incomingCallDoc.ref; // Store reference to the call document.
                isIncomingCall = true;
                callState = 'ringing';
                currentCallType = callData.callType;

                // Fetch caller's profile for display in the UI.
                const callerProfileDocRef = doc(db, "artifacts", appId, "public", "data", "users", callData.callerId);
                const callerProfileSnap = await getDoc(callerProfileDocRef);
                const callerUsername = callerProfileSnap.exists() ? callerProfileSnap.data().username : 'Unknown User';
                recipientUserProfileData = callerProfileSnap.exists() ? callerProfileSnap.data() : null; // Set recipient for UI.

                // Update call overlay UI.
                callOverlay.classList.add('active');
                callOverlay.classList.remove('voice-call', 'video-call'); // Clear previous call type classes.
                callOverlay.classList.add(currentCallType === 'voice' ? 'voice-call' : 'video-call');

                callStatusIcon.className = `fas fa-${currentCallType === 'voice' ? 'phone' : 'video'} call-status-icon`;
                callStatusText.textContent = `Incoming ${currentCallType} call from ${callerUsername}...`;
                callTimerDisplay.style.display = 'none'; // Hide timer initially.
                callActions.style.display = 'flex'; // Show call action buttons.
                acceptCallBtn.style.display = 'block';
                declineCallBtn.style.display = 'block';
                toggleMuteBtn.style.display = 'none';
                toggleVideoBtn.style.display = 'none';
                endCallBtn.style.display = 'none'; // Only accept/decline for incoming.
                callStatusIcon.style.animation = 'pulse-color 2s infinite alternate'; // Start icon animation.

                startRingingSound(); // Play ringing sound.

                // Set a timeout for no answer (20 seconds).
                callTimeoutId = setTimeout(async () => {
                    if (callState === 'ringing') {
                        stopRingingSound();
                        await updateDoc(callRef, { status: 'no-answer' });
                        showMessageBox("Incoming call unanswered.", "info");
                        playNotificationSound('info');
                        endCall(true); // End call and update Firestore.
                    }
                }, 20000);
            }, (error) => {
                console.error("JCHAT_ERROR: Error listening for incoming calls:", error);
            });
        }
        /**
         * Handles accepting an incoming call.
         * Initializes WebRTC peer connection, gets local media, sets remote description,
         * creates and sets local answer, and updates Firestore.
         */
        async function acceptCall() {
            if (callState !== 'ringing' || !callRef || !currentUser) {
                showMessageBox("Cannot accept call in current state.", "warning");
                playNotificationSound('info');
                return;
            }

            stopRingingSound(); // Stop ringing sound.
            clearTimeout(callTimeoutId); // Clear no-answer timeout.

            callState = 'connected'; // Update call state.
            callStatusText.textContent = `Call with ${recipientUserProfileData?.username || 'user'}`;
            callTimerDisplay.style.display = 'block'; // Show call timer.
            callActions.style.display = 'flex'; // Show call action buttons.
            acceptCallBtn.style.display = 'none';
            declineCallBtn.style.display = 'none';
            endCallBtn.style.display = 'block';
            toggleMuteBtn.style.display = 'block';
            toggleVideoBtn.style.display = currentCallType === 'video' ? 'block' : 'none';
            callStatusIcon.style.animation = 'none'; // Stop icon animation.

            clearInterval(callDurationInterval); // Clear any old timer.
            callDurationInterval = setInterval(updateCallTimer, 1000); // Start new timer.

            showMessageBox("Call connected!", "success");
            playNotificationSound('success');

            try {
                // Get local media stream (audio and optionally video).
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: currentCallType === 'video'
                });
                localVideo.srcObject = localStream;
                if (currentCallType === 'video') {
                    localVideo.style.display = 'block'; // Show local video if it's a video call.
                }

                // Update current user's inCall status in public profile.
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: true });

                // Create Peer Connection.
                peerConnection = createPeerConnection();

                // Add local tracks to peer connection.
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // Get the offer from Firestore.
                const callDocSnap = await getDoc(callRef);
                const callData = callDocSnap.data();
                const remoteOffer = new RTCSessionDescription(callData.offer);
                await peerConnection.setRemoteDescription(remoteOffer);

                // Create and set local answer.
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Update Firestore with answer and status.
                await updateDoc(callRef, {
                    status: 'accepted',
                    answer: {
                        type: answer.type,
                        sdp: answer.sdp
                    },
                    lastActivity: serverTimestamp()
                });

                // Add any initial candidates from caller that might have arrived before answer.
                if (callData.callerCandidates && callData.callerCandidates.length > 0) {
                    for (const candidate of callData.callerCandidates) {
                        try {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        } catch (e) {
                            console.error("Error adding initial caller ICE candidate:", e);
                        }
                    }
                    await updateDoc(callRef, { callerCandidates: [] }); // Clear them after adding.
                }

                // Listen for caller candidates (new ones) after call is accepted.
                // This listener needs to be distinct from the one in listenForIncomingCalls
                // to avoid issues when the status changes from ringing to accepted.
                // Re-assigning unsubscribeCallListener here will replace the previous one.
                unsubscribeCallListener = onSnapshot(callRef, async (docSnap) => {
                    if (!docSnap.exists()) {
                        console.log("JCHAT_DEBUG: Call document disappeared. Ending call.");
                        endCall(false); // End call locally if document is gone.
                        return;
                    }
                    const data = docSnap.data();
                    if (data.callerCandidates && data.callerCandidates.length > 0) {
                        for (const candidate of data.callerCandidates) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.error("Error adding caller ICE candidate:", e);
                            }
                        }
                        await updateDoc(callRef, { callerCandidates: [] }); // Clear candidates after adding.
                    }
                    // If the other party ends the call, update local state.
                    if (data.status === 'ended' && callState !== 'idle') {
                        showMessageBox("Call ended by other party.", "info");
                        playNotificationSound('info');
                        endCall(false);
                    }
                });

            } catch (error) {
                console.error("JCHAT_ERROR: Error accepting call:", error);
                // Provide user-friendly error messages for common media issues.
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showMessageBox(`Failed to accept call: Microphone/Camera access denied. Please allow permissions in your browser settings.`, "error", true, 5000);
                } else if (error.name === 'NotFoundError') {
                    showMessageBox(`Failed to accept call: No microphone or camera found. Please ensure one is connected.`, "error", true, 5000);
                } else {
                    showMessageBox(`Failed to accept call: ${error.message}`, "error", true, 5000);
                }
                playNotificationSound('error');
                endCall(true); // Ensure cleanup even if acceptance fails.
            }
        }

        /**
         * Handles declining an incoming call.
         * Updates Firestore status and cleans up.
         */
        async function declineCall() {
            if (callState !== 'ringing' || !callRef) {
                showMessageBox("Cannot decline call in current state.", "warning");
                playNotificationSound('info');
                return;
            }

            stopRingingSound(); // Stop ringing.
            clearTimeout(callTimeoutId); // Clear no-answer timeout.
            showMessageBox("Call declined.", "info");
            playNotificationSound('info');

            try {
                await updateDoc(callRef, { status: 'declined', lastActivity: serverTimestamp() });
            } catch (error) {
                console.error("JCHAT_ERROR: Error updating call status to declined:", error);
            } finally {
                endCall(false); // End call locally, Firestore already updated.
            }
        }

        /**
         * Toggles microphone mute/unmute during a call.
         */
        function toggleMute() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state.
                    isMuted = !track.enabled; // Update mute state.
                    toggleMuteBtn.classList.toggle('active', isMuted); // Toggle active class for styling.
                    toggleMuteBtn.querySelector('i').className = isMuted ? 'fas fa-microphone-slash' : 'fas fa-microphone'; // Change icon.
                });
            }
        }
        /**
         * Toggles video on/off during a call.
         */
        function toggleVideo() {
            if (localStream) {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled; // Toggle track's enabled state.
                    isVideoOff = !track.enabled; // Update video off state.
                    toggleVideoBtn.classList.toggle('active', isVideoOff); // Toggle active class for styling.
                    toggleVideoBtn.querySelector('i').className = isVideoOff ? 'fas fa-video-slash' : 'fas fa-video'; // Change icon.
                    localVideo.style.display = track.enabled ? 'block' : 'none'; // Hide/show local video element.
                });
            }
        }

        /**
         * Updates the call timer display every second.
         */
        function updateCallTimer() {
            callDuration++;
            const minutes = Math.floor(callDuration / 60);
            const seconds = callDuration % 60;
            callTimerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Ends the call and cleans up all WebRTC resources and UI.
         * @param {boolean} updateFirestore - Whether to update the Firestore call status to 'ended'.
         */
        async function endCall(updateFirestore = true) {
            stopRingingSound(); // Stop any ringing sound.
            clearInterval(callDurationInterval); // Stop call timer.
            clearTimeout(callTimeoutId); // Clear any no-answer timeout.

            if (unsubscribeCallListener) {
                unsubscribeCallListener(); // Unsubscribe from Firestore call listener.
                unsubscribeCallListener = null;
            }

            if (peerConnection) {
                peerConnection.close(); // Close the RTCPeerConnection.
                peerConnection = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop()); // Stop all local media tracks.
                localStream = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop()); // Stop all remote media tracks.
                remoteStream = null;
            }

            // Reset video element sources and display.
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            localVideo.style.display = 'none';
            remoteVideo.style.display = 'none';

            // Hide call overlay and reset call state.
            callOverlay.classList.remove('active', 'voice-call', 'video-call');
            callState = 'idle';
            isIncomingCall = false;
            callDuration = 0;
            callTimerDisplay.textContent = '00:00';

            // Reset call action button states and icons.
            toggleMuteBtn.classList.remove('active');
            toggleVideoBtn.classList.remove('active');
            toggleMuteBtn.querySelector('i').className = 'fas fa-microphone';
            toggleVideoBtn.querySelector('i').className = 'fas fa-video';
            toggleMuteBtn.style.display = 'none';
            toggleVideoBtn.style.display = 'none';
            acceptCallBtn.style.display = 'none';
            declineCallBtn.style.display = 'none';
            endCallBtn.style.display = 'none';
            callStatusIcon.style.animation = 'none';

            // Update user's inCall status in Firestore.
            if (currentUser && currentUser.uid) {
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on endCall:", e));
            }

            // Update Firestore call document status if explicitly requested.
            if (updateFirestore && callRef) {
                try {
                    await updateDoc(callRef, { status: 'ended', lastActivity: serverTimestamp() });
                } catch (error) {
                    console.error("JCHAT_ERROR: Error updating call status to ended in Firestore:", error);
                }
            }
            callRef = null; // Clear call reference.
        }
        // --- Authentication State Listener ---
        // This is the primary entry point after the DOM is loaded.
        onAuthStateChanged(auth, async (user) => {
            if (typeof setLoaderStage === 'function') setLoaderStage('auth');
            console.log("JCHAT_DEBUG: onAuthStateChanged triggered. User:", user ? user.uid : "null");
            if (user) {
                // Presence heartbeat (online + lastActive)
                try {
                    const userDocRef = doc(db, "artifacts", appId, "public", "data", "users", user.uid);
                    const computeOnline = () => navigator.onLine && document.visibilityState === 'visible';
                    const post = async () => { try { await setDoc(userDocRef, { online: computeOnline(), lastActive: serverTimestamp() }, { merge: true }); } catch {} };
                    post();
                    const debounced = () => { post(); };
                    window.addEventListener('online', debounced);
                    window.addEventListener('offline', debounced);
                    document.addEventListener('visibilitychange', debounced);
                    window.addEventListener('pagehide', () => { try { post(); } catch {} });
                    window.addEventListener('beforeunload', () => { try { post(); } catch {} });
                } catch {}

                currentUser = user;
                isAuthReady = true; // Set to true early so profile fetching can proceed.
                await fetchAndDisplayHeaderProfile(user); // This sets currentUserProfileData and updates UI.
                console.log("JCHAT_DEBUG: Auth is ready. User ID:", currentUser.uid, "isAuthReady:", isAuthReady);

                // Start listening to system settings in real-time and render announcement & chips
                const unsubscribeSettings = onSnapshot(SYSTEM_SETTINGS_DOC_REF, (docSnap) => {
                    if (docSnap.exists()) {
                        currentSystemSettings = docSnap.data();
                        console.log("JCHAT_DEBUG: Real-time system settings update:", currentSystemSettings);
                        // Apply system settings immediately for faster announcement display
                        applySystemSettings(currentSystemSettings);
                        
                        // Check for global announcements
                        if (currentSystemSettings.globalAnnouncement && typeof currentSystemSettings.globalAnnouncement === 'object') {
                            displayGlobalAnnouncement(currentSystemSettings.globalAnnouncement);
                        } else {
                            hideGlobalAnnouncement();
                        }
                                        // Update wallet chip
                if (homeChipsRow && walletChipAmount && jcoinRateSpan) {
                    walletChipAmount.textContent = String(currentUserProfileData?.jCoins || 0);
                    jcoinRateSpan.textContent = String(currentSystemSettings?.jcoinNairaRate || 0);
                    homeChipsRow.style.display = 'flex';
                }
                // Wallet chip click: gate by walletUnlocked
                if (walletChipLink) {
                    walletChipLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        const unlocked = !!currentUserProfileData?.walletUnlocked;
                        if (unlocked) {
                            window.location.href = '/Wallet.html';
                        } else {
                            const m = document.getElementById('walletLockedModal');
                            if (m) { m.style.display='block'; setTimeout(()=>m.classList.add('active'),0); }
                        }
                    });
                }
                const closeWalletLockedBtn = document.getElementById('closeWalletLockedBtn');
                if (closeWalletLockedBtn) closeWalletLockedBtn.addEventListener('click', ()=>{
                    const m = document.getElementById('walletLockedModal');
                    if (m) { m.classList.remove('active'); setTimeout(()=>m.style.display='none',200); }
                });
                                        // Start listening for calls only after settings are loaded and calls are enabled.
                if (currentSystemSettings.enableCalls) {
                    listenForIncomingCalls();
                } else {
                    if (unsubscribeCallListener) {
                        unsubscribeCallListener(); // Stop listening if calls are disabled.
                        unsubscribeCallListener = null;
                    }
                    if (callState !== 'idle') {
                        endCall(false); // End any active call if feature is disabled.
                        showMessageBox("Call ended: Calls are now disabled by administrators.", "warning", true, 5000);
                    }
                }

                // Subscribe to theme entitlements for the authenticated user
                const unsubscribeThemeEntitlements = subscribeThemeEntitlements(user.uid);
                if (unsubscribeThemeEntitlements) {
                    unsubscribeListeners.push(unsubscribeThemeEntitlements);
                }
                    } else {
                        console.warn("JCHAT_WARNING: System settings document not found during snapshot. Re-fetching.");
                        if (navigator.onLine) fetchSystemSettings().catch(()=>{});
                    }
                }, (error) => {
                    console.error("JCHAT_ERROR: Error listening to system settings:", error);
                    showMessageBox("Failed to get real-time settings updates.", 'error', true);
                });
                unsubscribeListeners.push(unsubscribeSettings); // Add to list to unsubscribe on unload.

                if (navigator.onLine) { 
                    try { 
                        await fetchSystemSettings(); 
                        // Check for announcements after initial fetch
                        await checkGlobalAnnouncements();
                    } catch(_){} 
                } else { 
                    console.warn('JCHAT_WARN: offline, skipping system settings fetch'); 
                } // Initial fetch of system settings.
                // Level chip: realtime gas progress
                try {
                    const userRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'profiles', 'user_profile');
                    onSnapshot(userRef, (snap) => {
                        const data = snap.exists() ? snap.data() : null;
                        if (!data || !homeChipsRow || !levelChipName || !levelChipProgressFill) return;
                        const totalGasEarned = data.gas ?? data.totalGasEarned ?? 0;
                        // derive current level by cumulative thresholds
                        let currentLevel = 1;
                        for (let i = 1; i <= 500; i++) {
                            const needed = getTotalGasRequiredToReachLevel(i);
                            if (totalGasEarned >= needed) currentLevel = i; else break;
                        }
                        currentLevel = Math.max(1, currentLevel);
                        const info = getLevelInfo(currentLevel);
                        if (levelChipIcon) levelChipIcon.className = `${info.icon}`;
                        const baseName = (info.name || '').replace(/\s+Lv\.?\s*\d+/i, '').trim();
                        levelChipName.textContent = `${baseName} Lv${currentLevel}`;
                        const gasNeededCurr = getTotalGasRequiredToReachLevel(currentLevel);
                        const gasNeededNext = getTotalGasRequiredToReachLevel(currentLevel + 1);
                        const segSize = Math.max(1, gasNeededNext - gasNeededCurr);
                        const inSeg = Math.max(0, Math.min(totalGasEarned, gasNeededNext) - gasNeededCurr);
                        const progressPct = Math.floor((inSeg / segSize) * 100);
                        if (levelChipPercent) levelChipPercent.textContent = `${progressPct}%`;
                        levelChipProgressFill.style.width = `${progressPct}%`;
                        const backgroundPosition = 100 - progressPct;
                        levelChipProgressFill.style.backgroundPosition = `${backgroundPosition}% 0`;
                        homeChipsRow.style.display = 'flex';
                    });
                } catch(e) { console.warn('level chip realtime', e); }
                // Highlights (best-effort)
                try {
                    if (highlightsSection && highlightsStrip) {
                        const ref = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'highlights');
                        const snap = await getDocs(ref);
                        if (!snap.empty) {
                            highlightsSection.style.display = 'block';
                            highlightsStrip.innerHTML='';
                            snap.forEach(d => {
                                const h = d.data();
                                const card = document.createElement('a');
                                card.href = `/Profile.html?userId=${currentUser.uid}&tab=highlights`;
                                card.className = 'highlight-card';
                                const cover = h.coverPicId ? getCloudinaryImageUrl(h.coverPicId,'w_600,h_240,c_fill,q_auto') : '';
                                card.innerHTML = cover ? `<img src="${cover}" alt="cover">` : `<div style="height:100px;display:flex;align-items:center;justify-content:center;opacity:.8;">${h.title||'Highlight'}</div>`;
                                highlightsStrip.appendChild(card);
                            });
                        }
                    }
                } catch(e) { console.warn('highlights load', e); }

                // Saved widget (recent saved)
                try {
                    if (savedWidgetSection && savedWidget) {
                        const savedRef = collection(db, 'artifacts', appId, 'users', currentUser.uid, 'saved_posts');
                        const savedSnap = await getDocs(savedRef);
                        const ids = [];
                        savedSnap.forEach(d => ids.push(d.id));
                        if (ids.length) {
                            const postsRef = collection(db, 'artifacts', appId, 'public', 'data', 'posts');
                            const postsSnap = await getDocs(postsRef);
                            const items = [];
                            postsSnap.forEach(p => { if (ids.includes(p.id)) items.push({id:p.id, ...p.data()}); });
                            if (items.length) {
                                savedWidgetSection.style.display='block';
                                savedWidget.innerHTML='';
                                items.slice(0,10).forEach(p => {
                                    const a = document.createElement('a');
                                    a.className='saved-card';
                                    a.href=`/Home.html#post-${p.id}`;
                                    const cover = p.mediaType==='image'? p.mediaUrl : '';
                                    a.innerHTML = `${cover?`<img src=\"${cover}\" alt=\"saved\">`:''}<div style=\"padding:8px;opacity:.85;\">${(p.content||'').slice(0,60)}</div>`;
                                    savedWidget.appendChild(a);
                                });
                            }
                        }
                    }
                } catch(e) { console.warn('saved widget load', e); }
                await fetchAndDisplayPosts(); // This will setup all real-time listeners for posts and comments.
                fetchNotificationCount(user.uid);

            } else {
                console.log("JCHAT_DEBUG: No user signed in. Attempting anonymous sign-in or redirecting to login page.");
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("JCHAT_DEBUG: Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("JCHAT_DEBUG: Signed in anonymously.");
                    }
                } catch (error) {
                    console.error("JCHAT_ERROR: Error during anonymous sign-in or custom token sign-in:", error);
                    if (!auth.currentUser) {
                        hideLoader();
                        if (typeof showMessageBox === 'function') {
                            showMessageBox('You are not signed in. Some features are limited until you log in.', 'info');
                        }
                        isAuthReady = false;
                        toggleInteractiveElements(false, false);
                        return;
                    }
                }
                // If we reach here, either anonymous sign-in succeeded or custom token worked.
                // Re-check currentUser after potential anonymous sign-in.
                currentUser = auth.currentUser;
                if (currentUser) {
                    isAuthReady = true;
                    await fetchAndDisplayHeaderProfile(currentUser);
                    await fetchNotificationCount(currentUser.uid);
                    console.log("JCHAT_DEBUG: Anonymous/Custom Token Auth successful. User ID:", currentUser.uid, "isAuthReady:", isAuthReady);

                    // Start listening to system settings for anonymous users too (e.g., for maintenance mode).
                    const unsubscribeSettings = onSnapshot(SYSTEM_SETTINGS_DOC_REF, (docSnap) => {
                        if (docSnap.exists()) {
                            currentSystemSettings = docSnap.data();
                            console.log("JCHAT_DEBUG: Real-time system settings update for anonymous user:", currentSystemSettings);
                            setTimeout(() => applySystemSettings(currentSystemSettings), 5000);
                            // Calls are disabled for anonymous users by default by applySystemSettings, so no need to start listener.
                                            } else {
                        console.warn("JCHAT_WARNING: System settings document not found during snapshot for anonymous user. Re-fetching.");
                        if (navigator.onLine) fetchSystemSettings().catch(()=>{});
                    }
                    }, (error) => {
                        console.error("JCHAT_ERROR: Error listening to system settings for anonymous user:", error);
                        showMessageBox("Failed to get real-time settings updates.", 'error', true);
                    });
                    unsubscribeListeners.push(unsubscribeSettings);

                    await fetchSystemSettings(); // Initial fetch for anonymous.
                    await fetchAndDisplayPosts(); // Fetch posts for anonymous (they can view, but not interact).

                } else {
                    // This case should ideally not be reached if the above logic is correct,
                    // but as a fallback, ensure UI is for logged out state.
                    isAuthReady = false;
                    toggleInteractiveElements(false, false); // Disable all elements for unauthenticated non-admin.
                    if (headerDisplayName) headerDisplayName.textContent = "Guest";
                    if (headerProfilePic) headerProfilePic.style.display = 'none';
                    if (headerAvatarIcon) headerAvatarIcon.style.display = 'block';
                    if (adminIconLink) adminIconLink.style.display = 'none'; // Ensure admin icon is hidden for guests.

                    if (postsFeed) postsFeed.innerHTML = '<p style="text-align: center; color: var(--text-light);">Please log in to see posts and interact.</p>';
                    if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                    // Show deterministic inspiration even for guests
                    displayInspiration();

                    // Ensure daily bonus button is disabled and countdown is cleared for logged out state.
                    if (claimDailyBonusButton) {
                        claimDailyBonusButton.disabled = true;
                        claimDailyBonusButton.querySelector('.button-text').textContent = "Login to Claim Bonus";
                    }
                    if (dailyBonusCountdownInterval) {
                        clearInterval(dailyBonusCountdownInterval);
                        dailyBonusCountdownInterval = null;
                    }
                    console.log("JCHAT_DEBUG: Auth is NOT ready (final fallback). isAuthReady:", isAuthReady);

                    // Set default system settings for unauthenticated view if not fetched.
                    currentSystemSettings = {
                        jcoinNairaRate: 7.5, gasJcoinRate: 0.1, dailyBonusAmount: 50,
                        defaultInspirationType: "motivational", profanityFilterSensitivity: 5,
                        enableUserRegistration: true, enableFriendRequests: true, enablePublicChat: true,
                        enablePostCreation: true, enableEmailNotifications: true, maintenanceMode: false,
                        enableCalls: true, // Default to true for calls even for anonymous users to see UI.
                        globalAnnouncement: "",
                    };
                    applySystemSettings(currentSystemSettings); // Apply default settings for unauthenticated state.
                }
            }
        });

        // --- Event Listeners for static elements ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize theme switcher
            initializeThemeSwitcher();
            console.log("JCHAT_DEBUG: DOMContentLoaded fired.");
            
            // Prevent horizontal swipe gestures on main content
            const preventHorizontalSwipe = (e) => {
                // Allow vertical scrolling but prevent horizontal
                if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
                    e.preventDefault();
                }
            };
            
            // Prevent touch-based horizontal scrolling outside of friends carousel
            let startX = 0;
            let startY = 0;
            
            document.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                const scrollRow = e.target.closest('.scroll-row');
                
                if (!scrollRow) {
                    // Not in any scroll area - block all horizontal movement
                    const deltaX = Math.abs(e.touches[0].clientX - startX);
                    const deltaY = Math.abs(e.touches[0].clientY - startY);
                    
                    // If horizontal movement is greater than vertical, prevent it
                    if (deltaX > deltaY && deltaX > 10) {
                        e.preventDefault();
                    }
                }
            }, { passive: false });
            
            // Prevent wheel horizontal scrolling
            document.addEventListener('wheel', preventHorizontalSwipe, { passive: false });
            
            // Initially disable interactive elements until authentication state is confirmed.
            toggleInteractiveElements(false, false);
            console.log(`JCHAT_DEBUG: Initial postContentInput disabled state: ${postContentInput ? postContentInput.disabled : 'N/A (element not found)'}`);

            // Set active class for current page in sidebar.
            const currentPagePath = window.location.pathname;
            const navItems = (sidebarNavItems && typeof sidebarNavItems.forEach === 'function')
                ? sidebarNavItems
                : document.querySelectorAll('.sidebar-nav-item');
            navItems.forEach(item => {
                if (item.getAttribute('href') === currentPagePath) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });

            // Call Overlay Button Listeners (NEW)
            if (acceptCallBtn) acceptCallBtn.addEventListener('click', acceptCall);
            if (declineCallBtn) declineCallBtn.addEventListener('click', declineCall);
            if (endCallBtn) endCallBtn.addEventListener('click', () => endCall(true)); // Pass true to update Firestore.
            if (toggleMuteBtn) toggleMuteBtn.addEventListener('click', toggleMute);
            if (toggleVideoBtn) toggleVideoBtn.addEventListener('click', toggleVideo);

            // Notification Dropdown Event Listeners
            const notificationToggle = document.getElementById('notificationToggle');
            const notificationDropdown = document.getElementById('notificationDropdown');
            
            if (notificationToggle) {
                notificationToggle.addEventListener('click', (e) => {
                    const href = notificationToggle.getAttribute('href');
                    if (!href || href === '#' || href === '') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (notificationDropdown.style.display === 'none' || !notificationDropdown.style.display) {
                            showNotificationDropdown();
                        } else {
                            hideNotificationDropdown();
                        }
                    }
                });
            }
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (notificationDropdown && !notificationDropdown.contains(e.target) && 
                    !notificationToggle.contains(e.target)) {
                    hideNotificationDropdown();
                }
            });
            
            // Close dropdown on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && notificationDropdown && 
                    notificationDropdown.style.display !== 'none') {
                    hideNotificationDropdown();
                }
            });

            // Announcement System Event Listeners
            const dismissAnnouncementBtn = document.getElementById('dismissAnnouncementBtn');
            if (dismissAnnouncementBtn) {
                dismissAnnouncementBtn.addEventListener('click', dismissGlobalAnnouncement);
            }
        });

        // Listen for changes in local storage (e.g., theme changes from other tabs).
        window.addEventListener('storage', (event) => {
            if (event.key === 'jchat-theme') {
                const newTheme = event.newValue || 'theme-dark-mode';
                if (newTheme === 'theme-light-mode' || newTheme === 'theme-dark-mode') {
                    setTheme(newTheme);
                }
            }
        });
        // Cleanup resources before the page unloads.
        window.addEventListener('beforeunload', async () => {
            // Detach all Firestore listeners before the page unloads.
            unsubscribeListeners.forEach(unsubscribe => {
                if (typeof unsubscribe === 'function') {
                    unsubscribe();
                }
            });
            unsubscribeListeners = []; // Clear the array.
            console.log("JCHAT_DEBUG: All Firestore listeners detached.");
            if (inspirationIntervalId) {
                clearInterval(inspirationIntervalId);
                console.log("JCHAT_DEBUG: Inspiration interval cleared.");
            }
            if (dailyBonusCountdownInterval) {
                clearInterval(dailyBonusCountdownInterval);
                console.log("JCHAT_DEBUG: Daily bonus countdown interval cleared.");
            }

            // Ensure inCall status is turned off when leaving the page.
            if (currentUser && currentUser.uid) {
                const currentUserPublicProfileRef = doc(db, "artifacts", appId, "public", "data", "users", currentUser.uid);
                await updateDoc(currentUserPublicProfileRef, { inCall: false }).catch(e => console.error("Failed to update inCall status on beforeunload:", e));
            }
            // End any active WebRTC call.
            if (callState !== 'idle') {
                await endCall(false); // End call without updating Firestore status to avoid conflicts during unload.
            }
        });

        // Event listeners for specific UI buttons.
        if (sharePostInspirationButton) {
            sharePostInspirationButton.addEventListener('click', () => {
                if (!isAuthReady) { showMessageBox("Please log in to share inspiration.", 'error'); return; }
                openShareInspirationModal();
            });
        }
        if (customizeInspirationButton) customizeInspirationButton.addEventListener('click', openCustomizeModal);
        if (cancelCustomizeButton) cancelCustomizeButton.addEventListener('click', closeCustomizeModal);
        if (saveCustomizeButton) saveCustomizeButton.addEventListener('click', saveInspirationType);
        if (claimDailyBonusButton) claimDailyBonusButton.addEventListener('click', handleClaimDailyBonusClick);

        // Close customization modal if clicking outside its content.
        if (customizeInspirationModal) {
            customizeInspirationModal.addEventListener('click', (event) => {
                if (event.target === customizeInspirationModal) {
                    closeCustomizeModal();
                }
            });
        }
        // Share modal handlers
        function openShareInspirationModal() {
            const modal = document.getElementById('shareInspirationModal');
            if (!modal) return;
            const q = inspirationQuoteElement ? inspirationQuoteElement.textContent : '';
            const a = inspirationAuthorElement ? inspirationAuthorElement.textContent : '';
            const prevQ = document.getElementById('sharePreviewQuote');
            const prevA = document.getElementById('sharePreviewAuthor');
            if (prevQ) prevQ.textContent = q;
            if (prevA) prevA.textContent = a;
            modal.style.display = 'flex';
            setTimeout(()=> modal.classList.add('active'), 0);
        }
        function closeShareInspirationModal() {
            const modal = document.getElementById('shareInspirationModal');
            if (!modal) return;
            modal.classList.remove('active');
            setTimeout(()=> modal.style.display = 'none', 200);
        }
        async function copyCurrentInspirationToClipboard() {
            const text = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
            try { await navigator.clipboard.writeText(text); showMessageBox('Copied to clipboard!', 'success'); }
            catch { showMessageBox('Copy failed. Select and copy manually.', 'warning'); }
        }
        function navigateToChatWithPrefill(partnerUid, messageText) {
            const url = new URL('/Chat.html', window.location.origin);
            url.searchParams.set('partner', partnerUid);
            url.searchParams.set('prefill', messageText);
            window.location.href = url.toString();
        }
        function chatIdFor(u1, u2) { return [u1, u2].sort().join('_'); }
        async function ensureChatDocForHome(chatId, friendId) {
            try {
                const chatDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'chats', chatId);
                const snap = await getDoc(chatDocRef);
                if (!snap.exists()) {
                    await setDoc(chatDocRef, { participants: [currentUser.uid, friendId].sort(), createdAt: serverTimestamp(), updatedAt: serverTimestamp() }, { merge: true });
                } else {
                    await updateDoc(chatDocRef, { updatedAt: serverTimestamp() });
                }
            } catch {}
        }
        async function sendQuoteToFriend(friendId) {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            const quote = inspirationQuoteElement ? inspirationQuoteElement.textContent : '';
            const authorRaw = inspirationAuthorElement ? inspirationAuthorElement.textContent : '';
            const authorClean = authorRaw.replace(/^[-\s]*/,'').replace(/\bJCHAT\b/gi,'').trim();
            const messageText = authorClean ? `${quote} - ${authorClean}`.trim() : `${quote}`.trim();
            const chatId = chatIdFor(currentUser.uid, friendId);
            const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'chats', chatId, 'messages');
            await ensureChatDocForHome(chatId, friendId);
            await addDoc(messagesRef, { text: messageText, senderId: currentUser.uid, receiverId: friendId, timestamp: serverTimestamp(), status: 'sent', chatId });
            showMessageBox('Sent to friend!', 'success');
        }
        async function openFriendPickerAndSend() {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            const friendPicker = document.getElementById('friendPicker');
            if (!friendPicker) { showMessageBox('Friend picker UI not found.', 'error'); return; }
            friendPicker.innerHTML = '<div style="opacity:0.8;">Loading friends...</div>';
            friendPicker.style.display = 'block';
            try {
                // Use global Find_Friends logic (public/data/friends) like Chat.html
                const publicFriendsRef = collection(db, 'artifacts', appId, 'public', 'data', 'friends');
                const snap = await getDocs(publicFriendsRef);
                const myFriends = new Set();
                snap.forEach(docSnap => {
                    const f = docSnap.data();
                    if (!f) return;
                    if (f.user1Id === currentUser.uid) myFriends.add(f.user2Id);
                    else if (f.user2Id === currentUser.uid) myFriends.add(f.user1Id);
                });
                const friendIds = Array.from(myFriends);
                if (!friendIds.length) {
                    friendPicker.innerHTML = '<div style="opacity:0.8;">No friends yet.</div>';
                    return;
                }
                const profiles = await Promise.all(friendIds.map(async (fid) => {
                    const pRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', fid);
                    const pSnap = await getDoc(pRef);
                    const p = pSnap.exists() ? pSnap.data() : {};
                    return {
                        id: fid,
                        displayName: p.displayName || p.username || 'JCHAT User',
                        username: p.username || '',
                        profilePicId: p.profilePicId || null
                    };
                }));
                // Build rows with search
                friendPicker.innerHTML = '';
                const search = document.createElement('input');
                search.type = 'text';
                search.placeholder = 'Search friends';
                search.style.cssText = 'width:100%;padding:8px 10px;border-radius:8px;border:1px solid var(--border-light);margin-bottom:6px;background:var(--input-background);color:var(--white)';
                friendPicker.appendChild(search);
                const listWrap = document.createElement('div');
                friendPicker.appendChild(listWrap);
                function renderList(filter='') {
                    listWrap.innerHTML = '';
                    profiles
                        .filter(f => (f.displayName||'').toLowerCase().includes(filter.toLowerCase()) || (f.username||'').toLowerCase().includes(filter.toLowerCase()))
                        .forEach(f => {
                            const initial = (f.displayName||'U').charAt(0).toUpperCase();
                            const imgUrl = f.profilePicId ? getCloudinaryImageUrl(f.profilePicId, 'w_60,h_60,c_fill,g_face,r_max') : `https://placehold.co/40x40/ff2e92/ffffff?text=${initial}`;
                            const row = document.createElement('div');
                            row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.05);margin-bottom:6px;gap:10px;';
                            row.innerHTML = `<div style=\"display:flex;align-items:center;gap:10px;\"><img src=\"${imgUrl}\" alt=\"${f.displayName}\" loading=\"lazy\" decoding=\"async\" style=\"width:36px;height:36px;border-radius:50%;object-fit:cover;border:1px solid var(--border-light);\"><span>${f.displayName}</span></div><button class=\"btn\" data-fid=\"${f.id}\">Send</button>`;
                            row.querySelector('button').addEventListener('click', async (e) => {
                                const btn = e.currentTarget;
                                btn.disabled = true;
                                try { await sendQuoteToFriend(f.id); btn.textContent = 'Sent'; }
                                catch (err) { btn.disabled = false; showMessageBox('Failed to send.', 'error'); }
                            });
                            listWrap.appendChild(row);
                        });
                }
                renderList('');
                search.addEventListener('input', () => renderList(search.value));
            } catch (e) {
                friendPicker.innerHTML = '<div style="color:salmon;">Failed to load friends.</div>';
                console.error('Friend picker load failed', e);
            }
        }
        async function openPostComposerWithPrefill() {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in to post.', 'warning'); return; }
            if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox('Post creation is disabled by administrators.', 'warning'); return; }
            if (postCreationSection && postContentInput) {
                const text = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
                postCreationSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                postContentInput.value = text;
                const addImg = await showConfirmationModal('Add Image', 'Add an image to this post?');
                if (addImg && postMediaUpload) postMediaUpload.click();
                closeShareInspirationModal();
                showMessageBox('Composer prefilled. You can edit and post now.', 'info');
            } else {
                showMessageBox('Post composer not available on this page.', 'warning');
            }
        }
        const copyInspirationBtn = document.getElementById('copyInspirationBtn');
        const sendToFriendBtn = document.getElementById('sendToFriendBtn');
        const postInspirationBtn = document.getElementById('postInspirationBtn');
        const saveInspirationBtn = document.getElementById('saveInspirationBtn');
        const closeShareModalBtn = document.getElementById('closeShareModalBtn');
        const shareModal = document.getElementById('shareInspirationModal');
        const friendPicker = document.getElementById('friendPicker');
        if (copyInspirationBtn) copyInspirationBtn.addEventListener('click', copyCurrentInspirationToClipboard);
        if (sendToFriendBtn) sendToFriendBtn.addEventListener('click', openFriendPickerAndSend);
        if (postInspirationBtn) postInspirationBtn.addEventListener('click', openPostComposerWithPrefill);
        if (saveInspirationBtn) saveInspirationBtn.addEventListener('click', async () => {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            try {
                const text = `${inspirationQuoteElement ? inspirationQuoteElement.textContent : ''} ${inspirationAuthorElement ? inspirationAuthorElement.textContent : ''}`.trim();
                const savedRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saved_inspirations', `${Date.now()}`);
                await setDoc(savedRef, { text, createdAt: serverTimestamp() });
                showMessageBox('Inspiration saved.', 'success');
            } catch (e) {
                showMessageBox('Failed to save inspiration.', 'error');
            }
        });
        if (closeShareModalBtn) closeShareModalBtn.addEventListener('click', closeShareInspirationModal);
        if (shareModal) shareModal.addEventListener('click', (evt)=> { if (evt.target === shareModal) closeShareInspirationModal(); });

        if (createPostButton) createPostButton.addEventListener('click', createNewPost);

        if (cancelEditPostButton) cancelEditPostButton.addEventListener('click', closeEditPostModal);
        if (saveEditedPostButton) saveEditedPostButton.addEventListener('click', saveEditedPost);

        // Close edit post modal if clicking outside its content.
        if (editPostModal) {
            editPostModal.addEventListener('click', (event) => {
                if (event.target === editPostModal) {
                    closeEditPostModal();
                }
            });
        }

        // Sidebar toggle logic - Fixed to prevent auto-switching during scroll
        let sidebarToggleState = false; // Track sidebar state explicitly
        let isScrolling = false; // Track if user is scrolling
        let scrollTimeout; // Timeout for scroll detection

        let sidebarPrevFocus = null;
        function focusTrap(e){
            if (e.key !== 'Tab') return;
            const focusable = sidebarNav.querySelectorAll('a,button,[tabindex]:not([tabindex="-1"])');
            if (!focusable.length) return;
            const first = focusable[0], last = focusable[focusable.length-1];
            if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
            else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
        }
        function openSidebar(){
            sidebarToggleState = true;
            document.body.classList.add('sidebar-open');
            sidebarNav.classList.remove('sidebar-hidden');
            sidebarNav.classList.add('sidebar-visible');
            const backdrop = document.getElementById('sidebarBackdrop');
            if (backdrop){ backdrop.classList.add('show'); backdrop.addEventListener('click', closeSidebar, { once:true }); }
            sidebarPrevFocus = document.activeElement;
            const firstLink = sidebarNav.querySelector('.sidebar-nav-item');
            if (firstLink) firstLink.focus();
            document.addEventListener('keydown', handleEscClose);
            document.addEventListener('keydown', focusTrap);
        }
        function closeSidebar(){
            sidebarToggleState = false;
            document.body.classList.remove('sidebar-open');
            sidebarNav.classList.remove('sidebar-visible');
            sidebarNav.classList.add('sidebar-hidden');
            const backdrop = document.getElementById('sidebarBackdrop');
            if (backdrop){ backdrop.classList.remove('show'); }
            document.removeEventListener('keydown', handleEscClose);
            document.removeEventListener('keydown', focusTrap);
            if (sidebarPrevFocus && typeof sidebarPrevFocus.focus === 'function') sidebarPrevFocus.focus();
        }
        function handleEscClose(e){ if (e.key === 'Escape') closeSidebar(); }
        function toggleSidebar() {
            if (isScrolling) { console.log('JCHAT_DEBUG: Sidebar toggle blocked during scroll'); return; }
            if (sidebarToggleState) closeSidebar(); else openSidebar();
        }

        // Prevent sidebar auto-toggle during scroll
        function handleScroll() {
            isScrolling = true;
            
            // Clear existing timeout
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            // Set timeout to allow sidebar toggle after scroll stops
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
            }, 150); // 150ms delay after scroll stops
        }

        // Enhanced scroll event listener with passive option
        if (typeof window !== 'undefined') {
            window.addEventListener('scroll', handleScroll, { passive: true });
        }

        // Sidebar event listeners moved inside DOMContentLoaded event

        // Export helpers (CSV/JSON) for posts
        function toCsv(rows) {
            if (!rows.length) return '';
            const headers = Object.keys(rows[0]);
            const escape = (v) => {
                if (v == null) return '';
                const s = String(v).replace(/"/g, '""');
                return /[",\n]/.test(s) ? `"${s}"` : s;
            };
            const lines = [headers.join(',')];
            for (const r of rows) lines.push(headers.map(h => escape(r[h])).join(','));
            return lines.join('\n');
        }
        async function fetchAllPostsForExport(filters) {
            const postsCollectionRef = collection(db, "artifacts", appId, "public", "data", "posts");
            const qAll = query(postsCollectionRef, orderBy("timestamp", "desc"));
            const snap = await getDocs(qAll);
            const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            return items.filter(p => {
                const pType = p.mediaType ? p.mediaType : 'text';
                if (filters.type && filters.type !== 'all' && pType !== filters.type) return false;
                if (filters.search && !(p.content || '').toLowerCase().includes(filters.search)) return false;
                if (filters.from || filters.to) {
                    const ts = p.timestamp ? p.timestamp.toDate() : null;
                    if (!ts) return false;
                    if (filters.from && ts < filters.from) return false;
                    if (filters.to && ts > filters.to) return false;
                }
                return true;
            });
        }

        function getPostFilterState() {
            const type = postTypeFilter?.value || 'all';
            const search = (postSearchInput?.value || '').toLowerCase();
            let from = null, to = null;
            if (postDateFromInput?.value) from = new Date(postDateFromInput.value + 'T00:00:00');
            if (postDateToInput?.value) to = new Date(postDateToInput.value + 'T23:59:59.999');
            return { type, search, from, to };
        }

        // Wire controls
        document.addEventListener('DOMContentLoaded', () => {
            if (postTypeFilter) postTypeFilter.addEventListener('change', fetchAndDisplayPosts);
            if (postSearchInput) postSearchInput.addEventListener('input', fetchAndDisplayPosts);
            if (postDateFromInput) postDateFromInput.addEventListener('change', fetchAndDisplayPosts);
            if (postDateToInput) postDateToInput.addEventListener('change', fetchAndDisplayPosts);
            if (showFollowedOnlyCheckbox) showFollowedOnlyCheckbox.addEventListener('change', fetchAndDisplayPosts);
            if (exportPostsCsvButton) exportPostsCsvButton.addEventListener('click', async () => {
                if (!currentUser && !isAuthReady) return showMessageBox('Please log in.', 'warning');
                showMessageBox('Preparing CSV export...', 'loading', true);
                try {
                    const filters = getPostFilterState();
                    const items = await fetchAllPostsForExport(filters);
                    const rows = items.map(p => ({
                        id: p.id,
                        type: p.mediaType ? p.mediaType : 'text',
                        content: p.content || '',
                        authorId: p.authorId || '',
                        timestamp: p.timestamp ? p.timestamp.toDate().toISOString() : ''
                    }));
                    const csv = toCsv(rows);
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-posts-${Date.now()}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('CSV downloaded.', 'success');
                } catch (e) {
                    console.error(e);
                    showMessageBox('Failed to export CSV.', 'error');
                }
            });
            if (exportPostsJsonButton) exportPostsJsonButton.addEventListener('click', async () => {
                if (!currentUser && !isAuthReady) return showMessageBox('Please log in.', 'warning');
                showMessageBox('Preparing JSON export...', 'loading', true);
                try {
                    const filters = getPostFilterState();
                    const items = await fetchAllPostsForExport(filters);
                    const json = JSON.stringify(items.map(p => ({
                        id: p.id,
                        type: p.mediaType ? p.mediaType : 'text',
                        content: p.content || '',
                        authorId: p.authorId || '',
                        timestamp: p.timestamp ? p.timestamp.toDate().toISOString() : ''
                    })), null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `jchat-posts-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showMessageBox('JSON downloaded.', 'success');
                } catch (e) {
                    console.error(e);
                    showMessageBox('Failed to export JSON.', 'error');
                }
            });
        });

        // Save/Unsave post helper
        async function toggleSavePost(postId, shouldSave) {
            if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
            const savedRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saved_posts', postId);
            if (shouldSave) {
                await setDoc(savedRef, { savedAt: serverTimestamp() }).catch(e => console.error('Save failed', e));
                showMessageBox('Post saved.', 'success');
            } else {
                await deleteDoc(savedRef).catch(e => console.error('Unsave failed', e));
                showMessageBox('Removed from saved.', 'info');
            }
        }

        // Enhance post content: link hashtags
        function linkHashtags(text) {
            if (!text) return '';
            return text.replace(/(^|\s)#(\w{2,30})/g, (m, p1, tag) => `${p1}<a href="#" class="hashtag-link" data-tag="${tag}">#${tag}</a>`);
        }

        // Link @mentions to Profile
        function linkMentions(text) {
            if (!text) return '';
            return text.replace(/(^|\s)@(\w{2,30})/g, (m, p1, handle) => `${p1}<a href="/Profile.html?handle=${handle}" class="mention-link" data-handle="${handle}">@${handle}</a>`);
        }

        // Track hashtags for trending display
        function updateTrendingHashtags(allPosts) {
            const counts = new Map();
            allPosts.forEach(p => {
                const matches = (p.content || '').match(/#\w{2,30}/g);
                if (matches) matches.forEach(t => {
                    counts.set(t, (counts.get(t) || 0) + 1);
                });
            });
            const top = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5);
            if (trendingHashtagsDiv) {
                if (top.length === 0) { trendingHashtagsDiv.textContent = ''; return; }
                const followed = new Set(JSON.parse(localStorage.getItem('jchat_followed_tags')||'[]').map(t=>t.toLowerCase()));
                trendingHashtagsDiv.innerHTML = 'Trending: ' + top.map(([tag]) => {
                    const t = tag.substring(1).toLowerCase();
                    const isFollowed = followed.has('#'+t);
                    return `<a href="#" class="hashtag-link" data-tag="${t}">${tag}</a> <button class="follow-tag-btn" data-tag="${t}">${isFollowed?'Unfollow':'Follow'}</button>`;
                }).join(' • ');
            }
        }
        // Feed skeleton helpers
        function showFeedSkeletons(count = 3) {
            try {
                if (!postsFeed) return;
                let holder = document.getElementById('feedSkeletons');
                if (holder) holder.remove();
                holder = document.createElement('div');
                holder.id = 'feedSkeletons';
                for (let i = 0; i < count; i++) {
                    const card = document.createElement('div');
                    card.className = 'post-skeleton-card';
                    card.innerHTML = `
                        <div class="post-skeleton-header">
                            <div class="skeleton post-skeleton-avatar"></div>
                            <div style="flex:1; display:flex; flex-direction:column; gap:6px;">
                                <div class="skeleton post-skeleton-line" style="width:30%"></div>
                                <div class="skeleton post-skeleton-line" style="width:18%"></div>
                            </div>
                        </div>
                        <div class="skeleton post-skeleton-line" style="width:90%"></div>
                        <div class="skeleton post-skeleton-line" style="width:80%"></div>
                        <div class="skeleton post-skeleton-media"></div>
                    `;
                    holder.appendChild(card);
                }
                if (loadingPostsMessage) loadingPostsMessage.style.display = 'none';
                postsFeed.insertBefore(holder, postsFeed.firstChild);
            } catch (_) {}
        }
        function hideFeedSkeletons() {
            try { document.getElementById('feedSkeletons')?.remove(); } catch (_) {}
        }

        // Extend renderPost to link hashtags and mentions
        const _origRenderPost = renderPost;
        renderPost = function(post, postId) {
            const el = _origRenderPost(post, postId);
            const textDiv = el.querySelector('.post-content-text p');
            if (textDiv && textDiv.textContent) {
                const linked = linkMentions(linkHashtags(textDiv.textContent));
                textDiv.innerHTML = linked;
            }
            return el;
        }

        // Mentions autocomplete (basic)
        function setupMentionsAutocomplete() {
            if (!postContentInput) return;
            let dropdown;
            postContentInput.addEventListener('input', async () => {
                const value = postContentInput.value;
                const atIdx = value.lastIndexOf('@');
                if (atIdx === -1) { if (dropdown) dropdown.remove(); return; }
                const fragment = value.slice(atIdx + 1);
                if (!/^\w{1,30}$/.test(fragment)) { if (dropdown) dropdown.remove(); return; }
                // Query top users by prefix (fallback local placeholder if Firestore unavailable)
                let suggestions = [];
                try {
                    const usersRef = collection(db, 'artifacts', appId, 'public', 'users');
                    // Simple contains filter (limit): Firestore doesn't support prefix easily; fetch limited and filter client-side
                    const snap = await getDocs(query(usersRef, orderBy('username'), limit(20)));
                    suggestions = snap.docs
                        .map(d => d.data())
                        .filter(u => (u.username || '').toLowerCase().startsWith(fragment.toLowerCase()))
                        .slice(0, 5)
                        .map(u => ({ username: u.username, handle: (u.handle || u.username || '').replace(/\s+/g,'') }));
                } catch (_) {
                    suggestions = [];
                }
                if (!dropdown) {
                    dropdown = document.createElement('div');
                    dropdown.style.cssText = 'position:absolute; z-index:1000; background: var(--card-background); border:1px solid var(--border-light); border-radius:8px; padding:6px; display:flex; flex-direction:column; gap:4px; max-height:180px; overflow:auto;';
                    postContentInput.parentElement.style.position = 'relative';
                    postContentInput.parentElement.appendChild(dropdown);
                }
                dropdown.innerHTML = suggestions.map(s => `<button type="button" class="mention-suggestion" data-handle="${s.handle}">@${s.username}</button>`).join('') || '<div style="color:var(--text-light);padding:6px;">No matches</div>';
                dropdown.querySelectorAll('.mention-suggestion').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const handle = btn.dataset.handle;
                        postContentInput.value = value.slice(0, atIdx) + '@' + handle + ' ' + value.slice(atIdx + 1 + fragment.length);
                        dropdown.remove(); dropdown = null;
                        postContentInput.focus();
                    });
                });
            });
            document.addEventListener('click', (e) => {
                if (dropdown && !e.target.closest('.mention-suggestion') && e.target !== postContentInput) {
                    dropdown.remove(); dropdown = null;
                }
            });
        }

        // Offline post queue with background retry
        const OFFLINE_POST_QUEUE_KEY = 'jchat_offline_post_queue_v1';
        function enqueueOfflinePost(data) {
            try {
                const q = JSON.parse(localStorage.getItem(OFFLINE_POST_QUEUE_KEY) || '[]');
                q.push({ ...data, queuedAt: Date.now() });
                localStorage.setItem(OFFLINE_POST_QUEUE_KEY, JSON.stringify(q));
                showMessageBox('Post queued. It will be sent when you are online.', 'info');
            } catch (_) {}
        }
        async function flushOfflineQueue() {
            try {
                const q = JSON.parse(localStorage.getItem(OFFLINE_POST_QUEUE_KEY) || '[]');
                if (!q.length) return;
                const remaining = [];
                for (const item of q) {
                    try {
                        await createNewPostDirect(item.content, item.mediaUrl, item.mediaType, item.pollOptions || null);
                    } catch (_) {
                        remaining.push(item);
                    }
                }
                localStorage.setItem(OFFLINE_POST_QUEUE_KEY, JSON.stringify(remaining));
                if (remaining.length === 0) showMessageBox('All queued posts sent.', 'success');
            } catch (_) {}
        }
        window.addEventListener('online', flushOfflineQueue);

        // Wrapper used by queue to bypass UI state
        async function createNewPostDirect(content, mediaUrl, mediaType, pollOptions) {
            if (!isAuthReady || !currentUser || !currentUserProfileData) throw new Error('not ready');
            const postsRef = collection(db, 'artifacts', appId, 'public', 'posts');
            const newPost = {
                authorId: currentUser.uid,
                username: currentUserProfileData.displayName || 'Anonymous',
                profilePhoto: currentUserProfileData.profilePicId || null,
                content: content,
                mediaUrl: mediaUrl || null,
                mediaType: mediaType || null,
                pollOptions: pollOptions || null,
                reactions: {},
                commentsCount: 0,
                createdAt: serverTimestamp(),
                isEdited: false
            };
            await addDoc(postsRef, newPost);
        }

        // Hook into existing post create to handle offline mode
        const _origCreateNewPost = createNewPost;
        createNewPost = async function() {
            try {
                await _origCreateNewPost();
            } catch (err) {
                if (!navigator.onLine) {
                    // Gather current composer state
                    const content = (postContentInput && postContentInput.value) || '';
                    const mediaUrl = (mediaImagePreview && mediaImagePreview.src && mediaImagePreview.style.display !== 'none') ? mediaImagePreview.src : ((mediaVideoPreview && mediaVideoPreview.src && mediaVideoPreview.style.display !== 'none') ? mediaVideoPreview.src : null);
                    const mediaType = mediaUrl ? (mediaImagePreview && mediaImagePreview.style.display !== 'none' ? 'image' : 'video') : null;
                    enqueueOfflinePost({ content, mediaUrl, mediaType });
                } else {
                    throw err;
                }
            }
        }
        // Notification permission prompt (deferred)
        async function requestNotificationPermissionIfNeeded() {
            try {
                if (!('Notification' in window)) return;
                if (Notification.permission === 'default') {
                    // Ask only after some engagement: e.g., after first post list render
                    setTimeout(() => {
                        Notification.requestPermission().catch(()=>{});
                    }, 3000);
                }
            } catch (_) {}
        }

        // Initialize enhancements on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            setupMentionsAutocomplete();
            requestNotificationPermissionIfNeeded();
            // Fetch system settings early to render announcement ASAP
            if (navigator.onLine) fetchSystemSettings().catch(()=>{});
        });

        // Comment like/unlike with user-specific toggle
        async function likeComment(postId, commentId, buttonEl) {
            try {
                if (!isAuthReady || !currentUser || !currentUserProfileData) { showMessageBox('Please log in.', 'warning'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox('Reactions are disabled by admin.', 'warning'); return; }
                const commentRef = doc(db, 'artifacts', appId, 'public', 'data', 'posts', postId, 'comments', commentId);
                const userLikeRef = doc(db, 'artifacts', appId, 'public', 'data', 'posts', postId, 'comments', commentId, 'userLikes', currentUser.uid);
                let delta = 0;
                let activityType = '';
                let xp = 0, jc = 0;
                await runTransaction(db, async (transaction) => {
                    const commentSnap = await transaction.get(commentRef);
                    const userLikeSnap = await transaction.get(userLikeRef);
                    if (!commentSnap.exists()) throw new Error('Comment not found');
                    const curr = commentSnap.data();
                    let likes = curr.likes || 0;
                    if (userLikeSnap.exists()) {
                        // Unlike
                        likes = Math.max(0, likes - 1);
                        transaction.update(commentRef, { likes });
                        transaction.delete(userLikeRef);
                        delta = -1; activityType = 'comment_unlike'; xp = -1; jc = -1;
                    } else {
                        // Like
                        likes = (likes || 0) + 1;
                        transaction.update(commentRef, { likes });
                        transaction.set(userLikeRef, { userId: currentUser.uid, timestamp: serverTimestamp() });
                        delta = 1; activityType = 'comment_like'; xp = 1; jc = 1;
                    }
                });
                // Update UI optimistically
                if (buttonEl) {
                    const countEl = buttonEl.querySelector('.comment-like-count');
                    if (countEl) countEl.textContent = String(Math.max(0, (Number(countEl.textContent||'0') + delta)));
                    buttonEl.classList.toggle('liked', delta > 0);
                }
                if (xp !== 0 || jc !== 0) {
                    await createPendingActivityReward(currentUser.uid, currentUserProfileData.username, activityType, xp, jc, commentId, postId);
                }
            } catch (e) {
                console.error('JCHAT_ERROR: likeComment failed', e);
                showMessageBox('Failed to update like. Please retry.', 'error');
            }
        }

        // Hook into document click for save and hashtag
        document.addEventListener('click', (ev) => {
            const saveBtn = ev.target.closest('.save-post-button');
            if (saveBtn) {
                const pid = saveBtn.dataset.postId;
                const saved = saveBtn.classList.toggle('saved');
                localStorage.setItem(`saved-post-${pid}`, saved ? '1' : '0');
                toggleSavePost(pid, saved);
                return;
            }
            const tagLink = ev.target.closest('.hashtag-link');
            if (tagLink) {
                const tag = tagLink.dataset.tag;
                if (postSearchInput) postSearchInput.value = `#${tag}`;
                fetchAndDisplayPosts();
                return;
            }
            const followBtn = ev.target.closest('.follow-tag-btn');
            if (followBtn) {
                const tag = '#' + followBtn.dataset.tag.toLowerCase();
                const followed = new Set(JSON.parse(localStorage.getItem('jchat_followed_tags')||'[]').map(t=>t.toLowerCase()));
                if (followed.has(tag)) followed.delete(tag); else followed.add(tag);
                localStorage.setItem('jchat_followed_tags', JSON.stringify([...followed]));
                updateTrendingHashtags([]); // Re-render controls with new button labels
                fetchAndDisplayPosts();
                return;
            }
            const replyBtn = ev.target.closest('.comment-reply-button');
            if (replyBtn) {
                const postId = replyBtn.dataset.postId;
                const commentId = replyBtn.dataset.commentId;
                addComment.replyContext = { postId, commentId };
                const input = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
                if (input) {
                    input.focus();
                    input.placeholder = 'Replying...';
                }
                return;
            }
            const likeBtn = ev.target.closest('.comment-like-button');
            if (likeBtn) {
                const postId = likeBtn.dataset.postId;
                const commentId = likeBtn.dataset.commentId;
                likeComment(postId, commentId, likeBtn);
                return;
            }
            const reactBtn = ev.target.closest('.comment-reaction-button');
            if (reactBtn) {
                reactToComment(reactBtn.dataset.postId, reactBtn.dataset.commentId, reactBtn.dataset.type, reactBtn);
                return;
            }
        });

                    // Clickable: level chip progress opens Levels
            document.addEventListener('click', (ev) => {
                const el = ev.target.closest('.chip.level-chip .chip-progress');
                if (el) window.location.href = '/Levels.html';
            });

            // Modify posts onSnapshot to compute trending + filter saved only
        const _origFetchAndDisplayPosts = fetchAndDisplayPosts;
        fetchAndDisplayPosts = async function() {
            showFeedSkeletons();
            try {
                await _origFetchAndDisplayPosts();
            } finally {
                hideFeedSkeletons();
            }
            // After initial render, we cannot easily intercept onSnapshot pipeline; recompute trending client-side from DOM
            const cards = [...(postsFeed?.querySelectorAll('.post-card') || [])];
            const posts = cards.map(c => ({
                id: c.dataset.postId,
                content: (c.querySelector('.post-content-text p')?.textContent) || ''
            }));
            updateTrendingHashtags(posts);
        }

        // Re-trigger fetch when toggling saved only
        document.addEventListener('DOMContentLoaded', () => {
            if (showSavedOnlyCheckbox) showSavedOnlyCheckbox.addEventListener('change', fetchAndDisplayPosts);
        });

        // Theme selector
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            const saved = localStorage.getItem('jchat-theme');
            if (saved && [...themeSelect.options].some(o => o.value === saved)) {
                themeSelect.value = saved;
            }
            themeSelect.addEventListener('change', () => applyTheme(themeSelect.value));
        }

        // Streaks & Quests basic implementation
        const streakInfo = document.getElementById('streakInfo');
        const questsList = document.getElementById('questsList');
        async function updateStreakAndQuestsUI() {
            if (!currentUser || !currentUserProfileData) { if (streakInfo) streakInfo.textContent = 'Login to start a streak.'; return; }
            try {
                const streakDocRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'streak');
                const streakSnap = await getDoc(streakDocRef);
                const today = new Date(); today.setHours(0,0,0,0);
                let streakCount = 0; let lastDate = null;
                if (streakSnap.exists()) {
                    const d = streakSnap.data();
                    streakCount = d.count || 0;
                    lastDate = d.lastDate ? d.lastDate.toDate() : null;
                }
                // Increment if lastDate is before today
                const needIncrement = !lastDate || (new Date(lastDate.setHours(0,0,0,0)) < today);
                if (needIncrement) {
                    await setDoc(streakDocRef, { count: streakCount + 1, lastDate: serverTimestamp() }, { merge: true });
                    streakCount += 1;
                }
                if (streakInfo) streakInfo.textContent = `Current streak: ${streakCount} day${streakCount===1?'':'s'}`;
            } catch (e) { console.error('Streak update failed', e); }

            // Quests (static weekly set)
            const weekQuests = [
                { id:'q1', title:'React 10 times', target:10 },
                { id:'q2', title:'Comment 5 times', target:5 },
                { id:'q3', title:'Create 2 posts', target:2 },
            ];
            if (questsList) {
                questsList.innerHTML = '';
                weekQuests.forEach(q => {
                    const progress = 0; // placeholder; wire to activity logs later
                    const pct = Math.min(100, Math.round((progress / q.target) * 100));
                    const row = document.createElement('div');
                    row.className = 'quest-item';
                    row.innerHTML = `<span>${q.title}</span><div class="quest-progress"><div style="width:${pct}%"></div></div><span>${progress}/${q.target}</span>`;
                    questsList.appendChild(row);
                });
            }
        }

        // Daily Spin
        const spinNowButton = document.getElementById('spinNowButton');
        const spinStatus = document.getElementById('spinStatus');
        if (spinNowButton) {
            spinNowButton.addEventListener('click', async () => {
                if (!currentUser) { showMessageBox('Login to spin.', 'warning'); return; }
                const spinRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'engagement', 'daily_spin');
                const snap = await getDoc(spinRef);
                const now = new Date();
                if (snap.exists()) {
                    const last = snap.data().lastSpinAt?.toDate();
                    if (last) {
                        const since = now - last;
                        if (since < 24*60*60*1000) {
                            const hrs = Math.ceil((24*60*60*1000 - since)/3600000);
                            if (spinStatus) spinStatus.textContent = `Come back in ~${hrs}h.`;
                            return;
                        }
                    }
                }
                // Weighted rewards
                const rewards = [ {j:5, w:40}, {j:10, w:30}, {j:20, w:20}, {j:50, w:8}, {j:100, w:2} ];
                const totalW = rewards.reduce((a,b)=>a+b.w,0);
                let r = Math.random()*totalW, pick = rewards[0];
                for (const it of rewards) { if (r < it.w) { pick = it; break; } r -= it.w; }
                // Credit user
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'profiles', 'user_profile');
                    await runTransaction(db, async (trx) => {
                        const ps = await trx.get(profileRef);
                        const cur = ps.exists()? (ps.data().jCoins||0):0;
                        trx.update(profileRef, { jCoins: cur + pick.j, updatedAt: serverTimestamp() });
                    });
                    await setDoc(spinRef, { lastSpinAt: serverTimestamp() }, { merge: true });
                    if (spinStatus) spinStatus.textContent = `You won ${pick.j} JCoins!`;
                } catch(e) { console.error(e); showMessageBox('Spin failed.', 'error'); }
            });
        }
        // Stories
        const addStoryButton = document.getElementById('addStoryButton');
        const storyUploadInput = document.getElementById('storyUploadInput');
        const storiesBar = document.getElementById('storiesBar');
        let currentStories = [];
        if (addStoryButton && storyUploadInput) {
            addStoryButton.addEventListener('click', ()=> storyUploadInput.click());
            storyUploadInput.addEventListener('change', async (e)=>{
                const file = e.target.files[0]; if (!file || !currentUser) return;
                showMessageBox('Uploading story...', 'loading', true);
                const url = await uploadMediaToCloudinary(file);
                if (!url) { showMessageBox('Story upload failed.', 'error'); return; }
                const storiesRef = collection(db, 'artifacts', appId, 'public', 'data', 'stories');
                await addDoc(storiesRef, { userId: currentUser.uid, username: currentUserProfileData?.username||'User', mediaUrl: url, mediaType: file.type.startsWith('image/')?'image':'video', viewCount: 0, createdAt: serverTimestamp() });
                showMessageBox('Story posted!', 'success');
                fetchStories();
            });
        }
        async function fetchStories() {
            if (!storiesBar) return;
            storiesBar.innerHTML = '';
            const storiesRef = collection(db, 'artifacts', appId, 'public', 'data', 'stories');
            const qStories = query(storiesRef, orderBy('createdAt','desc'));
            const snap = await getDocs(qStories);
            const now = Date.now();
            currentStories = snap.docs
                .map(d => ({ id: d.id, ...d.data() }))
                .filter(s => (now - (s.createdAt?.toDate()?.getTime() || 0)) <= 24*60*60*1000);
            currentStories.forEach((s, idx) => {
                const item = document.createElement('div');
                item.className = 'story-item';
                const avatar = document.createElement('div');
                avatar.className = 'story-avatar';
                if (s.mediaType==='image') {
                    avatar.innerHTML = `<img src="${s.mediaUrl}" alt="story" loading="lazy" decoding="async">`;
                } else {
                    avatar.innerHTML = `<i class=\"fas fa-video\"></i>`;
                }
                const name = document.createElement('span');
                name.style.color='var(--text-light)'; name.style.fontSize='0.8rem';
                name.textContent = s.username?.split(' ')[0] || 'User';
                item.appendChild(avatar); item.appendChild(name);
                item.addEventListener('click', ()=> openStory(idx));
                storiesBar.appendChild(item);
            });
        }

        // Story viewer refs/state
        const storyViewer = document.getElementById('storyViewer');
        const storyImageEl = document.getElementById('storyImage');
        const storyVideoEl = document.getElementById('storyVideo');
        const storyViewerTitle = document.getElementById('storyViewerTitle');
        const closeStoryViewerBtn = document.getElementById('closeStoryViewer');
        const prevStoryBtn = document.getElementById('prevStoryBtn');
        const nextStoryBtn = document.getElementById('nextStoryBtn');
        let currentStoryIndex = 0;
        const viewedStoryIds = new Set();

        async function openStory(index) {
            if (!currentStories || !currentStories.length) return;
            currentStoryIndex = Math.max(0, Math.min(index, currentStories.length-1));
            const s = currentStories[currentStoryIndex];
            if (!s) return;
            if (storyViewerTitle) storyViewerTitle.textContent = `${s.username || 'Story'}`;
            if (s.mediaType === 'image') {
                if (storyVideoEl) { try { storyVideoEl.pause(); } catch{} storyVideoEl.style.display = 'none'; storyVideoEl.src=''; }
                if (storyImageEl) { storyImageEl.src = s.mediaUrl; storyImageEl.style.display = 'block'; }
            } else {
                if (storyImageEl) { storyImageEl.style.display = 'none'; storyImageEl.src=''; }
                if (storyVideoEl) { storyVideoEl.src = s.mediaUrl; storyVideoEl.style.display = 'block'; storyVideoEl.play().catch(()=>{}); }
            }
            if (storyViewer) storyViewer.classList.add('active');
            if (!viewedStoryIds.has(s.id)) {
                viewedStoryIds.add(s.id);
                try {
                    const storyDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'stories', s.id);
                    await updateDoc(storyDocRef, { viewCount: (s.viewCount || 0) + 1 });
                    s.viewCount = (s.viewCount || 0) + 1;
                } catch (e) { console.error('Failed to update viewCount', e); }
            }
            if (prevStoryBtn) prevStoryBtn.disabled = currentStoryIndex <= 0;
            if (nextStoryBtn) nextStoryBtn.disabled = currentStoryIndex >= currentStories.length-1;
        }
        function closeStoryViewer() {
            if (storyViewer) storyViewer.classList.remove('active');
            if (storyImageEl) { storyImageEl.style.display = 'none'; storyImageEl.src=''; }
            if (storyVideoEl) { try { storyVideoEl.pause(); } catch{} storyVideoEl.style.display = 'none'; storyVideoEl.src=''; }
        }
        if (closeStoryViewerBtn) closeStoryViewerBtn.addEventListener('click', closeStoryViewer);
        if (prevStoryBtn) prevStoryBtn.addEventListener('click', ()=> openStory(currentStoryIndex-1));
        if (nextStoryBtn) nextStoryBtn.addEventListener('click', ()=> openStory(currentStoryIndex+1));

        function attachInspirationEventListeners() {
            if (sharePostInspirationButton && !sharePostInspirationButton.dataset.bound) {
                sharePostInspirationButton.addEventListener('click', () => {
                    if (!isAuthReady) { showMessageBox("Please log in to share inspiration.", 'error'); return; }
                    if (!currentSystemSettings.enablePostCreation && currentUser.uid !== ADMIN_UID) { showMessageBox("Post creation is currently disabled by administrators, so sharing as a post is not possible.", 'warning'); return; }
                    const currentQuote = inspirationQuoteElement ? inspirationQuoteElement.textContent : '';
                    openShareInspirationModal();
                });
                sharePostInspirationButton.dataset.bound = '1';
            }
            if (customizeInspirationButton && !customizeInspirationButton.dataset.bound) {
                customizeInspirationButton.addEventListener('click', openCustomizeModal);
                customizeInspirationButton.dataset.bound = '1';
            }
            if (cancelCustomizeButton && !cancelCustomizeButton.dataset.bound) {
                cancelCustomizeButton.addEventListener('click', closeCustomizeModal);
                cancelCustomizeButton.dataset.bound = '1';
            }
            if (saveCustomizeButton && !saveCustomizeButton.dataset.bound) {
                saveCustomizeButton.addEventListener('click', saveInspirationType);
                saveCustomizeButton.dataset.bound = '1';
            }
            if (claimDailyBonusButton && !claimDailyBonusButton.dataset.bound) {
                claimDailyBonusButton.addEventListener('click', handleClaimDailyBonusClick);
                claimDailyBonusButton.dataset.bound = '1';
            }
            if (customizeInspirationModal && !customizeInspirationModal.dataset.boundOutsideClick) {
                customizeInspirationModal.addEventListener('click', (event) => {
                    if (event.target === customizeInspirationModal) closeCustomizeModal();
                });
                customizeInspirationModal.dataset.boundOutsideClick = '1';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize DOM elements first
            initializeDOMElements();

            // Wire post composer listeners after DOM is ready
            if (postMediaUpload) {
                postMediaUpload.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    currentMediaFile = file; // Store the selected file.
                    // Reset previews.
                    if (mediaImagePreview) mediaImagePreview.style.display = 'none';
                    if (mediaVideoPreview) mediaVideoPreview.style.display = 'none';
                    if (mediaImagePreview) mediaImagePreview.src = '';
                    if (mediaVideoPreview) mediaVideoPreview.src = '';

                    if (file) {
                    const objectUrl = URL.createObjectURL(file);
                    if (file.type.startsWith('image/')) {
                        if (mediaImagePreview) {
                            mediaImagePreview.onload = () => URL.revokeObjectURL(objectUrl);
                            mediaImagePreview.src = objectUrl;
                            mediaImagePreview.style.display = 'block';
                        }
                    } else if (file.type.startsWith('video/')) {
                        if (mediaVideoPreview) {
                            const revoke = () => { URL.revokeObjectURL(objectUrl); mediaVideoPreview.removeEventListener('loadeddata', revoke); mediaVideoPreview.removeEventListener('loadedmetadata', revoke); };
                            mediaVideoPreview.addEventListener('loadeddata', revoke);
                            mediaVideoPreview.addEventListener('loadedmetadata', revoke);
                            mediaVideoPreview.src = objectUrl;
                            mediaVideoPreview.style.display = 'block';
                        }
                    }
                }
                });
            }
            if (createPostButton) createPostButton.addEventListener('click', createNewPost);

            // Edit post modal listeners
            if (editPostMediaUpload) {
                editPostMediaUpload.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    currentEditMediaFile = file; // Store the selected file.
                    // Reset previews and hide remove media button.
                    if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                    if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                    if (editMediaImagePreview) editMediaImagePreview.src = '';
                    if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                    if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';

                    if (file) {
                        const objectUrl = URL.createObjectURL(file);
                        if (file.type.startsWith('image/')) {
                            if (editMediaImagePreview) {
                                editMediaImagePreview.onload = () => URL.revokeObjectURL(objectUrl);
                                editMediaImagePreview.src = objectUrl;
                                editMediaImagePreview.style.display = 'block';
                            }
                        } else if (file.type.startsWith('video/')) {
                            if (editMediaVideoPreview) {
                                const revoke = () => { URL.revokeObjectURL(objectUrl); editMediaVideoPreview.removeEventListener('loadeddata', revoke); editMediaVideoPreview.removeEventListener('loadedmetadata', revoke); };
                                editMediaVideoPreview.addEventListener('loadeddata', revoke);
                                editMediaVideoPreview.addEventListener('loadedmetadata', revoke);
                                editMediaVideoPreview.src = objectUrl;
                                editMediaVideoPreview.style.display = 'block';
                            }
                        }
                        if (removeEditMediaButton) removeEditMediaButton.style.display = 'inline-block'; // Show remove media button.
                    }
                });
            }
            if (removeEditMediaButton) {
                removeEditMediaButton.addEventListener('click', () => {
                    currentEditMediaFile = null;
                    currentEditMediaUrl = null;
                    currentEditMediaType = null;
                    // Clear and hide all media related elements.
                    if (editMediaImagePreview) editMediaImagePreview.style.display = 'none';
                    if (editMediaVideoPreview) editMediaVideoPreview.style.display = 'none';
                    if (editMediaImagePreview) editMediaImagePreview.src = '';
                    if (editMediaVideoPreview) editMediaVideoPreview.src = '';
                    if (editPostMediaUpload) editPostMediaUpload.value = ''; // Clear file input.
                    if (removeEditMediaButton) removeEditMediaButton.style.display = 'none';
                    showMessageBox('Media removed.', 'info');
                });
            }
            if (cancelEditPostButton) cancelEditPostButton.addEventListener('click', closeEditPostModal);
            if (saveEditedPostButton) saveEditedPostButton.addEventListener('click', saveEditedPost);

            // Ensure inspiration section listeners are attached after elements exist
            attachInspirationEventListeners();
            if (!inspirationIntervalId) startInspirationDisplay(currentUserProfileData?.inspirationType || 'motivational');

            updateStreakAndQuestsUI();
            fetchStories();
            initializeNotificationSystem();
            
            // Profile link - let it use default href behavior for now
            // Custom handler removed to prevent errors
            
                    // Initialize sidebar toggle functionality with enhanced state management
        if (sidebarToggleFab) {
            sidebarToggleFab.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleSidebar();
            });
        }
        if (sidebarCloseBtn) {
            sidebarCloseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                closeSidebar();
            });
        }
        // Swipe to close (horizontal gesture only)
        let touchStartX = null, touchStartY = null, touchActive = false;
        if (sidebarNav){
            sidebarNav.addEventListener('touchstart', (e)=>{
                touchActive = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, {passive:true});
            sidebarNav.addEventListener('touchmove', (e)=>{
                if(!touchActive || touchStartX == null || touchStartY == null) return;
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                if (Math.abs(dx) > Math.abs(dy) && dx < -60){
                    closeSidebar();
                    touchActive = false;
                    touchStartX = null;
                    touchStartY = null;
                }
            }, {passive:true});
            sidebarNav.addEventListener('touchend', ()=>{ touchActive=false; touchStartX=null; touchStartY=null; }, {passive:true});
        }
        if (sidebarLogoutLink) sidebarLogoutLink.addEventListener('click', handleLogout);
        const sidebarThemeLink = document.getElementById('sidebarThemeLink');
        if (sidebarThemeLink) sidebarThemeLink.addEventListener('click', (e) => { e.preventDefault(); if (typeof openThemePicker === 'function') openThemePicker(); });

        // Ensure sidebar starts in hidden state
        if (sidebarNav) {
            sidebarNav.classList.remove('sidebar-visible');
            sidebarNav.classList.add('sidebar-hidden');
            sidebarToggleState = false;
        }
        });

        // Comment reaction handler
        async function reactToComment(postId, commentId, type, buttonEl) {
            try {
                if (!isAuthReady || !currentUser) { showMessageBox('Please log in.', 'warning'); return; }
                if (!currentSystemSettings.enablePublicChat && currentUser.uid !== ADMIN_UID) { showMessageBox('Reactions are disabled by admin.', 'warning'); return; }
                const commentRef = doc(db, 'artifacts', appId, 'public', 'data', 'posts', postId, 'comments', commentId);
                const userReactionRef = doc(db, 'artifacts', appId, 'public', 'data', 'posts', postId, 'comments', commentId, 'userReactions', currentUser.uid);
                await runTransaction(db, async (trx) => {
                    const cSnap = await trx.get(commentRef);
                    const uSnap = await trx.get(userReactionRef);
                    if (!cSnap.exists()) throw new Error('Comment not found');
                    const data = cSnap.data();
                    const summary = Object.assign({ like:0, love:0, haha:0 }, data.reactions||{});
                    const prev = uSnap.exists() ? (uSnap.data().type||null) : null;
                    if (prev === type) {
                        summary[type] = Math.max(0, (summary[type]||0)-1);
                        trx.update(commentRef, { reactions: summary });
                        trx.delete(userReactionRef);
                    } else {
                        if (prev) summary[prev] = Math.max(0, (summary[prev]||0)-1);
                        summary[type] = (summary[type]||0)+1;
                        trx.update(commentRef, { reactions: summary });
                        trx.set(userReactionRef, { type, userId: currentUser.uid, timestamp: serverTimestamp() });
                    }
                });
                const root = buttonEl.closest('.comment-item');
                if (root) {
                    root.querySelectorAll('.comment-reaction-button').forEach(b=>{ if (b.dataset.type!==type) b.classList.remove('active'); });
                    const countEl = root.querySelector(`.comment-reactions-summary [data-type="${type}"] .count`);
                    if (countEl) {
                        const isActive = buttonEl.classList.toggle('active');
                        const n = Number(countEl.textContent||'0');
                        countEl.textContent = String(Math.max(0, n + (isActive?1:-1)));
                    }
                }
            } catch(e) { console.error('reactToComment failed', e); showMessageBox('Failed to react.', 'error'); }
        }

        // Initialize notification system
        function initializeNotificationSystem() {
            loadNotificationsFromStorage();
        }

        /**
         * Saves notifications to localStorage
         */
        function saveNotificationsToStorage() {
            try {
                localStorage.setItem('jchat_notifications', JSON.stringify(notifications));
                localStorage.setItem('jchat_unread_count', unreadNotificationCount.toString());
            } catch (error) {
                console.log('JCHAT_DEBUG: Could not save notifications to storage:', error);
            }
        }

        /**
         * Loads notifications from localStorage
         */
        function loadNotificationsFromStorage() {
            try {
                const savedNotifications = localStorage.getItem('jchat_notifications');
                const savedCount = localStorage.getItem('jchat_unread_count');
                
                if (savedNotifications) {
                    notifications = JSON.parse(savedNotifications);
                    notifications.forEach(n => n.timestamp = new Date(n.timestamp));
                }
                
                if (savedCount) {
                    unreadNotificationCount = parseInt(savedCount);
                }
                
                updateNotificationBadge(unreadNotificationCount);
            } catch (error) {
                console.log('JCHAT_DEBUG: Could not load notifications from storage:', error);
            }
        }



        // Smart Scroll logic
        const smartScrollBtn = document.getElementById('smartScrollBtn');
        let scrollTarget = 'bottom';
        function updateSmartScrollState() {
            const nearTop = window.scrollY < 50;
            const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 50);
            if (nearBottom) { scrollTarget = 'top'; if (smartScrollBtn) { smartScrollBtn.querySelector('i').className='fas fa-arrow-up'; smartScrollBtn.querySelector('.label').textContent='Top'; } }
            else { scrollTarget = 'bottom'; if (smartScrollBtn) { smartScrollBtn.querySelector('i').className='fas fa-arrow-down'; smartScrollBtn.querySelector('.label').textContent='Bottom'; } }
        }
        if (smartScrollBtn) {
            smartScrollBtn.addEventListener('click', ()=> {
                if (scrollTarget === 'bottom') {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                } else {
                                          window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
                          window.addEventListener('scroll', updateSmartScrollState, { passive: true });
            window.addEventListener('resize', updateSmartScrollState);
            document.addEventListener('DOMContentLoaded', updateSmartScrollState);
        }

        // --- PREMIUM REQUEST SYSTEM ---
        console.log("JCHAT_DEBUG: Initializing Premium Request System...");

        // Premium Request Variables
        let selectedPremiumTier = null;
        let premiumRequestModal = null;
        let premiumRequestBtn = null;

        // Initialize Premium Request System
        function initializePremiumRequestSystem() {
            premiumRequestModal = document.getElementById('premiumRequestModal');
            premiumRequestBtn = document.getElementById('premiumRequestBtn');
            
            setupPremiumRequestEventListeners();
            checkPremiumStatus();
        }

        // Setup Premium Request Event Listeners
        function setupPremiumRequestEventListeners() {
            // Premium Request Button
            if (premiumRequestBtn) {
                premiumRequestBtn.addEventListener('click', openPremiumRequestModal);
            }

            // Premium Request Modal
            if (premiumRequestModal) {
                // Tier selection
                const tierOptions = premiumRequestModal.querySelectorAll('.premium-tier-option');
                tierOptions.forEach(option => {
                    option.addEventListener('click', () => selectPremiumTier(option));
                });

                // Modal buttons
                const cancelBtn = document.getElementById('cancelPremiumRequestBtn');
                const submitBtn = document.getElementById('submitPremiumRequestBtn');

                if (cancelBtn) {
                    cancelBtn.addEventListener('click', closePremiumRequestModal);
                }

                if (submitBtn) {
                    submitBtn.addEventListener('click', submitPremiumRequest);
                }

                // Close modal on outside click
                premiumRequestModal.addEventListener('click', (event) => {
                    if (event.target === premiumRequestModal) {
                        closePremiumRequestModal();
                    }
                });
            }
        }
        // Check Premium Status
        async function checkPremiumStatus() {
            if (!currentUser) return;

            try {
                const userRef = doc(db, 'artifacts', appId, 'users', currentUser.uid);
                const userSnap = await getDoc(userRef);
                
                if (userSnap.exists()) {
                    const userData = userSnap.data();
                    const hasPremium = userData.premiumStatus && userData.premiumExpiry;
                    
                    if (hasPremium) {
                        const expiryDate = userData.premiumExpiry.toDate();
                        const isExpired = expiryDate < new Date();
                        
                        if (!isExpired) {
                            // User has active premium - hide request button
                            if (premiumRequestBtn) {
                                premiumRequestBtn.style.display = 'none';
                            }
                            return;
                        }
                    }
                }
                
                // Show premium request button if user doesn't have active premium
                if (premiumRequestBtn) {
                    premiumRequestBtn.style.display = 'flex';
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Failed to check premium status:", error);
            }
        }

        // Open Premium Request Modal
        function openPremiumRequestModal() {
            if (!currentUser) {
                showMessageBox('Please log in to request premium access.', 'warning');
                return;
            }

            if (premiumRequestModal) {
                premiumRequestModal.style.display = 'flex';
                selectedPremiumTier = null;
                
                // Reset tier selection
                const tierOptions = premiumRequestModal.querySelectorAll('.premium-tier-option');
                tierOptions.forEach(option => option.classList.remove('selected'));
            }
        }

        // Close Premium Request Modal
        function closePremiumRequestModal() {
            if (premiumRequestModal) {
                premiumRequestModal.style.display = 'none';
                selectedPremiumTier = null;
                
                // Clear message
                const messageInput = document.getElementById('premiumRequestMessage');
                if (messageInput) {
                    messageInput.value = '';
                }
            }
        }

        // Select Premium Tier
        function selectPremiumTier(option) {
            const tierOptions = premiumRequestModal.querySelectorAll('.premium-tier-option');
            tierOptions.forEach(opt => opt.classList.remove('selected'));
            
            option.classList.add('selected');
            selectedPremiumTier = option.dataset.tier;
        }

        // Submit Premium Request
        async function submitPremiumRequest() {
            if (!currentUser) {
                showMessageBox('Please log in to submit a premium request.', 'warning');
                return;
            }

            if (!selectedPremiumTier) {
                showMessageBox('Please select a premium tier.', 'info');
                return;
            }

            try {
                showMessageBox('Submitting premium request...', 'loading', true);

                const messageInput = document.getElementById('premiumRequestMessage');
                const message = messageInput ? messageInput.value.trim() : '';

                // Create premium request document
                const requestData = {
                    userId: currentUser.uid,
                    username: currentUser.displayName || currentUser.email || 'Unknown User',
                    tier: selectedPremiumTier,
                    message: message,
                    status: 'pending',
                    timestamp: serverTimestamp()
                };

                // Add to Firestore
                await addDoc(collection(db, 'artifacts', appId, 'premium_requests'), requestData);

                // Close modal
                closePremiumRequestModal();

                // Redirect to payment
                const prices = {
                    premium: 9.99,
                    vip: 19.99,
                    elite: 39.99
                };

                const price = prices[selectedPremiumTier];
                const paymentUrl = `/Wallet.html?premium=${selectedPremiumTier}&amount=${price}`;
                
                showMessageBox('Premium request submitted! Redirecting to payment...', 'success');
                
                setTimeout(() => {
                    window.location.href = paymentUrl;
                }, 2000);

                console.log(`JCHAT_DEBUG: Premium request submitted for tier ${selectedPremiumTier}`);
            } catch (error) {
                console.error("JCHAT_ERROR: Failed to submit premium request:", error);
                showMessageBox(`Failed to submit request: ${error.message}`, 'error');
            }
        }

        // Initialize Premium Request System when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializePremiumRequestSystem();
        });

        // --- PREMIUM FEATURES SYSTEM ---
        console.log("JCHAT_DEBUG: Initializing Premium Features System...");

        // Premium Features Variables
        let userPremiumStatus = null;
        let userPremiumExpiry = null;
        let activePremiumTheme = null;
        let premiumPostOptions = {
            priority: false,
            exclusive: false,
            custom: false
        };

        // Initialize Premium Features
        function initializePremiumFeatures() {
            loadPremiumStatus();
            setupPremiumFeatures();
        }

        // Load Premium Status
        async function loadPremiumStatus() {
            if (!currentUser) return;
            if (!navigator.onLine) { deactivatePremiumFeatures(); return; }

            try {
                const userRef = doc(db, 'artifacts', appId, 'users', currentUser.uid);
                const userSnap = await getDoc(userRef);
                
                if (userSnap.exists()) {
                    const userData = userSnap.data();
                    userPremiumStatus = userData.premiumStatus;
                    userPremiumExpiry = userData.premiumExpiry;
                    
                    if (userPremiumStatus && userPremiumExpiry) {
                        const expiryDate = userPremiumExpiry.toDate();
                        const isExpired = expiryDate < new Date();
                        
                        if (!isExpired) {
                            activatePremiumFeatures();
                        } else {
                            deactivatePremiumFeatures();
                        }
                    } else {
                        deactivatePremiumFeatures();
                    }
                }
            } catch (error) {
                console.error("JCHAT_ERROR: Failed to load premium status:", error);
            }
        }

        // Activate Premium Features
        function activatePremiumFeatures() {
            console.log("JCHAT_DEBUG: Activating premium features for tier:", userPremiumStatus);
            
            // Show premium badge
            const headerPremiumBadge = document.getElementById('headerPremiumBadge');
            if (headerPremiumBadge) {
                headerPremiumBadge.textContent = getPremiumBadgeIcon(userPremiumStatus);
                headerPremiumBadge.className = `premium-badge ${userPremiumStatus}-badge`;
                headerPremiumBadge.style.display = 'inline-flex';
            }

            // Show premium features section
            const premiumFeaturesSection = document.getElementById('premiumFeaturesSection');
            if (premiumFeaturesSection) {
                premiumFeaturesSection.style.display = 'block';
            }

            // Show premium post options
            const premiumPostOptions = document.getElementById('premiumPostOptions');
            if (premiumPostOptions) {
                premiumPostOptions.style.display = 'flex';
            }

            // Hide premium request button
            const premiumRequestBtn = document.getElementById('premiumRequestBtn');
            if (premiumRequestBtn) {
                premiumRequestBtn.style.display = 'none';
            }

            // Apply saved theme
            const savedTheme = localStorage.getItem(`premium_theme_${currentUser.uid}`);
            if (savedTheme) {
                applyPremiumTheme(savedTheme);
            }

            // Enable premium features based on tier
            enablePremiumFeaturesByTier();
        }

        // Deactivate Premium Features
        function deactivatePremiumFeatures() {
            console.log("JCHAT_DEBUG: Deactivating premium features");
            
            // Hide premium badge
            const headerPremiumBadge = document.getElementById('headerPremiumBadge');
            if (headerPremiumBadge) {
                headerPremiumBadge.style.display = 'none';
            }

            // Hide premium features section
            const premiumFeaturesSection = document.getElementById('premiumFeaturesSection');
            if (premiumFeaturesSection) {
                premiumFeaturesSection.style.display = 'none';
            }

            // Hide premium post options
            const premiumPostOptions = document.getElementById('premiumPostOptions');
            if (premiumPostOptions) {
                premiumPostOptions.style.display = 'none';
            }

            // Hide premium request button (never show this CTA)
            const premiumRequestBtn = document.getElementById('premiumRequestBtn');
            if (premiumRequestBtn) {
                premiumRequestBtn.style.display = 'none';
            }

            // Remove premium theme
            removePremiumTheme();
        }

        // Get Premium Badge Icon
        function getPremiumBadgeIcon(tier) {
            switch (tier) {
                case 'premium': return '🌟';
                case 'vip': return '💎';
                case 'elite': return '👑';
                default: return '🌟';
            }
        }

        // Enable Premium Features by Tier
        function enablePremiumFeaturesByTier() {
            const features = {
                premium: ['themes', 'ad-free', 'basic-support'],
                vip: ['themes', 'ad-free', 'priority-support', 'advanced-features'],
                elite: ['themes', 'ad-free', 'priority-support', 'advanced-features', 'exclusive-content', 'custom-features']
            };

            const userFeatures = features[userPremiumStatus] || [];
            console.log("JCHAT_DEBUG: Enabled features for tier", userPremiumStatus, ":", userFeatures);
        }

        // Apply Premium Theme
        function applyPremiumTheme(themeName) {
            if (!currentUser) return;

            // Remove existing premium themes
            removePremiumTheme();

            // Apply new theme
            document.body.classList.add(`premium-theme-${themeName}`);
            activePremiumTheme = themeName;

            // Save theme preference
            localStorage.setItem(`premium_theme_${currentUser.uid}`, themeName);

            showMessageBox(`Premium theme applied: ${themeName}`, 'success');
            console.log(`JCHAT_DEBUG: Applied premium theme: ${themeName}`);
        }

        // Remove Premium Theme
        function removePremiumTheme() {
            document.body.classList.remove('premium-theme-dark', 'premium-theme-neon', 'premium-theme-glass');
            activePremiumTheme = null;
        }

        // Toggle Premium Post Option
        function togglePremiumPostOption(option) {
            if (!currentUser || !userPremiumStatus) {
                showMessageBox('Premium feature requires active subscription.', 'warning');
                return;
            }

            premiumPostOptions[option] = !premiumPostOptions[option];
            
            // Update UI
            const optionElement = event.target.closest('.premium-post-option');
            if (optionElement) {
                if (premiumPostOptions[option]) {
                    optionElement.classList.add('active');
                } else {
                    optionElement.classList.remove('active');
                }
            }

            console.log(`JCHAT_DEBUG: Toggled premium post option: ${option} = ${premiumPostOptions[option]}`);
        }

        // Setup Premium Features
        function setupPremiumFeatures() {
            // Theme buttons
            const themeButtons = document.querySelectorAll('[onclick^="applyPremiumTheme"]');
            themeButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    const themeName = button.getAttribute('onclick').match(/'([^']+)'/)[1];
                    applyPremiumTheme(themeName);
                });
            });
        }

        // Enhanced Post Creation with Premium Features
        const originalCreatePost = window.createPost;
        window.createPost = async function() {
            if (!currentUser) {
                showMessageBox("Please log in to create a post.", 'error');
                return;
            }

            // Check if any premium post options are active
            const hasPremiumOptions = Object.values(premiumPostOptions).some(option => option);
            
            if (hasPremiumOptions && !userPremiumStatus) {
                showMessageBox("Premium post features require an active subscription.", 'warning');
                return;
            }

            // Call original function with premium data
            const postData = {
                ...await originalCreatePost(),
                premiumOptions: hasPremiumOptions ? premiumPostOptions : null,
                premiumTier: userPremiumStatus
            };

            return postData;
        };

        // Enhanced Post Display with Premium Features
        function createPostCard(postData) {
            const postCard = document.createElement('div');
            postCard.className = 'post-card';
            postCard.dataset.postId = postData.id;

            // Add premium styling if post has premium options
            if (postData.premiumOptions) {
                postCard.classList.add('premium-post');
                
                if (postData.premiumOptions.priority) {
                    postCard.classList.add('priority-post');
                }
                if (postData.premiumOptions.exclusive) {
                    postCard.classList.add('exclusive-post');
                }
                if (postData.premiumOptions.custom) {
                    postCard.classList.add('custom-styled-post');
                }
            }

            // Add premium badge to post header
            let premiumBadge = '';
            if (postData.premiumTier) {
                const badgeIcon = getPremiumBadgeIcon(postData.premiumTier);
                premiumBadge = `<span class="premium-badge ${postData.premiumTier}-badge">${badgeIcon}</span>`;
            }

            postCard.innerHTML = `
                <div class="post-header">
                    <div class="post-user-info">
                        <img src="${postData.userPhotoURL || '/default-avatar.png'}" alt="User Avatar" class="post-avatar">
                        <div class="post-user-details">
                            <div class="post-username">
                                ${postData.username} ${premiumBadge}
                            </div>
                            <div class="post-timestamp">${formatTimestamp(postData.timestamp)}</div>
                        </div>
                    </div>
                    ${postData.premiumOptions ? `
                        <div class="premium-post-indicators">
                            ${postData.premiumOptions.priority ? '<span class="premium-indicator priority">⭐ Priority</span>' : ''}
                            ${postData.premiumOptions.exclusive ? '<span class="premium-indicator exclusive">👑 Exclusive</span>' : ''}
                            ${postData.premiumOptions.custom ? '<span class="premium-indicator custom">✨ Custom</span>' : ''}
                        </div>
                    ` : ''}
                </div>
                <div class="post-content">
                    <p class="post-text">${postData.content}</p>
                    ${postData.mediaURL ? `<img src="${postData.mediaURL}" alt="Post Media" class="post-media">` : ''}
                </div>
                <div class="post-actions">
                    <button class="post-action-btn like-btn" onclick="likePost('${postData.id}')">
                        <i class="fas fa-heart"></i> <span>${postData.likes || 0}</span>
                    </button>
                    <button class="post-action-btn comment-btn" onclick="showComments('${postData.id}')">
                        <i class="fas fa-comment"></i> <span>${postData.comments?.length || 0}</span>
                    </button>
                    <button class="post-action-btn share-btn" onclick="sharePost('${postData.id}')">
                        <i class="fas fa-share"></i>
                    </button>
                </div>
            `;

            return postCard;
        }

        // Premium Post Styling
        const premiumPostStyles = `
            <style>
                .premium-post {
                    border: 2px solid rgba(255, 215, 0, 0.3);
                    background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(255, 215, 0, 0.02));
                }

                .priority-post {
                    border-left: 4px solid #FFD700;
                }

                .exclusive-post {
                    background: linear-gradient(135deg, rgba(255, 107, 53, 0.1), rgba(255, 107, 53, 0.05));
                    border-color: rgba(255, 107, 53, 0.4);
                }

                .custom-styled-post {
                    background: linear-gradient(135deg, rgba(0, 213, 255, 0.1), rgba(255, 46, 146, 0.05));
                    border-color: rgba(0, 213, 255, 0.4);
                }

                .premium-post-indicators {
                    display: flex;
                    gap: 5px;
                    margin-top: 5px;
                }

                .premium-indicator {
                    padding: 2px 6px;
                    border-radius: 10px;
                    font-size: 0.7rem;
                    font-weight: 600;
                }

                .premium-indicator.priority {
                    background: rgba(255, 215, 0, 0.2);
                    color: #FFD700;
                }

                .premium-indicator.exclusive {
                    background: rgba(255, 107, 53, 0.2);
                    color: #FF6B35;
                }

                .premium-indicator.custom {
                    background: rgba(0, 213, 255, 0.2);
                    color: #00D5FF;
                }
            </style>
        `;

        // Inject premium post styles
        document.head.insertAdjacentHTML('beforeend', premiumPostStyles);

        // Initialize Premium Features when user is loaded
        if (currentUser) {
            initializePremiumFeatures();
        }
        // Listen for auth state changes
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                initializePremiumFeatures();
            } else {
                deactivatePremiumFeatures();
            }
        });
    </script>
	
</body>
</html>
